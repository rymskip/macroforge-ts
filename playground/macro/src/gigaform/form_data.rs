//! Generates the fromFormData() function for parsing FormData with type coercion.

use macroforge_ts::macros::ts_template;
use macroforge_ts::ts_syn::TsStream;

use crate::gigaform::parser::ParsedField;

/// Generates the fromFormData function.
pub fn generate(interface_name: &str, fields: &[ParsedField]) -> TsStream {
    let field_extractions = generate_field_extractions(fields, "");

    ts_template! {
        {>> "Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize)." <<}
        export function fromFormData(formData: FormData): Result<@{interface_name}, Array<{ field: string; message: string }>> {
            const obj: Record<string, unknown> = {};

            @{field_extractions}

            // Delegate validation to the fromStringifiedJSON generated by @derive(Deserialize)
            return @{interface_name}.fromStringifiedJSON(JSON.stringify(obj));
        }
    }
}

/// Generates the field extraction statements.
fn generate_field_extractions(fields: &[ParsedField], prefix: &str) -> String {
    fields
        .iter()
        .map(|field| generate_field_extraction(field, prefix))
        .collect::<Vec<_>>()
        .join("\n            ")
}

/// Generates extraction code for a single field.
fn generate_field_extraction(field: &ParsedField, prefix: &str) -> String {
    let name = &field.name;
    let form_key = if prefix.is_empty() {
        name.clone()
    } else {
        format!("{prefix}.{name}")
    };

    let ts_type = field.ts_type.trim();

    // Handle different types
    if field.is_array {
        generate_array_extraction(name, &form_key, field)
    } else if field.is_nested {
        generate_nested_extraction(name, &form_key, field)
    } else {
        generate_primitive_extraction(name, &form_key, ts_type, field.optional)
    }
}

/// Generates extraction for primitive types.
fn generate_primitive_extraction(
    name: &str,
    form_key: &str,
    ts_type: &str,
    optional: bool,
) -> String {
    let base_type = extract_base_type(ts_type);

    match base_type {
        "string" => {
            if optional {
                format!(
                    r#"obj.{name} = formData.get("{form_key}") ?? undefined;"#
                )
            } else {
                format!(
                    r#"obj.{name} = formData.get("{form_key}") ?? "";"#
                )
            }
        }
        "number" => {
            let default = if optional { "undefined" } else { "0" };
            format!(
                r#"{{
                const {name}Str = formData.get("{form_key}");
                obj.{name} = {name}Str ? parseFloat({name}Str as string) : {default};
                if (obj.{name} !== undefined && Number.isNaN(obj.{name})) obj.{name} = {default};
            }}"#
            )
        }
        "boolean" => {
            // FormData booleans: "true"/"on" = true, absent/other = false
            format!(
                r#"{{
                const {name}Val = formData.get("{form_key}");
                obj.{name} = {name}Val === "true" || {name}Val === "on" || {name}Val === "1";
            }}"#
            )
        }
        "Date" => {
            if optional {
                format!(
                    r#"{{
                const {name}Str = formData.get("{form_key}");
                obj.{name} = {name}Str ? new Date({name}Str as string) : undefined;
            }}"#
                )
            } else {
                format!(
                    r#"{{
                const {name}Str = formData.get("{form_key}");
                obj.{name} = {name}Str ? new Date({name}Str as string) : new Date();
            }}"#
                )
            }
        }
        "bigint" => {
            if optional {
                format!(
                    r#"{{
                const {name}Str = formData.get("{form_key}");
                obj.{name} = {name}Str ? BigInt({name}Str as string) : undefined;
            }}"#
                )
            } else {
                format!(
                    r#"{{
                const {name}Str = formData.get("{form_key}");
                obj.{name} = {name}Str ? BigInt({name}Str as string) : 0n;
            }}"#
                )
            }
        }
        _ => {
            // Unknown type - treat as string
            if optional {
                format!(
                    r#"obj.{name} = formData.get("{form_key}") ?? undefined;"#
                )
            } else {
                format!(
                    r#"obj.{name} = formData.get("{form_key}") ?? "";"#
                )
            }
        }
    }
}

/// Generates extraction for array types.
fn generate_array_extraction(name: &str, form_key: &str, field: &ParsedField) -> String {
    let element_type = field
        .array_element_type
        .as_deref()
        .unwrap_or("string");
    let base_element = extract_base_type(element_type);

    match base_element {
        "string" => {
            format!(
                r#"obj.{name} = formData.getAll("{form_key}") as Array<string>;"#
            )
        }
        "number" => {
            format!(
                r#"obj.{name} = formData.getAll("{form_key}").map(v => parseFloat(v as string)).filter(n => !Number.isNaN(n));"#
            )
        }
        "boolean" => {
            format!(
                r#"obj.{name} = formData.getAll("{form_key}").map(v => v === "true" || v === "on" || v === "1");"#
            )
        }
        _ => {
            // For nested types in arrays, we need to handle indexed fields
            // FormData would have fields like: items.0.name, items.0.value, items.1.name, etc.
            format!(
                r#"{{
                // Collect array items from indexed form fields
                const {name}Items: Array<Record<string, unknown>> = [];
                let idx = 0;
                while (formData.has("{form_key}." + idx + ".") || idx === 0) {{
                    // Check if any field with this index exists
                    const hasAny = Array.from(formData.keys()).some(k => k.startsWith("{form_key}." + idx + "."));
                    if (!hasAny && idx > 0) break;
                    if (hasAny) {{
                        const item: Record<string, unknown> = {{}};
                        for (const [key, value] of formData.entries()) {{
                            if (key.startsWith("{form_key}." + idx + ".")) {{
                                const fieldName = key.slice("{form_key}.".length + String(idx).length + 1);
                                item[fieldName] = value;
                            }}
                        }}
                        {name}Items.push(item);
                    }}
                    idx++;
                    if (idx > 1000) break; // Safety limit
                }}
                obj.{name} = {name}Items;
            }}"#
            )
        }
    }
}

/// Generates extraction for nested object types.
fn generate_nested_extraction(name: &str, form_key: &str, field: &ParsedField) -> String {
    let _nested_type = field.nested_type.as_deref().unwrap_or("unknown");

    // For nested types that also have Gigaform, we can delegate to their fromFormData
    // But since we don't know the fields at macro time, we collect by prefix
    format!(
        r#"{{
            // Collect nested object fields with prefix "{form_key}."
            const {name}Obj: Record<string, unknown> = {{}};
            for (const [key, value] of formData.entries()) {{
                if (key.startsWith("{form_key}.")) {{
                    const fieldName = key.slice("{form_key}.".length);
                    // Handle deeper nesting by splitting on dots
                    const parts = fieldName.split(".");
                    let current = {name}Obj;
                    for (let i = 0; i < parts.length - 1; i++) {{
                        const part = parts[i];
                        if (!(part in current)) {{
                            current[part] = {{}};
                        }}
                        current = current[part] as Record<string, unknown>;
                    }}
                    current[parts[parts.length - 1]] = value;
                }}
            }}
            obj.{name} = {name}Obj;
        }}"#
    )
}

/// Extracts the base type from a potentially nullable/optional type.
fn extract_base_type(ts_type: &str) -> &str {
    let trimmed = ts_type.trim();

    // Handle "T | null", "null | T", "T | undefined", etc.
    if trimmed.contains('|') {
        for part in trimmed.split('|') {
            let p = part.trim();
            if p != "null" && p != "undefined" {
                return p;
            }
        }
    }

    trimmed
}
