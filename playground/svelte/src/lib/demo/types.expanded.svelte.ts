import { SerializeContext } from "macroforge/serde";
import { Result } from "macroforge/utils";
import { DeserializeContext } from "macroforge/serde";
import { DeserializeError } from "macroforge/serde";
import type { DeserializeOptions } from "macroforge/serde";
import { PendingRef } from "macroforge/serde";
import { Option } from "macroforge/utils";
import type { ArrayFieldController } from "@playground/macro/gigaform";
/** import macro {Gigaform} from "@playground/macro"; */

export interface User {
  id: string;
  email: string | null;

  firstName: string;

  lastName: string;
  password: string | null;
  metadata: Metadata | null;
  settings: Settings;

  role: UserRole;
  emailVerified: boolean;
  verificationToken: string | null;
  verificationExpires: string | null;
  passwordResetToken: string | null;
  passwordResetExpires: string | null;
  permissions: AppPermissions;
}

export namespace User {
  export function defaultValue(): User {
    return {
      id: "",
      email: null,
      firstName: "",
      lastName: "",
      password: null,
      metadata: null,
      settings: Settings.defaultValue(),
      role: "Administrator",
      emailVerified: false,
      verificationToken: null,
      verificationExpires: null,
      passwordResetToken: null,
      passwordResetExpires: null,
      permissions: AppPermissions.defaultValue(),
    } as User;
  }
}

export namespace User {
  export function toStringifiedJSON(self: User): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: User): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: User,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "User", __id };
    result["id"] = self.id;
    if (self.email !== null) {
      result["email"] =
        typeof (self.email as any)?.__serialize === "function"
          ? (self.email as any).__serialize(ctx)
          : self.email;
    } else {
      result["email"] = null;
    }
    result["firstName"] = self.firstName;
    result["lastName"] = self.lastName;
    if (self.password !== null) {
      result["password"] =
        typeof (self.password as any)?.__serialize === "function"
          ? (self.password as any).__serialize(ctx)
          : self.password;
    } else {
      result["password"] = null;
    }
    if (self.metadata !== null) {
      result["metadata"] =
        typeof (self.metadata as any)?.__serialize === "function"
          ? (self.metadata as any).__serialize(ctx)
          : self.metadata;
    } else {
      result["metadata"] = null;
    }
    result["settings"] =
      typeof (self.settings as any)?.__serialize === "function"
        ? (self.settings as any).__serialize(ctx)
        : self.settings;
    result["role"] =
      typeof (self.role as any)?.__serialize === "function"
        ? (self.role as any).__serialize(ctx)
        : self.role;
    result["emailVerified"] = self.emailVerified;
    if (self.verificationToken !== null) {
      result["verificationToken"] =
        typeof (self.verificationToken as any)?.__serialize === "function"
          ? (self.verificationToken as any).__serialize(ctx)
          : self.verificationToken;
    } else {
      result["verificationToken"] = null;
    }
    if (self.verificationExpires !== null) {
      result["verificationExpires"] =
        typeof (self.verificationExpires as any)?.__serialize === "function"
          ? (self.verificationExpires as any).__serialize(ctx)
          : self.verificationExpires;
    } else {
      result["verificationExpires"] = null;
    }
    if (self.passwordResetToken !== null) {
      result["passwordResetToken"] =
        typeof (self.passwordResetToken as any)?.__serialize === "function"
          ? (self.passwordResetToken as any).__serialize(ctx)
          : self.passwordResetToken;
    } else {
      result["passwordResetToken"] = null;
    }
    if (self.passwordResetExpires !== null) {
      result["passwordResetExpires"] =
        typeof (self.passwordResetExpires as any)?.__serialize === "function"
          ? (self.passwordResetExpires as any).__serialize(ctx)
          : self.passwordResetExpires;
    } else {
      result["passwordResetExpires"] = null;
    }
    result["permissions"] =
      typeof (self.permissions as any)?.__serialize === "function"
        ? (self.permissions as any).__serialize(ctx)
        : self.permissions;
    return result;
  }
}

export namespace User {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<User, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<User, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "User.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): User | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "User.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("email" in obj)) {
      errors.push({ field: "email", message: "missing required field" });
    }
    if (!("firstName" in obj)) {
      errors.push({ field: "firstName", message: "missing required field" });
    }
    if (!("lastName" in obj)) {
      errors.push({ field: "lastName", message: "missing required field" });
    }
    if (!("password" in obj)) {
      errors.push({ field: "password", message: "missing required field" });
    }
    if (!("metadata" in obj)) {
      errors.push({ field: "metadata", message: "missing required field" });
    }
    if (!("settings" in obj)) {
      errors.push({ field: "settings", message: "missing required field" });
    }
    if (!("role" in obj)) {
      errors.push({ field: "role", message: "missing required field" });
    }
    if (!("emailVerified" in obj)) {
      errors.push({
        field: "emailVerified",
        message: "missing required field",
      });
    }
    if (!("verificationToken" in obj)) {
      errors.push({
        field: "verificationToken",
        message: "missing required field",
      });
    }
    if (!("verificationExpires" in obj)) {
      errors.push({
        field: "verificationExpires",
        message: "missing required field",
      });
    }
    if (!("passwordResetToken" in obj)) {
      errors.push({
        field: "passwordResetToken",
        message: "missing required field",
      });
    }
    if (!("passwordResetExpires" in obj)) {
      errors.push({
        field: "passwordResetExpires",
        message: "missing required field",
      });
    }
    if (!("permissions" in obj)) {
      errors.push({ field: "permissions", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_email = obj["email"];
      instance.email = __raw_email;
    }
    {
      const __raw_firstName = obj["firstName"];
      instance.firstName = __raw_firstName;
    }
    {
      const __raw_lastName = obj["lastName"];
      instance.lastName = __raw_lastName;
    }
    {
      const __raw_password = obj["password"];
      instance.password = __raw_password;
    }
    {
      const __raw_metadata = obj["metadata"];
      instance.metadata = __raw_metadata;
    }
    {
      const __raw_settings = obj["settings"];
      if (typeof (Settings as any)?.__deserialize === "function") {
        const __result = (Settings as any).__deserialize(__raw_settings, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "settings", __result);
      } else {
        instance.settings = __raw_settings;
      }
    }
    {
      const __raw_role = obj["role"];
      if (typeof (UserRole as any)?.__deserialize === "function") {
        const __result = (UserRole as any).__deserialize(__raw_role, ctx);
        ctx.assignOrDefer(instance, "role", __result);
      } else {
        instance.role = __raw_role;
      }
    }
    {
      const __raw_emailVerified = obj["emailVerified"];
      instance.emailVerified = __raw_emailVerified;
    }
    {
      const __raw_verificationToken = obj["verificationToken"];
      instance.verificationToken = __raw_verificationToken;
    }
    {
      const __raw_verificationExpires = obj["verificationExpires"];
      instance.verificationExpires = __raw_verificationExpires;
    }
    {
      const __raw_passwordResetToken = obj["passwordResetToken"];
      instance.passwordResetToken = __raw_passwordResetToken;
    }
    {
      const __raw_passwordResetExpires = obj["passwordResetExpires"];
      instance.passwordResetExpires = __raw_passwordResetExpires;
    }
    {
      const __raw_permissions = obj["permissions"];
      if (typeof (AppPermissions as any)?.__deserialize === "function") {
        const __result = (AppPermissions as any).__deserialize(
          __raw_permissions,
          ctx,
        );
        ctx.assignOrDefer(instance, "permissions", __result);
      } else {
        instance.permissions = __raw_permissions;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as User;
  }
}

export namespace User {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    email: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
    password: Option<Array<string>>;
    metadata: Option<Array<string>>;
    settings: Option<Array<string>>;
    role: Option<Array<string>>;
    emailVerified: Option<Array<string>>;
    verificationToken: Option<Array<string>>;
    verificationExpires: Option<Array<string>>;
    passwordResetToken: Option<Array<string>>;
    passwordResetExpires: Option<Array<string>>;
    permissions: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      email: Option<boolean>;
      firstName: Option<boolean>;
      lastName: Option<boolean>;
      password: Option<boolean>;
      metadata: Option<boolean>;
      settings: Option<boolean>;
      role: Option<boolean>;
      emailVerified: Option<boolean>;
      verificationToken: Option<boolean>;
      verificationExpires: Option<boolean>;
      passwordResetToken: Option<boolean>;
      passwordResetExpires: Option<boolean>;
      permissions: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly email: FieldController<string | null>;
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
    readonly password: FieldController<string | null>;
    readonly metadata: FieldController<Metadata | null>;
    readonly settings: FieldController<Settings>;
    readonly role: FieldController<UserRole>;
    readonly emailVerified: FieldController<boolean>;
    readonly verificationToken: FieldController<string | null>;
    readonly verificationExpires: FieldController<string | null>;
    readonly passwordResetToken: FieldController<string | null>;
    readonly passwordResetExpires: FieldController<string | null>;
    readonly permissions: FieldController<AppPermissions>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: User;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<User, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<User>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<User>,
  ): Gigaform {
    let data = $state({ ...User.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      email: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      password: Option.none(),
      metadata: Option.none(),
      settings: Option.none(),
      role: Option.none(),
      emailVerified: Option.none(),
      verificationToken: Option.none(),
      verificationExpires: Option.none(),
      passwordResetToken: Option.none(),
      passwordResetExpires: Option.none(),
      permissions: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      email: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      password: Option.none(),
      metadata: Option.none(),
      settings: Option.none(),
      role: Option.none(),
      emailVerified: Option.none(),
      verificationToken: Option.none(),
      verificationExpires: Option.none(),
      passwordResetToken: Option.none(),
      passwordResetExpires: Option.none(),
      permissions: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: string | null) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "email")
              .map((e) => e.message);
          }
          return [];
        },
      },
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },

        get: () => data.firstName,
        set: (value: string) => {
          data.firstName = value;
        },
        getError: () => errors.firstName,
        setError: (value: Option<Array<string>>) => {
          errors.firstName = value;
        },
        getTainted: () => tainted.firstName,
        setTainted: (value: Option<boolean>) => {
          tainted.firstName = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "firstName")
              .map((e) => e.message);
          }
          return [];
        },
      },
      lastName: {
        path: ["lastName"] as const,
        name: "lastName",
        constraints: { required: true },

        get: () => data.lastName,
        set: (value: string) => {
          data.lastName = value;
        },
        getError: () => errors.lastName,
        setError: (value: Option<Array<string>>) => {
          errors.lastName = value;
        },
        getTainted: () => tainted.lastName,
        setTainted: (value: Option<boolean>) => {
          tainted.lastName = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lastName")
              .map((e) => e.message);
          }
          return [];
        },
      },
      password: {
        path: ["password"] as const,
        name: "password",
        constraints: { required: true },

        get: () => data.password,
        set: (value: string | null) => {
          data.password = value;
        },
        getError: () => errors.password,
        setError: (value: Option<Array<string>>) => {
          errors.password = value;
        },
        getTainted: () => tainted.password,
        setTainted: (value: Option<boolean>) => {
          tainted.password = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "password")
              .map((e) => e.message);
          }
          return [];
        },
      },
      metadata: {
        path: ["metadata"] as const,
        name: "metadata",
        constraints: { required: true },

        get: () => data.metadata,
        set: (value: Metadata | null) => {
          data.metadata = value;
        },
        getError: () => errors.metadata,
        setError: (value: Option<Array<string>>) => {
          errors.metadata = value;
        },
        getTainted: () => tainted.metadata,
        setTainted: (value: Option<boolean>) => {
          tainted.metadata = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "metadata")
              .map((e) => e.message);
          }
          return [];
        },
      },
      settings: {
        path: ["settings"] as const,
        name: "settings",
        constraints: { required: true },

        get: () => data.settings,
        set: (value: Settings) => {
          data.settings = value;
        },
        getError: () => errors.settings,
        setError: (value: Option<Array<string>>) => {
          errors.settings = value;
        },
        getTainted: () => tainted.settings,
        setTainted: (value: Option<boolean>) => {
          tainted.settings = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "settings")
              .map((e) => e.message);
          }
          return [];
        },
      },
      role: {
        path: ["role"] as const,
        name: "role",
        constraints: { required: true },

        get: () => data.role,
        set: (value: UserRole) => {
          data.role = value;
        },
        getError: () => errors.role,
        setError: (value: Option<Array<string>>) => {
          errors.role = value;
        },
        getTainted: () => tainted.role,
        setTainted: (value: Option<boolean>) => {
          tainted.role = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "role")
              .map((e) => e.message);
          }
          return [];
        },
      },
      emailVerified: {
        path: ["emailVerified"] as const,
        name: "emailVerified",
        constraints: { required: true },

        get: () => data.emailVerified,
        set: (value: boolean) => {
          data.emailVerified = value;
        },
        getError: () => errors.emailVerified,
        setError: (value: Option<Array<string>>) => {
          errors.emailVerified = value;
        },
        getTainted: () => tainted.emailVerified,
        setTainted: (value: Option<boolean>) => {
          tainted.emailVerified = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "emailVerified")
              .map((e) => e.message);
          }
          return [];
        },
      },
      verificationToken: {
        path: ["verificationToken"] as const,
        name: "verificationToken",
        constraints: { required: true },

        get: () => data.verificationToken,
        set: (value: string | null) => {
          data.verificationToken = value;
        },
        getError: () => errors.verificationToken,
        setError: (value: Option<Array<string>>) => {
          errors.verificationToken = value;
        },
        getTainted: () => tainted.verificationToken,
        setTainted: (value: Option<boolean>) => {
          tainted.verificationToken = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "verificationToken")
              .map((e) => e.message);
          }
          return [];
        },
      },
      verificationExpires: {
        path: ["verificationExpires"] as const,
        name: "verificationExpires",
        constraints: { required: true },

        get: () => data.verificationExpires,
        set: (value: string | null) => {
          data.verificationExpires = value;
        },
        getError: () => errors.verificationExpires,
        setError: (value: Option<Array<string>>) => {
          errors.verificationExpires = value;
        },
        getTainted: () => tainted.verificationExpires,
        setTainted: (value: Option<boolean>) => {
          tainted.verificationExpires = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "verificationExpires")
              .map((e) => e.message);
          }
          return [];
        },
      },
      passwordResetToken: {
        path: ["passwordResetToken"] as const,
        name: "passwordResetToken",
        constraints: { required: true },

        get: () => data.passwordResetToken,
        set: (value: string | null) => {
          data.passwordResetToken = value;
        },
        getError: () => errors.passwordResetToken,
        setError: (value: Option<Array<string>>) => {
          errors.passwordResetToken = value;
        },
        getTainted: () => tainted.passwordResetToken,
        setTainted: (value: Option<boolean>) => {
          tainted.passwordResetToken = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "passwordResetToken")
              .map((e) => e.message);
          }
          return [];
        },
      },
      passwordResetExpires: {
        path: ["passwordResetExpires"] as const,
        name: "passwordResetExpires",
        constraints: { required: true },

        get: () => data.passwordResetExpires,
        set: (value: string | null) => {
          data.passwordResetExpires = value;
        },
        getError: () => errors.passwordResetExpires,
        setError: (value: Option<Array<string>>) => {
          errors.passwordResetExpires = value;
        },
        getTainted: () => tainted.passwordResetExpires,
        setTainted: (value: Option<boolean>) => {
          tainted.passwordResetExpires = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "passwordResetExpires")
              .map((e) => e.message);
          }
          return [];
        },
      },
      permissions: {
        path: ["permissions"] as const,
        name: "permissions",
        constraints: { required: true },

        get: () => data.permissions,
        set: (value: AppPermissions) => {
          data.permissions = value;
        },
        getError: () => errors.permissions,
        setError: (value: Option<Array<string>>) => {
          errors.permissions = value;
        },
        getTainted: () => tainted.permissions,
        setTainted: (value: Option<boolean>) => {
          tainted.permissions = value;
        },
        validate: (): Array<string> => {
          const result = User.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "permissions")
              .map((e) => e.message);
          }
          return [];
        },
      },
    };
    function validate(): Result<
      User,
      Array<{ field: string; message: string }>
    > {
      return User.fromObject(data);
    }
    function reset(newOverrides?: Partial<User>): void {
      data = { ...User.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        email: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        password: Option.none(),
        metadata: Option.none(),
        settings: Option.none(),
        role: Option.none(),
        emailVerified: Option.none(),
        verificationToken: Option.none(),
        verificationExpires: Option.none(),
        passwordResetToken: Option.none(),
        passwordResetExpires: Option.none(),
        permissions: Option.none(),
      };
      tainted = {
        id: Option.none(),
        email: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        password: Option.none(),
        metadata: Option.none(),
        settings: Option.none(),
        role: Option.none(),
        emailVerified: Option.none(),
        verificationToken: Option.none(),
        verificationExpires: Option.none(),
        passwordResetToken: Option.none(),
        passwordResetExpires: Option.none(),
        permissions: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<User, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.email = formData.get("email") ?? "";
    obj.firstName = formData.get("firstName") ?? "";
    obj.lastName = formData.get("lastName") ?? "";
    obj.password = formData.get("password") ?? "";
    obj.metadata = formData.get("metadata") ?? "";
    {
      // Collect nested object fields with prefix "settings."
      const settingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("settings.")) {
          const fieldName = key.slice("settings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = settingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.settings = settingsObj;
    }
    {
      // Collect nested object fields with prefix "role."
      const roleObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("role.")) {
          const fieldName = key.slice("role.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = roleObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.settings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.settings = v;
          });
        } else {
          instance.settings = __result;
        }
      } else {
        instance.settings = __raw_settings;
      }
    }
    {
      const __raw_role = obj["role"];
      if (typeof (UserRole as any)?.__deserialize === "function") {
        const __result = (UserRole as any).__deserialize(__raw_role, ctx);
        if (PendingRef.is(__result)) {
          instance.role = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.role = v;
          });
        } else {
          instance.role = __result;
        }
      } else {
        instance.role = __raw_role;
      }
    }
    {
      const __raw_emailVerified = obj["emailVerified"];
      instance.emailVerified = __raw_emailVerified;
    }
    {
      const __raw_verificationToken = obj["verificationToken"];
      instance.verificationToken = __raw_verificationToken;
    }
    {
      const __raw_verificationExpires = obj["verificationExpires"];
      instance.verificationExpires = __raw_verificationExpires;
    }
    {
      const __raw_passwordResetToken = obj["passwordResetToken"];
      instance.passwordResetToken = __raw_passwordResetToken;
    }
    {
      const __raw_passwordResetExpires = obj["passwordResetExpires"];
      instance.passwordResetExpires = __raw_passwordResetExpires;
    }
    {
      const __raw_permissions = obj["permissions"];
      if (typeof (AppPermissions as any)?.__deserialize === "function") {
        const __result = (AppPermissions as any).__deserialize(
          __raw_permissions,
          ctx,
        );
        if (PendingRef.is(__result)) {
          instance.permissions = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.permissions = v;
          });
        } else {
          instance.permissions = __result;
        }
      } else {
        instance.permissions = __raw_permissions;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as User;
  }
  export function validateField<K extends keyof User>(
    field: K,
    value: User[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "firstName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "firstName", message: "must not be empty" });
        }
        break;
      }
      case "lastName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "lastName", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<User>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("firstName" in partial && partial.firstName !== undefined) {
      const __val = partial.firstName as string;
      if (__val.length === 0) {
        errors.push({ field: "firstName", message: "must not be empty" });
      }
    }
    if ("lastName" in partial && partial.lastName !== undefined) {
      const __val = partial.lastName as string;
      if (__val.length === 0) {
        errors.push({ field: "lastName", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace User {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    email: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
    password: Option<Array<string>>;
    metadata: Option<Array<string>>;
    settings: Option<Array<string>>;
    role: Option<Array<string>>;
    emailVerified: Option<Array<string>>;
    verificationToken: Option<Array<string>>;
    verificationExpires: Option<Array<string>>;
    passwordResetToken: Option<Array<string>>;
    passwordResetExpires: Option<Array<string>>;
    permissions: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      email: Option<boolean>;
      firstName: Option<boolean>;
      lastName: Option<boolean>;
      password: Option<boolean>;
      metadata: Option<boolean>;
      settings: Option<boolean>;
      role: Option<boolean>;
      emailVerified: Option<boolean>;
      verificationToken: Option<boolean>;
      verificationExpires: Option<boolean>;
      passwordResetToken: Option<boolean>;
      passwordResetExpires: Option<boolean>;
      permissions: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly email: FieldController<string | null>;
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
    readonly password: FieldController<string | null>;
    readonly metadata: FieldController<Metadata | null>;
    readonly settings: FieldController<Settings>;
    readonly role: FieldController<UserRole>;
    readonly emailVerified: FieldController<boolean>;
    readonly verificationToken: FieldController<string | null>;
    readonly verificationExpires: FieldController<string | null>;
    readonly passwordResetToken: FieldController<string | null>;
    readonly passwordResetExpires: FieldController<string | null>;
    readonly permissions: FieldController<AppPermissions>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: User;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<User, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<User>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<User>,
  ): Gigaform {
    let data = $state({ ...User.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      email: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      password: Option.none(),
      metadata: Option.none(),
      settings: Option.none(),
      role: Option.none(),
      emailVerified: Option.none(),
      verificationToken: Option.none(),
      verificationExpires: Option.none(),
      passwordResetToken: Option.none(),
      passwordResetExpires: Option.none(),
      permissions: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      email: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      password: Option.none(),
      metadata: Option.none(),
      settings: Option.none(),
      role: Option.none(),
      emailVerified: Option.none(),
      verificationToken: Option.none(),
      verificationExpires: Option.none(),
      passwordResetToken: Option.none(),
      passwordResetExpires: Option.none(),
      permissions: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: string | null) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("email", data.email);
          return fieldErrors.map((e) => e.message);
        },
      },
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },

        get: () => data.firstName,
        set: (value: string) => {
          data.firstName = value;
        },
        getError: () => errors.firstName,
        setError: (value: Option<Array<string>>) => {
          errors.firstName = value;
        },
        getTainted: () => tainted.firstName,
        setTainted: (value: Option<boolean>) => {
          tainted.firstName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("firstName", data.firstName);
          return fieldErrors.map((e) => e.message);
        },
      },
      lastName: {
        path: ["lastName"] as const,
        name: "lastName",
        constraints: { required: true },

        get: () => data.lastName,
        set: (value: string) => {
          data.lastName = value;
        },
        getError: () => errors.lastName,
        setError: (value: Option<Array<string>>) => {
          errors.lastName = value;
        },
        getTainted: () => tainted.lastName,
        setTainted: (value: Option<boolean>) => {
          tainted.lastName = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("lastName", data.lastName);
          return fieldErrors.map((e) => e.message);
        },
      },
      password: {
        path: ["password"] as const,
        name: "password",
        constraints: { required: true },

        get: () => data.password,
        set: (value: string | null) => {
          data.password = value;
        },
        getError: () => errors.password,
        setError: (value: Option<Array<string>>) => {
          errors.password = value;
        },
        getTainted: () => tainted.password,
        setTainted: (value: Option<boolean>) => {
          tainted.password = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("password", data.password);
          return fieldErrors.map((e) => e.message);
        },
      },
      metadata: {
        path: ["metadata"] as const,
        name: "metadata",
        constraints: { required: true },

        get: () => data.metadata,
        set: (value: Metadata | null) => {
          data.metadata = value;
        },
        getError: () => errors.metadata,
        setError: (value: Option<Array<string>>) => {
          errors.metadata = value;
        },
        getTainted: () => tainted.metadata,
        setTainted: (value: Option<boolean>) => {
          tainted.metadata = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("metadata", data.metadata);
          return fieldErrors.map((e) => e.message);
        },
      },
      settings: {
        path: ["settings"] as const,
        name: "settings",
        constraints: { required: true },

        get: () => data.settings,
        set: (value: Settings) => {
          data.settings = value;
        },
        getError: () => errors.settings,
        setError: (value: Option<Array<string>>) => {
          errors.settings = value;
        },
        getTainted: () => tainted.settings,
        setTainted: (value: Option<boolean>) => {
          tainted.settings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("settings", data.settings);
          return fieldErrors.map((e) => e.message);
        },
      },
      role: {
        path: ["role"] as const,
        name: "role",
        constraints: { required: true },

        get: () => data.role,
        set: (value: UserRole) => {
          data.role = value;
        },
        getError: () => errors.role,
        setError: (value: Option<Array<string>>) => {
          errors.role = value;
        },
        getTainted: () => tainted.role,
        setTainted: (value: Option<boolean>) => {
          tainted.role = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField("role", data.role);
          return fieldErrors.map((e) => e.message);
        },
      },
      emailVerified: {
        path: ["emailVerified"] as const,
        name: "emailVerified",
        constraints: { required: true },

        get: () => data.emailVerified,
        set: (value: boolean) => {
          data.emailVerified = value;
        },
        getError: () => errors.emailVerified,
        setError: (value: Option<Array<string>>) => {
          errors.emailVerified = value;
        },
        getTainted: () => tainted.emailVerified,
        setTainted: (value: Option<boolean>) => {
          tainted.emailVerified = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "emailVerified",
            data.emailVerified,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      verificationToken: {
        path: ["verificationToken"] as const,
        name: "verificationToken",
        constraints: { required: true },

        get: () => data.verificationToken,
        set: (value: string | null) => {
          data.verificationToken = value;
        },
        getError: () => errors.verificationToken,
        setError: (value: Option<Array<string>>) => {
          errors.verificationToken = value;
        },
        getTainted: () => tainted.verificationToken,
        setTainted: (value: Option<boolean>) => {
          tainted.verificationToken = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "verificationToken",
            data.verificationToken,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      verificationExpires: {
        path: ["verificationExpires"] as const,
        name: "verificationExpires",
        constraints: { required: true },

        get: () => data.verificationExpires,
        set: (value: string | null) => {
          data.verificationExpires = value;
        },
        getError: () => errors.verificationExpires,
        setError: (value: Option<Array<string>>) => {
          errors.verificationExpires = value;
        },
        getTainted: () => tainted.verificationExpires,
        setTainted: (value: Option<boolean>) => {
          tainted.verificationExpires = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "verificationExpires",
            data.verificationExpires,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      passwordResetToken: {
        path: ["passwordResetToken"] as const,
        name: "passwordResetToken",
        constraints: { required: true },

        get: () => data.passwordResetToken,
        set: (value: string | null) => {
          data.passwordResetToken = value;
        },
        getError: () => errors.passwordResetToken,
        setError: (value: Option<Array<string>>) => {
          errors.passwordResetToken = value;
        },
        getTainted: () => tainted.passwordResetToken,
        setTainted: (value: Option<boolean>) => {
          tainted.passwordResetToken = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "passwordResetToken",
            data.passwordResetToken,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      passwordResetExpires: {
        path: ["passwordResetExpires"] as const,
        name: "passwordResetExpires",
        constraints: { required: true },

        get: () => data.passwordResetExpires,
        set: (value: string | null) => {
          data.passwordResetExpires = value;
        },
        getError: () => errors.passwordResetExpires,
        setError: (value: Option<Array<string>>) => {
          errors.passwordResetExpires = value;
        },
        getTainted: () => tainted.passwordResetExpires,
        setTainted: (value: Option<boolean>) => {
          tainted.passwordResetExpires = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "passwordResetExpires",
            data.passwordResetExpires,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      permissions: {
        path: ["permissions"] as const,
        name: "permissions",
        constraints: { required: true },

        get: () => data.permissions,
        set: (value: AppPermissions) => {
          data.permissions = value;
        },
        getError: () => errors.permissions,
        setError: (value: Option<Array<string>>) => {
          errors.permissions = value;
        },
        getTainted: () => tainted.permissions,
        setTainted: (value: Option<boolean>) => {
          tainted.permissions = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = User.validateField(
            "permissions",
            data.permissions,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
    };
    function validate(): Result<
      User,
      Array<{ field: string; message: string }>
    > {
      return User.fromObject(data);
    }
    function reset(newOverrides?: Partial<User>): void {
      data = { ...User.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        email: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        password: Option.none(),
        metadata: Option.none(),
        settings: Option.none(),
        role: Option.none(),
        emailVerified: Option.none(),
        verificationToken: Option.none(),
        verificationExpires: Option.none(),
        passwordResetToken: Option.none(),
        passwordResetExpires: Option.none(),
        permissions: Option.none(),
      };
      tainted = {
        id: Option.none(),
        email: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        password: Option.none(),
        metadata: Option.none(),
        settings: Option.none(),
        role: Option.none(),
        emailVerified: Option.none(),
        verificationToken: Option.none(),
        verificationExpires: Option.none(),
        passwordResetToken: Option.none(),
        passwordResetExpires: Option.none(),
        permissions: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<User, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.email = formData.get("email") ?? "";
    obj.firstName = formData.get("firstName") ?? "";
    obj.lastName = formData.get("lastName") ?? "";
    obj.password = formData.get("password") ?? "";
    obj.metadata = formData.get("metadata") ?? "";
    {
      // Collect nested object fields with prefix "settings."
      const settingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("settings.")) {
          const fieldName = key.slice("settings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = settingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.settings = settingsObj;
    }
    {
      // Collect nested object fields with prefix "role."
      const roleObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("role.")) {
          const fieldName = key.slice("role.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = roleObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.role = roleObj;
    }
    {
      const emailVerifiedVal = formData.get("emailVerified");
      obj.emailVerified =
        emailVerifiedVal === "true" ||
        emailVerifiedVal === "on" ||
        emailVerifiedVal === "1";
    }
    obj.verificationToken = formData.get("verificationToken") ?? "";
    obj.verificationExpires = formData.get("verificationExpires") ?? "";
    obj.passwordResetToken = formData.get("passwordResetToken") ?? "";
    obj.passwordResetExpires = formData.get("passwordResetExpires") ?? "";
    {
      // Collect nested object fields with prefix "permissions."
      const permissionsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("permissions.")) {
          const fieldName = key.slice("permissions.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = permissionsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.permissions = permissionsObj;
    }
    return User.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Service {
  id: string;

  name: string;

  quickCode: string;
<<<<<<< Updated upstream
  group: string | null;
  subgroup: string | null;
  unit: string | null;
  active: boolean;
  commission: boolean;
  favorite: boolean;
=======

  group: string | null;

  subgroup: string | null;

  unit: string | null;

  active: boolean;

  commission: boolean;

  favorite: boolean;

>>>>>>> Stashed changes
  averageTime: string | null;
  defaults: ServiceDefaults;
}

export namespace Service {
  export function defaultValue(): Service {
    return {
      id: "",
      name: "",
      quickCode: "",
      group: null,
      subgroup: null,
      unit: null,
      active: false,
      commission: false,
      favorite: false,
      averageTime: null,
      defaults: ServiceDefaults.defaultValue(),
    } as Service;
  }
}

export namespace Service {
  export function toStringifiedJSON(self: Service): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Service): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Service,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Service", __id };
    result["id"] = self.id;
    result["name"] = self.name;
    result["quickCode"] = self.quickCode;
    if (self.group !== null) {
      result["group"] =
        typeof (self.group as any)?.__serialize === "function"
          ? (self.group as any).__serialize(ctx)
          : self.group;
    } else {
      result["group"] = null;
    }
    if (self.subgroup !== null) {
      result["subgroup"] =
        typeof (self.subgroup as any)?.__serialize === "function"
          ? (self.subgroup as any).__serialize(ctx)
          : self.subgroup;
    } else {
      result["subgroup"] = null;
    }
    if (self.unit !== null) {
      result["unit"] =
        typeof (self.unit as any)?.__serialize === "function"
          ? (self.unit as any).__serialize(ctx)
          : self.unit;
    } else {
      result["unit"] = null;
    }
    result["active"] = self.active;
    result["commission"] = self.commission;
    result["favorite"] = self.favorite;
    if (self.averageTime !== null) {
      result["averageTime"] =
        typeof (self.averageTime as any)?.__serialize === "function"
          ? (self.averageTime as any).__serialize(ctx)
          : self.averageTime;
    } else {
      result["averageTime"] = null;
    }
    result["defaults"] =
      typeof (self.defaults as any)?.__serialize === "function"
        ? (self.defaults as any).__serialize(ctx)
        : self.defaults;
    return result;
  }
}

export namespace Service {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Service, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Service, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Service.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Service | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Service.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (!("quickCode" in obj)) {
      errors.push({ field: "quickCode", message: "missing required field" });
    }
    if (!("group" in obj)) {
      errors.push({ field: "group", message: "missing required field" });
    }
    if (!("subgroup" in obj)) {
      errors.push({ field: "subgroup", message: "missing required field" });
    }
    if (!("unit" in obj)) {
      errors.push({ field: "unit", message: "missing required field" });
    }
    if (!("active" in obj)) {
      errors.push({ field: "active", message: "missing required field" });
    }
    if (!("commission" in obj)) {
      errors.push({ field: "commission", message: "missing required field" });
    }
    if (!("favorite" in obj)) {
      errors.push({ field: "favorite", message: "missing required field" });
    }
    if (!("averageTime" in obj)) {
      errors.push({ field: "averageTime", message: "missing required field" });
    }
    if (!("defaults" in obj)) {
      errors.push({ field: "defaults", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    {
      const __raw_quickCode = obj["quickCode"];
      instance.quickCode = __raw_quickCode;
    }
    {
      const __raw_group = obj["group"];
      instance.group = __raw_group;
    }
    {
      const __raw_subgroup = obj["subgroup"];
      instance.subgroup = __raw_subgroup;
    }
    {
      const __raw_unit = obj["unit"];
      instance.unit = __raw_unit;
    }
    {
      const __raw_active = obj["active"];
      instance.active = __raw_active;
    }
    {
      const __raw_commission = obj["commission"];
      instance.commission = __raw_commission;
    }
    {
      const __raw_favorite = obj["favorite"];
      instance.favorite = __raw_favorite;
    }
    {
      const __raw_averageTime = obj["averageTime"];
      instance.averageTime = __raw_averageTime;
    }
    {
      const __raw_defaults = obj["defaults"];
      if (typeof (ServiceDefaults as any)?.__deserialize === "function") {
        const __result = (ServiceDefaults as any).__deserialize(
          __raw_defaults,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "defaults", __result);
=======
        if (PendingRef.is(__result)) {
          instance.defaults = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.defaults = v;
          });
        } else {
          instance.defaults = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.defaults = __raw_defaults;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Service;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Service>(
    field: K,
    value: Service[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
      case "quickCode": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "quickCode", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Service>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    if ("quickCode" in partial && partial.quickCode !== undefined) {
      const __val = partial.quickCode as string;
      if (__val.length === 0) {
        errors.push({ field: "quickCode", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Service {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    name: Option<Array<string>>;
    quickCode: Option<Array<string>>;
    group: Option<Array<string>>;
    subgroup: Option<Array<string>>;
    unit: Option<Array<string>>;
    active: Option<Array<string>>;
    commission: Option<Array<string>>;
    favorite: Option<Array<string>>;
    averageTime: Option<Array<string>>;
    defaults: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      name: Option<boolean>;
      quickCode: Option<boolean>;
      group: Option<boolean>;
      subgroup: Option<boolean>;
      unit: Option<boolean>;
      active: Option<boolean>;
      commission: Option<boolean>;
      favorite: Option<boolean>;
      averageTime: Option<boolean>;
      defaults: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly quickCode: FieldController<string>;
    readonly group: FieldController<string | null>;
    readonly subgroup: FieldController<string | null>;
    readonly unit: FieldController<string | null>;
    readonly active: FieldController<boolean>;
    readonly commission: FieldController<boolean>;
    readonly favorite: FieldController<boolean>;
    readonly averageTime: FieldController<string | null>;
    readonly defaults: FieldController<ServiceDefaults>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Service;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Service, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Service>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Service>,
  ): Gigaform {
    let data = $state({ ...Service.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      averageTime: Option.none(),
      defaults: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      averageTime: Option.none(),
      defaults: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Name",
>>>>>>> Stashed changes
        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("name", data.name);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      quickCode: {
        path: ["quickCode"] as const,
        name: "quickCode",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Quick Code",
>>>>>>> Stashed changes
        get: () => data.quickCode,
        set: (value: string) => {
          data.quickCode = value;
        },
        getError: () => errors.quickCode,
        setError: (value: Option<Array<string>>) => {
          errors.quickCode = value;
        },
        getTainted: () => tainted.quickCode,
        setTainted: (value: Option<boolean>) => {
          tainted.quickCode = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "quickCode")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField(
            "quickCode",
            data.quickCode,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      group: {
        path: ["group"] as const,
        name: "group",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Group",
>>>>>>> Stashed changes
        get: () => data.group,
        set: (value: string | null) => {
          data.group = value;
        },
        getError: () => errors.group,
        setError: (value: Option<Array<string>>) => {
          errors.group = value;
        },
        getTainted: () => tainted.group,
        setTainted: (value: Option<boolean>) => {
          tainted.group = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "group")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("group", data.group);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      subgroup: {
        path: ["subgroup"] as const,
        name: "subgroup",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Subgroup",
>>>>>>> Stashed changes
        get: () => data.subgroup,
        set: (value: string | null) => {
          data.subgroup = value;
        },
        getError: () => errors.subgroup,
        setError: (value: Option<Array<string>>) => {
          errors.subgroup = value;
        },
        getTainted: () => tainted.subgroup,
        setTainted: (value: Option<boolean>) => {
          tainted.subgroup = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "subgroup")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("subgroup", data.subgroup);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      unit: {
        path: ["unit"] as const,
        name: "unit",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Unit",
>>>>>>> Stashed changes
        get: () => data.unit,
        set: (value: string | null) => {
          data.unit = value;
        },
        getError: () => errors.unit,
        setError: (value: Option<Array<string>>) => {
          errors.unit = value;
        },
        getTainted: () => tainted.unit,
        setTainted: (value: Option<boolean>) => {
          tainted.unit = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "unit")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("unit", data.unit);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Active",
>>>>>>> Stashed changes
        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "active")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("active", data.active);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      commission: {
        path: ["commission"] as const,
        name: "commission",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Commission",
>>>>>>> Stashed changes
        get: () => data.commission,
        set: (value: boolean) => {
          data.commission = value;
        },
        getError: () => errors.commission,
        setError: (value: Option<Array<string>>) => {
          errors.commission = value;
        },
        getTainted: () => tainted.commission,
        setTainted: (value: Option<boolean>) => {
          tainted.commission = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "commission")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField(
            "commission",
            data.commission,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      favorite: {
        path: ["favorite"] as const,
        name: "favorite",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Favorite",
>>>>>>> Stashed changes
        get: () => data.favorite,
        set: (value: boolean) => {
          data.favorite = value;
        },
        getError: () => errors.favorite,
        setError: (value: Option<Array<string>>) => {
          errors.favorite = value;
        },
        getTainted: () => tainted.favorite,
        setTainted: (value: Option<boolean>) => {
          tainted.favorite = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "favorite")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("favorite", data.favorite);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      averageTime: {
        path: ["averageTime"] as const,
        name: "averageTime",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Average Time",
>>>>>>> Stashed changes
        get: () => data.averageTime,
        set: (value: string | null) => {
          data.averageTime = value;
        },
        getError: () => errors.averageTime,
        setError: (value: Option<Array<string>>) => {
          errors.averageTime = value;
        },
        getTainted: () => tainted.averageTime,
        setTainted: (value: Option<boolean>) => {
          tainted.averageTime = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "averageTime")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField(
            "averageTime",
            data.averageTime,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      defaults: {
        path: ["defaults"] as const,
        name: "defaults",
        constraints: { required: true },

        get: () => data.defaults,
        set: (value: ServiceDefaults) => {
          data.defaults = value;
        },
        getError: () => errors.defaults,
        setError: (value: Option<Array<string>>) => {
          errors.defaults = value;
        },
        getTainted: () => tainted.defaults,
        setTainted: (value: Option<boolean>) => {
          tainted.defaults = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Service.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "defaults")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Service.validateField("defaults", data.defaults);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Service,
      Array<{ field: string; message: string }>
    > {
      return Service.fromObject(data);
    }
    function reset(newOverrides?: Partial<Service>): void {
      data = { ...Service.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        averageTime: Option.none(),
        defaults: Option.none(),
      };
      tainted = {
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        averageTime: Option.none(),
        defaults: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Service, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.name = formData.get("name") ?? "";
    obj.quickCode = formData.get("quickCode") ?? "";
    obj.group = formData.get("group") ?? "";
    obj.subgroup = formData.get("subgroup") ?? "";
    obj.unit = formData.get("unit") ?? "";
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
      const commissionVal = formData.get("commission");
      obj.commission =
        commissionVal === "true" ||
        commissionVal === "on" ||
        commissionVal === "1";
    }
    {
      const favoriteVal = formData.get("favorite");
      obj.favorite =
        favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    obj.averageTime = formData.get("averageTime") ?? "";
    {
      // Collect nested object fields with prefix "defaults."
      const defaultsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("defaults.")) {
          const fieldName = key.slice("defaults.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = defaultsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.defaults = defaultsObj;
    }
    return Service.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface ServiceDefaults {
  price: number;

  description: string;
}

export namespace ServiceDefaults {
  export function defaultValue(): ServiceDefaults {
    return { price: 0, description: "" } as ServiceDefaults;
  }
}

export namespace ServiceDefaults {
  export function toStringifiedJSON(self: ServiceDefaults): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: ServiceDefaults): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: ServiceDefaults,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "ServiceDefaults", __id };
    result["price"] = self.price;
    result["description"] = self.description;
    return result;
  }
}

export namespace ServiceDefaults {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<ServiceDefaults, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<ServiceDefaults, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "ServiceDefaults.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): ServiceDefaults | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "ServiceDefaults.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("price" in obj)) {
      errors.push({ field: "price", message: "missing required field" });
    }
    if (!("description" in obj)) {
      errors.push({ field: "description", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_price = obj["price"];
      instance.price = __raw_price;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as ServiceDefaults;
  }
<<<<<<< Updated upstream
}

export namespace ServiceDefaults {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    price: Option<Array<string>>;
    description: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { price: Option<boolean>; description: Option<boolean> };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ServiceDefaults;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ServiceDefaults,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ServiceDefaults>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ServiceDefaults>,
  ): Gigaform {
    let data = $state({ ...ServiceDefaults.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      price: Option.none(),
      description: Option.none(),
    });
    let tainted = $state<Tainted>({
      price: Option.none(),
      description: Option.none(),
    });
    const fields: FieldControllers = {
      price: {
        path: ["price"] as const,
        name: "price",
        constraints: { required: true },

=======
  export function validateField<K extends keyof ServiceDefaults>(
    field: K,
    value: ServiceDefaults[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "description": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "description", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<ServiceDefaults>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("description" in partial && partial.description !== undefined) {
      const __val = partial.description as string;
      if (__val.length === 0) {
        errors.push({ field: "description", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace ServiceDefaults {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    price: Option<Array<string>>;
    description: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { price: Option<boolean>; description: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ServiceDefaults;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ServiceDefaults,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ServiceDefaults>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ServiceDefaults>,
  ): Gigaform {
    let data = $state({ ...ServiceDefaults.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      price: Option.none(),
      description: Option.none(),
    });
    let tainted = $state<Tainted>({
      price: Option.none(),
      description: Option.none(),
    });
    const fields: FieldControllers = {
      price: {
        path: ["price"] as const,
        name: "price",
        constraints: { required: true },
        label: "Price",
>>>>>>> Stashed changes
        get: () => data.price,
        set: (value: number) => {
          data.price = value;
        },
        getError: () => errors.price,
        setError: (value: Option<Array<string>>) => {
          errors.price = value;
        },
        getTainted: () => tainted.price,
        setTainted: (value: Option<boolean>) => {
          tainted.price = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = ServiceDefaults.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "price")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = ServiceDefaults.validateField(
            "price",
            data.price,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Description",
>>>>>>> Stashed changes
        get: () => data.description,
        set: (value: string) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = ServiceDefaults.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "description")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = ServiceDefaults.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      ServiceDefaults,
      Array<{ field: string; message: string }>
    > {
      return ServiceDefaults.fromObject(data);
    }
    function reset(newOverrides?: Partial<ServiceDefaults>): void {
      data = { ...ServiceDefaults.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        price: Option.none(),
        description: Option.none(),
      };
      tainted = { price: Option.none(), description: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ServiceDefaults, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const priceStr = formData.get("price");
      obj.price = priceStr ? parseFloat(priceStr as string) : 0;
      if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = 0;
    }
    obj.description = formData.get("description") ?? "";
    return ServiceDefaults.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Did {
  in: string | Actor;

  out: string | Target;
  id: string;
  activityType: ActivityType;
  createdAt: string;
  metadata: string | null;
}

export namespace Did {
  export function defaultValue(): Did {
    return {
      in: "",
      out: "",
      id: "",
      activityType: ActivityType.defaultValue(),
      createdAt: "",
      metadata: null,
    } as Did;
  }
}

export namespace Did {
  export function toStringifiedJSON(self: Did): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Did): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Did,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Did", __id };
    result["in"] = self.in;
    result["out"] = self.out;
    result["id"] = self.id;
    result["activityType"] =
      typeof (self.activityType as any)?.__serialize === "function"
        ? (self.activityType as any).__serialize(ctx)
        : self.activityType;
    result["createdAt"] = self.createdAt;
    if (self.metadata !== null) {
      result["metadata"] =
        typeof (self.metadata as any)?.__serialize === "function"
          ? (self.metadata as any).__serialize(ctx)
          : self.metadata;
    } else {
      result["metadata"] = null;
    }
    return result;
  }
}

export namespace Did {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Did, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Did, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Did.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Did | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Did.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("in" in obj)) {
      errors.push({ field: "in", message: "missing required field" });
    }
    if (!("out" in obj)) {
      errors.push({ field: "out", message: "missing required field" });
    }
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("activityType" in obj)) {
      errors.push({ field: "activityType", message: "missing required field" });
    }
    if (!("createdAt" in obj)) {
      errors.push({ field: "createdAt", message: "missing required field" });
    }
    if (!("metadata" in obj)) {
      errors.push({ field: "metadata", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_in = obj["in"];
      instance.in = __raw_in;
    }
    {
      const __raw_out = obj["out"];
      instance.out = __raw_out;
    }
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_activityType = obj["activityType"];
      if (typeof (ActivityType as any)?.__deserialize === "function") {
        const __result = (ActivityType as any).__deserialize(
          __raw_activityType,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "activityType", __result);
      } else {
        instance.activityType = __raw_activityType;
      }
    }
    {
      const __raw_createdAt = obj["createdAt"];
      instance.createdAt = __raw_createdAt;
    }
    {
      const __raw_metadata = obj["metadata"];
      instance.metadata = __raw_metadata;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Did;
  }
}

export namespace Did {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    in: Option<Array<string>>;
    out: Option<Array<string>>;
    id: Option<Array<string>>;
    activityType: Option<Array<string>>;
    createdAt: Option<Array<string>>;
    metadata: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      in: Option<boolean>;
      out: Option<boolean>;
      id: Option<boolean>;
      activityType: Option<boolean>;
      createdAt: Option<boolean>;
      metadata: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly in: FieldController<string | Actor>;
    readonly out: FieldController<string | Target>;
    readonly id: FieldController<string>;
    readonly activityType: FieldController<ActivityType>;
    readonly createdAt: FieldController<string>;
    readonly metadata: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Did;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Did, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Did>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Did>,
  ): Gigaform {
    let data = $state({ ...Did.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      activityType: Option.none(),
      createdAt: Option.none(),
      metadata: Option.none(),
    });
    let tainted = $state<Tainted>({
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      activityType: Option.none(),
      createdAt: Option.none(),
      metadata: Option.none(),
    });
    const fields: FieldControllers = {
      in: {
        path: ["in"] as const,
        name: "in",
        constraints: { required: true },

        get: () => data.in,
        set: (value: string | Actor) => {
          data.in = value;
        },
        getError: () => errors.in,
        setError: (value: Option<Array<string>>) => {
          errors.in = value;
        },
        getTainted: () => tainted.in,
        setTainted: (value: Option<boolean>) => {
          tainted.in = value;
        },
        validate: (): Array<string> => {
          const result = Did.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "in")
              .map((e) => e.message);
          }
          return [];
        },
      },
      out: {
        path: ["out"] as const,
        name: "out",
        constraints: { required: true },

        get: () => data.out,
        set: (value: string | Target) => {
          data.out = value;
        },
        getError: () => errors.out,
        setError: (value: Option<Array<string>>) => {
          errors.out = value;
        },
        getTainted: () => tainted.out,
        setTainted: (value: Option<boolean>) => {
          tainted.out = value;
        },
        validate: (): Array<string> => {
          const result = Did.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "out")
              .map((e) => e.message);
          }
          return [];
        },
      },
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const result = Did.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
        },
      },
      activityType: {
        path: ["activityType"] as const,
        name: "activityType",
        constraints: { required: true },

        get: () => data.activityType,
        set: (value: ActivityType) => {
          data.activityType = value;
        },
        getError: () => errors.activityType,
        setError: (value: Option<Array<string>>) => {
          errors.activityType = value;
        },
        getTainted: () => tainted.activityType,
        setTainted: (value: Option<boolean>) => {
          tainted.activityType = value;
        },
        validate: (): Array<string> => {
          const result = Did.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "activityType")
              .map((e) => e.message);
          }
          return [];
        },
      },
      createdAt: {
        path: ["createdAt"] as const,
        name: "createdAt",
        constraints: { required: true },

        get: () => data.createdAt,
        set: (value: string) => {
          data.createdAt = value;
        },
        getError: () => errors.createdAt,
        setError: (value: Option<Array<string>>) => {
          errors.createdAt = value;
        },
        getTainted: () => tainted.createdAt,
        setTainted: (value: Option<boolean>) => {
          tainted.createdAt = value;
        },
        validate: (): Array<string> => {
          const result = Did.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "createdAt")
              .map((e) => e.message);
          }
          return [];
        },
      },
      metadata: {
        path: ["metadata"] as const,
        name: "metadata",
        constraints: { required: true },

        get: () => data.metadata,
        set: (value: string | null) => {
          data.metadata = value;
        },
        getError: () => errors.metadata,
        setError: (value: Option<Array<string>>) => {
          errors.metadata = value;
        },
        getTainted: () => tainted.metadata,
        setTainted: (value: Option<boolean>) => {
          tainted.metadata = value;
        },
        validate: (): Array<string> => {
          const result = Did.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "metadata")
              .map((e) => e.message);
          }
          return [];
        },
      },
    };
    function validate(): Result<
      Did,
      Array<{ field: string; message: string }>
    > {
      return Did.fromObject(data);
    }
    function reset(newOverrides?: Partial<Did>): void {
      data = { ...Did.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        activityType: Option.none(),
        createdAt: Option.none(),
        metadata: Option.none(),
      };
      tainted = {
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        activityType: Option.none(),
        createdAt: Option.none(),
        metadata: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Did, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.in = formData.get("in") ?? "";
    obj.out = formData.get("out") ?? "";
    obj.id = formData.get("id") ?? "";
    {
      // Collect nested object fields with prefix "activityType."
      const activityTypeObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("activityType.")) {
          const fieldName = key.slice("activityType.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = activityTypeObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.activityType = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.activityType = v;
          });
        } else {
          instance.activityType = __result;
        }
      } else {
        instance.activityType = __raw_activityType;
      }
    }
    {
      const __raw_createdAt = obj["createdAt"];
      instance.createdAt = __raw_createdAt;
    }
    {
      const __raw_metadata = obj["metadata"];
      instance.metadata = __raw_metadata;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Did;
  }
  export function validateField<K extends keyof Did>(
    field: K,
    value: Did[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Did>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace Did {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    in: Option<Array<string>>;
    out: Option<Array<string>>;
    id: Option<Array<string>>;
    activityType: Option<Array<string>>;
    createdAt: Option<Array<string>>;
    metadata: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      in: Option<boolean>;
      out: Option<boolean>;
      id: Option<boolean>;
      activityType: Option<boolean>;
      createdAt: Option<boolean>;
      metadata: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly in: FieldController<string | Actor>;
    readonly out: FieldController<string | Target>;
    readonly id: FieldController<string>;
    readonly activityType: FieldController<ActivityType>;
    readonly createdAt: FieldController<string>;
    readonly metadata: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Did;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Did, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Did>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Did>,
  ): Gigaform {
    let data = $state({ ...Did.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      activityType: Option.none(),
      createdAt: Option.none(),
      metadata: Option.none(),
    });
    let tainted = $state<Tainted>({
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      activityType: Option.none(),
      createdAt: Option.none(),
      metadata: Option.none(),
    });
    const fields: FieldControllers = {
      in: {
        path: ["in"] as const,
        name: "in",
        constraints: { required: true },

        get: () => data.in,
        set: (value: string | Actor) => {
          data.in = value;
        },
        getError: () => errors.in,
        setError: (value: Option<Array<string>>) => {
          errors.in = value;
        },
        getTainted: () => tainted.in,
        setTainted: (value: Option<boolean>) => {
          tainted.in = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("in", data.in);
          return fieldErrors.map((e) => e.message);
        },
      },
      out: {
        path: ["out"] as const,
        name: "out",
        constraints: { required: true },

        get: () => data.out,
        set: (value: string | Target) => {
          data.out = value;
        },
        getError: () => errors.out,
        setError: (value: Option<Array<string>>) => {
          errors.out = value;
        },
        getTainted: () => tainted.out,
        setTainted: (value: Option<boolean>) => {
          tainted.out = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("out", data.out);
          return fieldErrors.map((e) => e.message);
        },
      },
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
        },
      },
      activityType: {
        path: ["activityType"] as const,
        name: "activityType",
        constraints: { required: true },

        get: () => data.activityType,
        set: (value: ActivityType) => {
          data.activityType = value;
        },
        getError: () => errors.activityType,
        setError: (value: Option<Array<string>>) => {
          errors.activityType = value;
        },
        getTainted: () => tainted.activityType,
        setTainted: (value: Option<boolean>) => {
          tainted.activityType = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField(
            "activityType",
            data.activityType,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      createdAt: {
        path: ["createdAt"] as const,
        name: "createdAt",
        constraints: { required: true },

        get: () => data.createdAt,
        set: (value: string) => {
          data.createdAt = value;
        },
        getError: () => errors.createdAt,
        setError: (value: Option<Array<string>>) => {
          errors.createdAt = value;
        },
        getTainted: () => tainted.createdAt,
        setTainted: (value: Option<boolean>) => {
          tainted.createdAt = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("createdAt", data.createdAt);
          return fieldErrors.map((e) => e.message);
        },
      },
      metadata: {
        path: ["metadata"] as const,
        name: "metadata",
        constraints: { required: true },

        get: () => data.metadata,
        set: (value: string | null) => {
          data.metadata = value;
        },
        getError: () => errors.metadata,
        setError: (value: Option<Array<string>>) => {
          errors.metadata = value;
        },
        getTainted: () => tainted.metadata,
        setTainted: (value: Option<boolean>) => {
          tainted.metadata = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Did.validateField("metadata", data.metadata);
          return fieldErrors.map((e) => e.message);
        },
      },
    };
    function validate(): Result<
      Did,
      Array<{ field: string; message: string }>
    > {
      return Did.fromObject(data);
    }
    function reset(newOverrides?: Partial<Did>): void {
      data = { ...Did.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        activityType: Option.none(),
        createdAt: Option.none(),
        metadata: Option.none(),
      };
      tainted = {
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        activityType: Option.none(),
        createdAt: Option.none(),
        metadata: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Did, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.in = formData.get("in") ?? "";
    obj.out = formData.get("out") ?? "";
    obj.id = formData.get("id") ?? "";
    {
      // Collect nested object fields with prefix "activityType."
      const activityTypeObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("activityType.")) {
          const fieldName = key.slice("activityType.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = activityTypeObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.activityType = activityTypeObj;
    }
    obj.createdAt = formData.get("createdAt") ?? "";
    obj.metadata = formData.get("metadata") ?? "";
    return Did.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface PersonName {
  firstName: string;

  lastName: string;
}

export namespace PersonName {
  export function defaultValue(): PersonName {
    return { firstName: "", lastName: "" } as PersonName;
  }
}

export namespace PersonName {
  export function toStringifiedJSON(self: PersonName): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: PersonName): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: PersonName,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "PersonName", __id };
    result["firstName"] = self.firstName;
    result["lastName"] = self.lastName;
    return result;
  }
}

export namespace PersonName {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<PersonName, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<PersonName, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "PersonName.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): PersonName | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "PersonName.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("firstName" in obj)) {
      errors.push({ field: "firstName", message: "missing required field" });
    }
    if (!("lastName" in obj)) {
      errors.push({ field: "lastName", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_firstName = obj["firstName"];
      instance.firstName = __raw_firstName;
    }
    {
      const __raw_lastName = obj["lastName"];
      instance.lastName = __raw_lastName;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as PersonName;
  }
<<<<<<< Updated upstream
}

export namespace PersonName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { firstName: Option<boolean>; lastName: Option<boolean> };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: PersonName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<PersonName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<PersonName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<PersonName>,
  ): Gigaform {
    let data = $state({ ...PersonName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
    });
    let tainted = $state<Tainted>({
      firstName: Option.none(),
      lastName: Option.none(),
    });
    const fields: FieldControllers = {
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },

=======
  export function validateField<K extends keyof PersonName>(
    field: K,
    value: PersonName[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "firstName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "firstName", message: "must not be empty" });
        }
        break;
      }
      case "lastName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "lastName", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<PersonName>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("firstName" in partial && partial.firstName !== undefined) {
      const __val = partial.firstName as string;
      if (__val.length === 0) {
        errors.push({ field: "firstName", message: "must not be empty" });
      }
    }
    if ("lastName" in partial && partial.lastName !== undefined) {
      const __val = partial.lastName as string;
      if (__val.length === 0) {
        errors.push({ field: "lastName", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace PersonName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { firstName: Option<boolean>; lastName: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly firstName: FieldController<string>;
    readonly lastName: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: PersonName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<PersonName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<PersonName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<PersonName>,
  ): Gigaform {
    let data = $state({ ...PersonName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
    });
    let tainted = $state<Tainted>({
      firstName: Option.none(),
      lastName: Option.none(),
    });
    const fields: FieldControllers = {
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },
        label: "First Name",
>>>>>>> Stashed changes
        get: () => data.firstName,
        set: (value: string) => {
          data.firstName = value;
        },
        getError: () => errors.firstName,
        setError: (value: Option<Array<string>>) => {
          errors.firstName = value;
        },
        getTainted: () => tainted.firstName,
        setTainted: (value: Option<boolean>) => {
          tainted.firstName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = PersonName.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "firstName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = PersonName.validateField(
            "firstName",
            data.firstName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      lastName: {
        path: ["lastName"] as const,
        name: "lastName",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Last Name",
>>>>>>> Stashed changes
        get: () => data.lastName,
        set: (value: string) => {
          data.lastName = value;
        },
        getError: () => errors.lastName,
        setError: (value: Option<Array<string>>) => {
          errors.lastName = value;
        },
        getTainted: () => tainted.lastName,
        setTainted: (value: Option<boolean>) => {
          tainted.lastName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = PersonName.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lastName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = PersonName.validateField(
            "lastName",
            data.lastName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      PersonName,
      Array<{ field: string; message: string }>
    > {
      return PersonName.fromObject(data);
    }
    function reset(newOverrides?: Partial<PersonName>): void {
      data = { ...PersonName.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
      };
      tainted = { firstName: Option.none(), lastName: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<PersonName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.firstName = formData.get("firstName") ?? "";
    obj.lastName = formData.get("lastName") ?? "";
    return PersonName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Promotion {
  id: string;
  date: string;
}

export namespace Promotion {
  export function defaultValue(): Promotion {
    return { id: "", date: "" } as Promotion;
  }
}

export namespace Promotion {
  export function toStringifiedJSON(self: Promotion): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Promotion): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Promotion,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Promotion", __id };
    result["id"] = self.id;
    result["date"] = self.date;
    return result;
  }
}

export namespace Promotion {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Promotion, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Promotion, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Promotion.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Promotion | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Promotion.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("date" in obj)) {
      errors.push({ field: "date", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_date = obj["date"];
      instance.date = __raw_date;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Promotion;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Promotion>(
    field: K,
    value: Promotion[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Promotion>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Promotion {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { id: Option<boolean>; date: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Promotion;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Promotion, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Promotion>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Promotion>,
  ): Gigaform {
    let data = $state({ ...Promotion.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({ id: Option.none(), date: Option.none() });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Promotion.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Promotion.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },

        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Promotion.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "date")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Promotion.validateField("date", data.date);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Promotion,
      Array<{ field: string; message: string }>
    > {
      return Promotion.fromObject(data);
    }
    function reset(newOverrides?: Partial<Promotion>): void {
      data = { ...Promotion.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        date: Option.none(),
      };
      tainted = { id: Option.none(), date: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Promotion, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.date = formData.get("date") ?? "";
    return Promotion.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Site {
  id: string;

  addressLine1: string;
  addressLine2: string | null;
  sublocalityLevel1: string | null;

  locality: string;
  administrativeAreaLevel3: string | null;
  administrativeAreaLevel2: string | null;

  administrativeAreaLevel1: string;

  country: string;

  postalCode: string;
  postalCodeSuffix: string | null;
  coordinates: Coordinates;
}

export namespace Site {
  export function defaultValue(): Site {
    return {
      id: "",
      addressLine1: "",
      addressLine2: null,
      sublocalityLevel1: null,
      locality: "",
      administrativeAreaLevel3: null,
      administrativeAreaLevel2: null,
      administrativeAreaLevel1: "",
      country: "",
      postalCode: "",
      postalCodeSuffix: null,
      coordinates: Coordinates.defaultValue(),
    } as Site;
  }
}

export namespace Site {
  export function toStringifiedJSON(self: Site): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Site): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Site,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Site", __id };
    result["id"] = self.id;
    result["addressLine1"] = self.addressLine1;
    if (self.addressLine2 !== null) {
      result["addressLine2"] =
        typeof (self.addressLine2 as any)?.__serialize === "function"
          ? (self.addressLine2 as any).__serialize(ctx)
          : self.addressLine2;
    } else {
      result["addressLine2"] = null;
    }
    if (self.sublocalityLevel1 !== null) {
      result["sublocalityLevel1"] =
        typeof (self.sublocalityLevel1 as any)?.__serialize === "function"
          ? (self.sublocalityLevel1 as any).__serialize(ctx)
          : self.sublocalityLevel1;
    } else {
      result["sublocalityLevel1"] = null;
    }
    result["locality"] = self.locality;
    if (self.administrativeAreaLevel3 !== null) {
      result["administrativeAreaLevel3"] =
        typeof (self.administrativeAreaLevel3 as any)?.__serialize ===
        "function"
          ? (self.administrativeAreaLevel3 as any).__serialize(ctx)
          : self.administrativeAreaLevel3;
    } else {
      result["administrativeAreaLevel3"] = null;
    }
    if (self.administrativeAreaLevel2 !== null) {
      result["administrativeAreaLevel2"] =
        typeof (self.administrativeAreaLevel2 as any)?.__serialize ===
        "function"
          ? (self.administrativeAreaLevel2 as any).__serialize(ctx)
          : self.administrativeAreaLevel2;
    } else {
      result["administrativeAreaLevel2"] = null;
    }
    result["administrativeAreaLevel1"] = self.administrativeAreaLevel1;
    result["country"] = self.country;
    result["postalCode"] = self.postalCode;
    if (self.postalCodeSuffix !== null) {
      result["postalCodeSuffix"] =
        typeof (self.postalCodeSuffix as any)?.__serialize === "function"
          ? (self.postalCodeSuffix as any).__serialize(ctx)
          : self.postalCodeSuffix;
    } else {
      result["postalCodeSuffix"] = null;
    }
    result["coordinates"] =
      typeof (self.coordinates as any)?.__serialize === "function"
        ? (self.coordinates as any).__serialize(ctx)
        : self.coordinates;
    return result;
  }
}

export namespace Site {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Site, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Site, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Site.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Site | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Site.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("addressLine1" in obj)) {
      errors.push({ field: "addressLine1", message: "missing required field" });
    }
    if (!("addressLine2" in obj)) {
      errors.push({ field: "addressLine2", message: "missing required field" });
    }
    if (!("sublocalityLevel1" in obj)) {
      errors.push({
        field: "sublocalityLevel1",
        message: "missing required field",
      });
    }
    if (!("locality" in obj)) {
      errors.push({ field: "locality", message: "missing required field" });
    }
    if (!("administrativeAreaLevel3" in obj)) {
      errors.push({
        field: "administrativeAreaLevel3",
        message: "missing required field",
      });
    }
    if (!("administrativeAreaLevel2" in obj)) {
      errors.push({
        field: "administrativeAreaLevel2",
        message: "missing required field",
      });
    }
    if (!("administrativeAreaLevel1" in obj)) {
      errors.push({
        field: "administrativeAreaLevel1",
        message: "missing required field",
      });
    }
    if (!("country" in obj)) {
      errors.push({ field: "country", message: "missing required field" });
    }
    if (!("postalCode" in obj)) {
      errors.push({ field: "postalCode", message: "missing required field" });
    }
    if (!("postalCodeSuffix" in obj)) {
      errors.push({
        field: "postalCodeSuffix",
        message: "missing required field",
      });
    }
    if (!("coordinates" in obj)) {
      errors.push({ field: "coordinates", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_addressLine1 = obj["addressLine1"];
      instance.addressLine1 = __raw_addressLine1;
    }
    {
      const __raw_addressLine2 = obj["addressLine2"];
      instance.addressLine2 = __raw_addressLine2;
    }
    {
      const __raw_sublocalityLevel1 = obj["sublocalityLevel1"];
      instance.sublocalityLevel1 = __raw_sublocalityLevel1;
    }
    {
      const __raw_locality = obj["locality"];
      instance.locality = __raw_locality;
    }
    {
      const __raw_administrativeAreaLevel3 = obj["administrativeAreaLevel3"];
      instance.administrativeAreaLevel3 = __raw_administrativeAreaLevel3;
    }
    {
      const __raw_administrativeAreaLevel2 = obj["administrativeAreaLevel2"];
      instance.administrativeAreaLevel2 = __raw_administrativeAreaLevel2;
    }
    {
      const __raw_administrativeAreaLevel1 = obj["administrativeAreaLevel1"];
      instance.administrativeAreaLevel1 = __raw_administrativeAreaLevel1;
    }
    {
      const __raw_country = obj["country"];
      instance.country = __raw_country;
    }
    {
      const __raw_postalCode = obj["postalCode"];
      instance.postalCode = __raw_postalCode;
    }
    {
      const __raw_postalCodeSuffix = obj["postalCodeSuffix"];
      instance.postalCodeSuffix = __raw_postalCodeSuffix;
    }
    {
      const __raw_coordinates = obj["coordinates"];
      if (typeof (Coordinates as any)?.__deserialize === "function") {
        const __result = (Coordinates as any).__deserialize(
          __raw_coordinates,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "coordinates", __result);
=======
        if (PendingRef.is(__result)) {
          instance.coordinates = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.coordinates = v;
          });
        } else {
          instance.coordinates = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.coordinates = __raw_coordinates;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Site;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Site>(
    field: K,
    value: Site[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "addressLine1": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "addressLine1", message: "must not be empty" });
        }
        break;
      }
      case "locality": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "locality", message: "must not be empty" });
        }
        break;
      }
      case "administrativeAreaLevel1": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "administrativeAreaLevel1",
            message: "must not be empty",
          });
        }
        break;
      }
      case "country": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "country", message: "must not be empty" });
        }
        break;
      }
      case "postalCode": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "postalCode", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Site>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("addressLine1" in partial && partial.addressLine1 !== undefined) {
      const __val = partial.addressLine1 as string;
      if (__val.length === 0) {
        errors.push({ field: "addressLine1", message: "must not be empty" });
      }
    }
    if ("locality" in partial && partial.locality !== undefined) {
      const __val = partial.locality as string;
      if (__val.length === 0) {
        errors.push({ field: "locality", message: "must not be empty" });
      }
    }
    if (
      "administrativeAreaLevel1" in partial &&
      partial.administrativeAreaLevel1 !== undefined
    ) {
      const __val = partial.administrativeAreaLevel1 as string;
      if (__val.length === 0) {
        errors.push({
          field: "administrativeAreaLevel1",
          message: "must not be empty",
        });
      }
    }
    if ("country" in partial && partial.country !== undefined) {
      const __val = partial.country as string;
      if (__val.length === 0) {
        errors.push({ field: "country", message: "must not be empty" });
      }
    }
    if ("postalCode" in partial && partial.postalCode !== undefined) {
      const __val = partial.postalCode as string;
      if (__val.length === 0) {
        errors.push({ field: "postalCode", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Site {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    addressLine1: Option<Array<string>>;
    addressLine2: Option<Array<string>>;
    sublocalityLevel1: Option<Array<string>>;
    locality: Option<Array<string>>;
    administrativeAreaLevel3: Option<Array<string>>;
    administrativeAreaLevel2: Option<Array<string>>;
    administrativeAreaLevel1: Option<Array<string>>;
    country: Option<Array<string>>;
    postalCode: Option<Array<string>>;
    postalCodeSuffix: Option<Array<string>>;
    coordinates: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      addressLine1: Option<boolean>;
      addressLine2: Option<boolean>;
      sublocalityLevel1: Option<boolean>;
      locality: Option<boolean>;
      administrativeAreaLevel3: Option<boolean>;
      administrativeAreaLevel2: Option<boolean>;
      administrativeAreaLevel1: Option<boolean>;
      country: Option<boolean>;
      postalCode: Option<boolean>;
      postalCodeSuffix: Option<boolean>;
      coordinates: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly addressLine1: FieldController<string>;
    readonly addressLine2: FieldController<string | null>;
    readonly sublocalityLevel1: FieldController<string | null>;
    readonly locality: FieldController<string>;
    readonly administrativeAreaLevel3: FieldController<string | null>;
    readonly administrativeAreaLevel2: FieldController<string | null>;
    readonly administrativeAreaLevel1: FieldController<string>;
    readonly country: FieldController<string>;
    readonly postalCode: FieldController<string>;
    readonly postalCodeSuffix: FieldController<string | null>;
    readonly coordinates: FieldController<Coordinates>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Site;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Site, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Site>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Site>,
  ): Gigaform {
    let data = $state({ ...Site.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      addressLine1: Option.none(),
      addressLine2: Option.none(),
      sublocalityLevel1: Option.none(),
      locality: Option.none(),
      administrativeAreaLevel3: Option.none(),
      administrativeAreaLevel2: Option.none(),
      administrativeAreaLevel1: Option.none(),
      country: Option.none(),
      postalCode: Option.none(),
      postalCodeSuffix: Option.none(),
      coordinates: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      addressLine1: Option.none(),
      addressLine2: Option.none(),
      sublocalityLevel1: Option.none(),
      locality: Option.none(),
      administrativeAreaLevel3: Option.none(),
      administrativeAreaLevel2: Option.none(),
      administrativeAreaLevel1: Option.none(),
      country: Option.none(),
      postalCode: Option.none(),
      postalCodeSuffix: Option.none(),
      coordinates: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      addressLine1: {
        path: ["addressLine1"] as const,
        name: "addressLine1",
        constraints: { required: true },

        get: () => data.addressLine1,
        set: (value: string) => {
          data.addressLine1 = value;
        },
        getError: () => errors.addressLine1,
        setError: (value: Option<Array<string>>) => {
          errors.addressLine1 = value;
        },
        getTainted: () => tainted.addressLine1,
        setTainted: (value: Option<boolean>) => {
          tainted.addressLine1 = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "addressLine1")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "addressLine1",
            data.addressLine1,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      addressLine2: {
        path: ["addressLine2"] as const,
        name: "addressLine2",
        constraints: { required: true },

        get: () => data.addressLine2,
        set: (value: string | null) => {
          data.addressLine2 = value;
        },
        getError: () => errors.addressLine2,
        setError: (value: Option<Array<string>>) => {
          errors.addressLine2 = value;
        },
        getTainted: () => tainted.addressLine2,
        setTainted: (value: Option<boolean>) => {
          tainted.addressLine2 = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "addressLine2")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "addressLine2",
            data.addressLine2,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      sublocalityLevel1: {
        path: ["sublocalityLevel1"] as const,
        name: "sublocalityLevel1",
        constraints: { required: true },

        get: () => data.sublocalityLevel1,
        set: (value: string | null) => {
          data.sublocalityLevel1 = value;
        },
        getError: () => errors.sublocalityLevel1,
        setError: (value: Option<Array<string>>) => {
          errors.sublocalityLevel1 = value;
        },
        getTainted: () => tainted.sublocalityLevel1,
        setTainted: (value: Option<boolean>) => {
          tainted.sublocalityLevel1 = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "sublocalityLevel1")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "sublocalityLevel1",
            data.sublocalityLevel1,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      locality: {
        path: ["locality"] as const,
        name: "locality",
        constraints: { required: true },

        get: () => data.locality,
        set: (value: string) => {
          data.locality = value;
        },
        getError: () => errors.locality,
        setError: (value: Option<Array<string>>) => {
          errors.locality = value;
        },
        getTainted: () => tainted.locality,
        setTainted: (value: Option<boolean>) => {
          tainted.locality = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "locality")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField("locality", data.locality);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      administrativeAreaLevel3: {
        path: ["administrativeAreaLevel3"] as const,
        name: "administrativeAreaLevel3",
        constraints: { required: true },

        get: () => data.administrativeAreaLevel3,
        set: (value: string | null) => {
          data.administrativeAreaLevel3 = value;
        },
        getError: () => errors.administrativeAreaLevel3,
        setError: (value: Option<Array<string>>) => {
          errors.administrativeAreaLevel3 = value;
        },
        getTainted: () => tainted.administrativeAreaLevel3,
        setTainted: (value: Option<boolean>) => {
          tainted.administrativeAreaLevel3 = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "administrativeAreaLevel3")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "administrativeAreaLevel3",
            data.administrativeAreaLevel3,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      administrativeAreaLevel2: {
        path: ["administrativeAreaLevel2"] as const,
        name: "administrativeAreaLevel2",
        constraints: { required: true },

        get: () => data.administrativeAreaLevel2,
        set: (value: string | null) => {
          data.administrativeAreaLevel2 = value;
        },
        getError: () => errors.administrativeAreaLevel2,
        setError: (value: Option<Array<string>>) => {
          errors.administrativeAreaLevel2 = value;
        },
        getTainted: () => tainted.administrativeAreaLevel2,
        setTainted: (value: Option<boolean>) => {
          tainted.administrativeAreaLevel2 = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "administrativeAreaLevel2")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "administrativeAreaLevel2",
            data.administrativeAreaLevel2,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      administrativeAreaLevel1: {
        path: ["administrativeAreaLevel1"] as const,
        name: "administrativeAreaLevel1",
        constraints: { required: true },

        get: () => data.administrativeAreaLevel1,
        set: (value: string) => {
          data.administrativeAreaLevel1 = value;
        },
        getError: () => errors.administrativeAreaLevel1,
        setError: (value: Option<Array<string>>) => {
          errors.administrativeAreaLevel1 = value;
        },
        getTainted: () => tainted.administrativeAreaLevel1,
        setTainted: (value: Option<boolean>) => {
          tainted.administrativeAreaLevel1 = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "administrativeAreaLevel1")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "administrativeAreaLevel1",
            data.administrativeAreaLevel1,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      country: {
        path: ["country"] as const,
        name: "country",
        constraints: { required: true },

        get: () => data.country,
        set: (value: string) => {
          data.country = value;
        },
        getError: () => errors.country,
        setError: (value: Option<Array<string>>) => {
          errors.country = value;
        },
        getTainted: () => tainted.country,
        setTainted: (value: Option<boolean>) => {
          tainted.country = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "country")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField("country", data.country);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      postalCode: {
        path: ["postalCode"] as const,
        name: "postalCode",
        constraints: { required: true },

        get: () => data.postalCode,
        set: (value: string) => {
          data.postalCode = value;
        },
        getError: () => errors.postalCode,
        setError: (value: Option<Array<string>>) => {
          errors.postalCode = value;
        },
        getTainted: () => tainted.postalCode,
        setTainted: (value: Option<boolean>) => {
          tainted.postalCode = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "postalCode")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField("postalCode", data.postalCode);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      postalCodeSuffix: {
        path: ["postalCodeSuffix"] as const,
        name: "postalCodeSuffix",
        constraints: { required: true },

        get: () => data.postalCodeSuffix,
        set: (value: string | null) => {
          data.postalCodeSuffix = value;
        },
        getError: () => errors.postalCodeSuffix,
        setError: (value: Option<Array<string>>) => {
          errors.postalCodeSuffix = value;
        },
        getTainted: () => tainted.postalCodeSuffix,
        setTainted: (value: Option<boolean>) => {
          tainted.postalCodeSuffix = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "postalCodeSuffix")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "postalCodeSuffix",
            data.postalCodeSuffix,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      coordinates: {
        path: ["coordinates"] as const,
        name: "coordinates",
        constraints: { required: true },

        get: () => data.coordinates,
        set: (value: Coordinates) => {
          data.coordinates = value;
        },
        getError: () => errors.coordinates,
        setError: (value: Option<Array<string>>) => {
          errors.coordinates = value;
        },
        getTainted: () => tainted.coordinates,
        setTainted: (value: Option<boolean>) => {
          tainted.coordinates = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Site.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "coordinates")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Site.validateField(
            "coordinates",
            data.coordinates,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Site,
      Array<{ field: string; message: string }>
    > {
      return Site.fromObject(data);
    }
    function reset(newOverrides?: Partial<Site>): void {
      data = { ...Site.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        addressLine1: Option.none(),
        addressLine2: Option.none(),
        sublocalityLevel1: Option.none(),
        locality: Option.none(),
        administrativeAreaLevel3: Option.none(),
        administrativeAreaLevel2: Option.none(),
        administrativeAreaLevel1: Option.none(),
        country: Option.none(),
        postalCode: Option.none(),
        postalCodeSuffix: Option.none(),
        coordinates: Option.none(),
      };
      tainted = {
        id: Option.none(),
        addressLine1: Option.none(),
        addressLine2: Option.none(),
        sublocalityLevel1: Option.none(),
        locality: Option.none(),
        administrativeAreaLevel3: Option.none(),
        administrativeAreaLevel2: Option.none(),
        administrativeAreaLevel1: Option.none(),
        country: Option.none(),
        postalCode: Option.none(),
        postalCodeSuffix: Option.none(),
        coordinates: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Site, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.addressLine1 = formData.get("addressLine1") ?? "";
    obj.addressLine2 = formData.get("addressLine2") ?? "";
    obj.sublocalityLevel1 = formData.get("sublocalityLevel1") ?? "";
    obj.locality = formData.get("locality") ?? "";
    obj.administrativeAreaLevel3 =
      formData.get("administrativeAreaLevel3") ?? "";
    obj.administrativeAreaLevel2 =
      formData.get("administrativeAreaLevel2") ?? "";
    obj.administrativeAreaLevel1 =
      formData.get("administrativeAreaLevel1") ?? "";
    obj.country = formData.get("country") ?? "";
    obj.postalCode = formData.get("postalCode") ?? "";
    obj.postalCodeSuffix = formData.get("postalCodeSuffix") ?? "";
    {
      // Collect nested object fields with prefix "coordinates."
      const coordinatesObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("coordinates.")) {
          const fieldName = key.slice("coordinates.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = coordinatesObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.coordinates = coordinatesObj;
    }
    return Site.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Metadata {
  createdAt: string;
  lastLogin: string | null;
  isActive: boolean;
  roles: string[];
}

export namespace Metadata {
  export function defaultValue(): Metadata {
    return {
      createdAt: "",
      lastLogin: null,
      isActive: false,
      roles: [],
    } as Metadata;
  }
}

export namespace Metadata {
  export function toStringifiedJSON(self: Metadata): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Metadata): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Metadata,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Metadata", __id };
    result["createdAt"] = self.createdAt;
    if (self.lastLogin !== null) {
      result["lastLogin"] =
        typeof (self.lastLogin as any)?.__serialize === "function"
          ? (self.lastLogin as any).__serialize(ctx)
          : self.lastLogin;
    } else {
      result["lastLogin"] = null;
    }
    result["isActive"] = self.isActive;
    result["roles"] = self.roles.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    return result;
  }
}

export namespace Metadata {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Metadata, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Metadata, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Metadata.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Metadata | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Metadata.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("createdAt" in obj)) {
      errors.push({ field: "createdAt", message: "missing required field" });
    }
    if (!("lastLogin" in obj)) {
      errors.push({ field: "lastLogin", message: "missing required field" });
    }
    if (!("isActive" in obj)) {
      errors.push({ field: "isActive", message: "missing required field" });
    }
    if (!("roles" in obj)) {
      errors.push({ field: "roles", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_createdAt = obj["createdAt"];
      instance.createdAt = __raw_createdAt;
    }
    {
      const __raw_lastLogin = obj["lastLogin"];
      instance.lastLogin = __raw_lastLogin;
    }
    {
      const __raw_isActive = obj["isActive"];
      instance.isActive = __raw_isActive;
    }
    {
      const __raw_roles = obj["roles"];
      instance.roles = __raw_roles;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Metadata;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Metadata>(
    field: K,
    value: Metadata[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Metadata>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Metadata {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    createdAt: Option<Array<string>>;
    lastLogin: Option<Array<string>>;
    isActive: Option<Array<string>>;
    roles: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      createdAt: Option<boolean>;
      lastLogin: Option<boolean>;
      isActive: Option<boolean>;
      roles: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly createdAt: FieldController<string>;
    readonly lastLogin: FieldController<string | null>;
    readonly isActive: FieldController<boolean>;
    readonly roles: ArrayFieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Metadata;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Metadata, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Metadata>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Metadata>,
  ): Gigaform {
    let data = $state({ ...Metadata.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      createdAt: Option.none(),
      lastLogin: Option.none(),
      isActive: Option.none(),
      roles: Option.none(),
    });
    let tainted = $state<Tainted>({
      createdAt: Option.none(),
      lastLogin: Option.none(),
      isActive: Option.none(),
      roles: Option.none(),
    });
    const fields: FieldControllers = {
      createdAt: {
        path: ["createdAt"] as const,
        name: "createdAt",
        constraints: { required: true },

        get: () => data.createdAt,
        set: (value: string) => {
          data.createdAt = value;
        },
        getError: () => errors.createdAt,
        setError: (value: Option<Array<string>>) => {
          errors.createdAt = value;
        },
        getTainted: () => tainted.createdAt,
        setTainted: (value: Option<boolean>) => {
          tainted.createdAt = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Metadata.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "createdAt")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Metadata.validateField(
            "createdAt",
            data.createdAt,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      lastLogin: {
        path: ["lastLogin"] as const,
        name: "lastLogin",
        constraints: { required: true },

        get: () => data.lastLogin,
        set: (value: string | null) => {
          data.lastLogin = value;
        },
        getError: () => errors.lastLogin,
        setError: (value: Option<Array<string>>) => {
          errors.lastLogin = value;
        },
        getTainted: () => tainted.lastLogin,
        setTainted: (value: Option<boolean>) => {
          tainted.lastLogin = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Metadata.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lastLogin")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Metadata.validateField(
            "lastLogin",
            data.lastLogin,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      isActive: {
        path: ["isActive"] as const,
        name: "isActive",
        constraints: { required: true },

        get: () => data.isActive,
        set: (value: boolean) => {
          data.isActive = value;
        },
        getError: () => errors.isActive,
        setError: (value: Option<Array<string>>) => {
          errors.isActive = value;
        },
        getTainted: () => tainted.isActive,
        setTainted: (value: Option<boolean>) => {
          tainted.isActive = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Metadata.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "isActive")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Metadata.validateField("isActive", data.isActive);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      roles: {
        path: ["roles"] as const,
        name: "roles",
        constraints: { required: true },

        get: () => data.roles,
        set: (value: string[]) => {
          data.roles = value;
        },
        getError: () => errors.roles,
        setError: (value: Option<Array<string>>) => {
          errors.roles = value;
        },
        getTainted: () => tainted.roles,
        setTainted: (value: Option<boolean>) => {
          tainted.roles = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Metadata.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "roles")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Metadata.validateField("roles", data.roles);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["roles", index] as const,
          name: `roles.${index}`,
          constraints: { required: true },
          get: () => data.roles[index],
          set: (value: string) => {
            data.roles[index] = value;
          },
          getError: () => errors.roles,
          setError: (value: Option<Array<string>>) => {
            errors.roles = value;
          },
          getTainted: () => tainted.roles,
          setTainted: (value: Option<boolean>) => {
            tainted.roles = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.roles.push(item);
        },
        remove: (index: number) => {
          data.roles.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.roles[a], data.roles[b]] = [data.roles[b], data.roles[a]];
        },
      },
    };
    function validate(): Result<
      Metadata,
      Array<{ field: string; message: string }>
    > {
      return Metadata.fromObject(data);
    }
    function reset(newOverrides?: Partial<Metadata>): void {
      data = { ...Metadata.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        createdAt: Option.none(),
        lastLogin: Option.none(),
        isActive: Option.none(),
        roles: Option.none(),
      };
      tainted = {
        createdAt: Option.none(),
        lastLogin: Option.none(),
        isActive: Option.none(),
        roles: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Metadata, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.createdAt = formData.get("createdAt") ?? "";
    obj.lastLogin = formData.get("lastLogin") ?? "";
    {
      const isActiveVal = formData.get("isActive");
      obj.isActive =
        isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
    }
    obj.roles = formData.getAll("roles") as Array<string>;
    return Metadata.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface ColumnConfig {
  heading: string;
  dataPath: DataPath;
}

export namespace ColumnConfig {
  export function defaultValue(): ColumnConfig {
    return { heading: "", dataPath: DataPath.defaultValue() } as ColumnConfig;
  }
}

export namespace ColumnConfig {
  export function toStringifiedJSON(self: ColumnConfig): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: ColumnConfig): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: ColumnConfig,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "ColumnConfig", __id };
    result["heading"] = self.heading;
    result["dataPath"] =
      typeof (self.dataPath as any)?.__serialize === "function"
        ? (self.dataPath as any).__serialize(ctx)
        : self.dataPath;
    return result;
  }
}

export namespace ColumnConfig {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<ColumnConfig, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<ColumnConfig, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "ColumnConfig.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): ColumnConfig | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "ColumnConfig.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("heading" in obj)) {
      errors.push({ field: "heading", message: "missing required field" });
    }
    if (!("dataPath" in obj)) {
      errors.push({ field: "dataPath", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_heading = obj["heading"];
      instance.heading = __raw_heading;
    }
    {
      const __raw_dataPath = obj["dataPath"];
      if (typeof (DataPath as any)?.__deserialize === "function") {
        const __result = (DataPath as any).__deserialize(__raw_dataPath, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "dataPath", __result);
=======
        if (PendingRef.is(__result)) {
          instance.dataPath = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.dataPath = v;
          });
        } else {
          instance.dataPath = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.dataPath = __raw_dataPath;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as ColumnConfig;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof ColumnConfig>(
    field: K,
    value: ColumnConfig[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "heading": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "heading", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<ColumnConfig>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("heading" in partial && partial.heading !== undefined) {
      const __val = partial.heading as string;
      if (__val.length === 0) {
        errors.push({ field: "heading", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace ColumnConfig {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    heading: Option<Array<string>>;
    dataPath: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { heading: Option<boolean>; dataPath: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly heading: FieldController<string>;
    readonly dataPath: FieldController<DataPath>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ColumnConfig;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<ColumnConfig, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<ColumnConfig>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ColumnConfig>,
  ): Gigaform {
    let data = $state({ ...ColumnConfig.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      heading: Option.none(),
      dataPath: Option.none(),
    });
    let tainted = $state<Tainted>({
      heading: Option.none(),
      dataPath: Option.none(),
    });
    const fields: FieldControllers = {
      heading: {
        path: ["heading"] as const,
        name: "heading",
        constraints: { required: true },

        get: () => data.heading,
        set: (value: string) => {
          data.heading = value;
        },
        getError: () => errors.heading,
        setError: (value: Option<Array<string>>) => {
          errors.heading = value;
        },
        getTainted: () => tainted.heading,
        setTainted: (value: Option<boolean>) => {
          tainted.heading = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = ColumnConfig.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "heading")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = ColumnConfig.validateField(
            "heading",
            data.heading,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      dataPath: {
        path: ["dataPath"] as const,
        name: "dataPath",
        constraints: { required: true },

        get: () => data.dataPath,
        set: (value: DataPath) => {
          data.dataPath = value;
        },
        getError: () => errors.dataPath,
        setError: (value: Option<Array<string>>) => {
          errors.dataPath = value;
        },
        getTainted: () => tainted.dataPath,
        setTainted: (value: Option<boolean>) => {
          tainted.dataPath = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = ColumnConfig.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "dataPath")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = ColumnConfig.validateField(
            "dataPath",
            data.dataPath,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      ColumnConfig,
      Array<{ field: string; message: string }>
    > {
      return ColumnConfig.fromObject(data);
    }
    function reset(newOverrides?: Partial<ColumnConfig>): void {
      data = { ...ColumnConfig.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        heading: Option.none(),
        dataPath: Option.none(),
      };
      tainted = { heading: Option.none(), dataPath: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ColumnConfig, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.heading = formData.get("heading") ?? "";
    {
      // Collect nested object fields with prefix "dataPath."
      const dataPathObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("dataPath.")) {
          const fieldName = key.slice("dataPath.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = dataPathObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.dataPath = dataPathObj;
    }
    return ColumnConfig.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface PhoneNumber {
  main: boolean;

  phoneType: string;

  number: string;
<<<<<<< Updated upstream
  canText: boolean;
=======

  canText: boolean;

>>>>>>> Stashed changes
  canCall: boolean;
}

export namespace PhoneNumber {
  export function defaultValue(): PhoneNumber {
    return {
      main: false,
      phoneType: "",
      number: "",
      canText: false,
      canCall: false,
    } as PhoneNumber;
  }
}

export namespace PhoneNumber {
  export function toStringifiedJSON(self: PhoneNumber): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: PhoneNumber): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: PhoneNumber,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "PhoneNumber", __id };
    result["main"] = self.main;
    result["phoneType"] = self.phoneType;
    result["number"] = self.number;
    result["canText"] = self.canText;
    result["canCall"] = self.canCall;
    return result;
  }
}

export namespace PhoneNumber {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<PhoneNumber, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<PhoneNumber, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "PhoneNumber.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): PhoneNumber | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "PhoneNumber.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("main" in obj)) {
      errors.push({ field: "main", message: "missing required field" });
    }
    if (!("phoneType" in obj)) {
      errors.push({ field: "phoneType", message: "missing required field" });
    }
    if (!("number" in obj)) {
      errors.push({ field: "number", message: "missing required field" });
    }
    if (!("canText" in obj)) {
      errors.push({ field: "canText", message: "missing required field" });
    }
    if (!("canCall" in obj)) {
      errors.push({ field: "canCall", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_main = obj["main"];
      instance.main = __raw_main;
    }
    {
      const __raw_phoneType = obj["phoneType"];
      instance.phoneType = __raw_phoneType;
    }
    {
      const __raw_number = obj["number"];
      instance.number = __raw_number;
    }
    {
      const __raw_canText = obj["canText"];
      instance.canText = __raw_canText;
    }
    {
      const __raw_canCall = obj["canCall"];
      instance.canCall = __raw_canCall;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as PhoneNumber;
  }
<<<<<<< Updated upstream
}

export namespace PhoneNumber {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    main: Option<Array<string>>;
    phoneType: Option<Array<string>>;
    number: Option<Array<string>>;
    canText: Option<Array<string>>;
    canCall: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      main: Option<boolean>;
      phoneType: Option<boolean>;
      number: Option<boolean>;
      canText: Option<boolean>;
      canCall: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly main: FieldController<boolean>;
    readonly phoneType: FieldController<string>;
    readonly number: FieldController<string>;
    readonly canText: FieldController<boolean>;
    readonly canCall: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: PhoneNumber;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<PhoneNumber, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<PhoneNumber>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<PhoneNumber>,
  ): Gigaform {
    let data = $state({ ...PhoneNumber.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      main: Option.none(),
      phoneType: Option.none(),
      number: Option.none(),
      canText: Option.none(),
      canCall: Option.none(),
    });
    let tainted = $state<Tainted>({
      main: Option.none(),
      phoneType: Option.none(),
      number: Option.none(),
      canText: Option.none(),
      canCall: Option.none(),
    });
    const fields: FieldControllers = {
      main: {
        path: ["main"] as const,
        name: "main",
        constraints: { required: true },

=======
  export function validateField<K extends keyof PhoneNumber>(
    field: K,
    value: PhoneNumber[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "phoneType": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "phoneType", message: "must not be empty" });
        }
        break;
      }
      case "number": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "number", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<PhoneNumber>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("phoneType" in partial && partial.phoneType !== undefined) {
      const __val = partial.phoneType as string;
      if (__val.length === 0) {
        errors.push({ field: "phoneType", message: "must not be empty" });
      }
    }
    if ("number" in partial && partial.number !== undefined) {
      const __val = partial.number as string;
      if (__val.length === 0) {
        errors.push({ field: "number", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace PhoneNumber {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    main: Option<Array<string>>;
    phoneType: Option<Array<string>>;
    number: Option<Array<string>>;
    canText: Option<Array<string>>;
    canCall: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      main: Option<boolean>;
      phoneType: Option<boolean>;
      number: Option<boolean>;
      canText: Option<boolean>;
      canCall: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly main: FieldController<boolean>;
    readonly phoneType: FieldController<string>;
    readonly number: FieldController<string>;
    readonly canText: FieldController<boolean>;
    readonly canCall: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: PhoneNumber;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<PhoneNumber, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<PhoneNumber>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<PhoneNumber>,
  ): Gigaform {
    let data = $state({ ...PhoneNumber.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      main: Option.none(),
      phoneType: Option.none(),
      number: Option.none(),
      canText: Option.none(),
      canCall: Option.none(),
    });
    let tainted = $state<Tainted>({
      main: Option.none(),
      phoneType: Option.none(),
      number: Option.none(),
      canText: Option.none(),
      canCall: Option.none(),
    });
    const fields: FieldControllers = {
      main: {
        path: ["main"] as const,
        name: "main",
        constraints: { required: true },
        label: "Main",
>>>>>>> Stashed changes
        get: () => data.main,
        set: (value: boolean) => {
          data.main = value;
        },
        getError: () => errors.main,
        setError: (value: Option<Array<string>>) => {
          errors.main = value;
        },
        getTainted: () => tainted.main,
        setTainted: (value: Option<boolean>) => {
          tainted.main = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = PhoneNumber.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "main")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = PhoneNumber.validateField("main", data.main);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      phoneType: {
        path: ["phoneType"] as const,
        name: "phoneType",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Phone Type",
>>>>>>> Stashed changes
        get: () => data.phoneType,
        set: (value: string) => {
          data.phoneType = value;
        },
        getError: () => errors.phoneType,
        setError: (value: Option<Array<string>>) => {
          errors.phoneType = value;
        },
        getTainted: () => tainted.phoneType,
        setTainted: (value: Option<boolean>) => {
          tainted.phoneType = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = PhoneNumber.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "phoneType")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = PhoneNumber.validateField(
            "phoneType",
            data.phoneType,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      number: {
        path: ["number"] as const,
        name: "number",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Number",
>>>>>>> Stashed changes
        get: () => data.number,
        set: (value: string) => {
          data.number = value;
        },
        getError: () => errors.number,
        setError: (value: Option<Array<string>>) => {
          errors.number = value;
        },
        getTainted: () => tainted.number,
        setTainted: (value: Option<boolean>) => {
          tainted.number = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = PhoneNumber.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "number")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = PhoneNumber.validateField("number", data.number);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      canText: {
        path: ["canText"] as const,
        name: "canText",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Can Text",
>>>>>>> Stashed changes
        get: () => data.canText,
        set: (value: boolean) => {
          data.canText = value;
        },
        getError: () => errors.canText,
        setError: (value: Option<Array<string>>) => {
          errors.canText = value;
        },
        getTainted: () => tainted.canText,
        setTainted: (value: Option<boolean>) => {
          tainted.canText = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = PhoneNumber.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "canText")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = PhoneNumber.validateField(
            "canText",
            data.canText,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      canCall: {
        path: ["canCall"] as const,
        name: "canCall",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Can Call",
>>>>>>> Stashed changes
        get: () => data.canCall,
        set: (value: boolean) => {
          data.canCall = value;
        },
        getError: () => errors.canCall,
        setError: (value: Option<Array<string>>) => {
          errors.canCall = value;
        },
        getTainted: () => tainted.canCall,
        setTainted: (value: Option<boolean>) => {
          tainted.canCall = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = PhoneNumber.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "canCall")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = PhoneNumber.validateField(
            "canCall",
            data.canCall,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      PhoneNumber,
      Array<{ field: string; message: string }>
    > {
      return PhoneNumber.fromObject(data);
    }
    function reset(newOverrides?: Partial<PhoneNumber>): void {
      data = { ...PhoneNumber.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        main: Option.none(),
        phoneType: Option.none(),
        number: Option.none(),
        canText: Option.none(),
        canCall: Option.none(),
      };
      tainted = {
        main: Option.none(),
        phoneType: Option.none(),
        number: Option.none(),
        canText: Option.none(),
        canCall: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<PhoneNumber, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const mainVal = formData.get("main");
      obj.main = mainVal === "true" || mainVal === "on" || mainVal === "1";
    }
    obj.phoneType = formData.get("phoneType") ?? "";
    obj.number = formData.get("number") ?? "";
    {
      const canTextVal = formData.get("canText");
      obj.canText =
        canTextVal === "true" || canTextVal === "on" || canTextVal === "1";
    }
    {
      const canCallVal = formData.get("canCall");
      obj.canCall =
        canCallVal === "true" || canCallVal === "on" || canCallVal === "1";
    }
    return PhoneNumber.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Gradient {
  startHue: number;
}

export namespace Gradient {
  export function defaultValue(): Gradient {
    return { startHue: 0 } as Gradient;
  }
}

export namespace Gradient {
  export function toStringifiedJSON(self: Gradient): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Gradient): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Gradient,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Gradient", __id };
    result["startHue"] = self.startHue;
    return result;
  }
}

export namespace Gradient {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Gradient, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Gradient, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Gradient.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Gradient | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Gradient.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("startHue" in obj)) {
      errors.push({ field: "startHue", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_startHue = obj["startHue"];
      instance.startHue = __raw_startHue;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Gradient;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Gradient>(
    field: K,
    value: Gradient[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Gradient>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Gradient {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    startHue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { startHue: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly startHue: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Gradient;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Gradient, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Gradient>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Gradient>,
  ): Gigaform {
    let data = $state({ ...Gradient.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      startHue: Option.none(),
    });
    let tainted = $state<Tainted>({ startHue: Option.none() });
    const fields: FieldControllers = {
      startHue: {
        path: ["startHue"] as const,
        name: "startHue",
        constraints: { required: true },

        get: () => data.startHue,
        set: (value: number) => {
          data.startHue = value;
        },
        getError: () => errors.startHue,
        setError: (value: Option<Array<string>>) => {
          errors.startHue = value;
        },
        getTainted: () => tainted.startHue,
        setTainted: (value: Option<boolean>) => {
          tainted.startHue = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Gradient.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "startHue")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Gradient.validateField("startHue", data.startHue);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Gradient,
      Array<{ field: string; message: string }>
    > {
      return Gradient.fromObject(data);
    }
    function reset(newOverrides?: Partial<Gradient>): void {
      data = { ...Gradient.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), startHue: Option.none() };
      tainted = { startHue: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Gradient, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const startHueStr = formData.get("startHue");
      obj.startHue = startHueStr ? parseFloat(startHueStr as string) : 0;
      if (obj.startHue !== undefined && isNaN(obj.startHue as number))
        obj.startHue = 0;
    }
    return Gradient.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Product {
  id: string;

  name: string;

  quickCode: string;
<<<<<<< Updated upstream
  group: string | null;
  subgroup: string | null;
  unit: string | null;
  active: boolean;
  commission: boolean;
=======

  group: string | null;

  subgroup: string | null;

  unit: string | null;

  active: boolean;

  commission: boolean;

>>>>>>> Stashed changes
  favorite: boolean;
  defaults: ProductDefaults;
}

export namespace Product {
  export function defaultValue(): Product {
    return {
      id: "",
      name: "",
      quickCode: "",
      group: null,
      subgroup: null,
      unit: null,
      active: false,
      commission: false,
      favorite: false,
      defaults: ProductDefaults.defaultValue(),
    } as Product;
  }
}

export namespace Product {
  export function toStringifiedJSON(self: Product): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Product): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Product,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Product", __id };
    result["id"] = self.id;
    result["name"] = self.name;
    result["quickCode"] = self.quickCode;
    if (self.group !== null) {
      result["group"] =
        typeof (self.group as any)?.__serialize === "function"
          ? (self.group as any).__serialize(ctx)
          : self.group;
    } else {
      result["group"] = null;
    }
    if (self.subgroup !== null) {
      result["subgroup"] =
        typeof (self.subgroup as any)?.__serialize === "function"
          ? (self.subgroup as any).__serialize(ctx)
          : self.subgroup;
    } else {
      result["subgroup"] = null;
    }
    if (self.unit !== null) {
      result["unit"] =
        typeof (self.unit as any)?.__serialize === "function"
          ? (self.unit as any).__serialize(ctx)
          : self.unit;
    } else {
      result["unit"] = null;
    }
    result["active"] = self.active;
    result["commission"] = self.commission;
    result["favorite"] = self.favorite;
    result["defaults"] =
      typeof (self.defaults as any)?.__serialize === "function"
        ? (self.defaults as any).__serialize(ctx)
        : self.defaults;
    return result;
  }
}

export namespace Product {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Product, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Product, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Product.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Product | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Product.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (!("quickCode" in obj)) {
      errors.push({ field: "quickCode", message: "missing required field" });
    }
    if (!("group" in obj)) {
      errors.push({ field: "group", message: "missing required field" });
    }
    if (!("subgroup" in obj)) {
      errors.push({ field: "subgroup", message: "missing required field" });
    }
    if (!("unit" in obj)) {
      errors.push({ field: "unit", message: "missing required field" });
    }
    if (!("active" in obj)) {
      errors.push({ field: "active", message: "missing required field" });
    }
    if (!("commission" in obj)) {
      errors.push({ field: "commission", message: "missing required field" });
    }
    if (!("favorite" in obj)) {
      errors.push({ field: "favorite", message: "missing required field" });
    }
    if (!("defaults" in obj)) {
      errors.push({ field: "defaults", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    {
      const __raw_quickCode = obj["quickCode"];
      instance.quickCode = __raw_quickCode;
    }
    {
      const __raw_group = obj["group"];
      instance.group = __raw_group;
    }
    {
      const __raw_subgroup = obj["subgroup"];
      instance.subgroup = __raw_subgroup;
    }
    {
      const __raw_unit = obj["unit"];
      instance.unit = __raw_unit;
    }
    {
      const __raw_active = obj["active"];
      instance.active = __raw_active;
    }
    {
      const __raw_commission = obj["commission"];
      instance.commission = __raw_commission;
    }
    {
      const __raw_favorite = obj["favorite"];
      instance.favorite = __raw_favorite;
    }
    {
      const __raw_defaults = obj["defaults"];
      if (typeof (ProductDefaults as any)?.__deserialize === "function") {
        const __result = (ProductDefaults as any).__deserialize(
          __raw_defaults,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "defaults", __result);
=======
        if (PendingRef.is(__result)) {
          instance.defaults = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.defaults = v;
          });
        } else {
          instance.defaults = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.defaults = __raw_defaults;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Product;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Product>(
    field: K,
    value: Product[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
      case "quickCode": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "quickCode", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Product>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    if ("quickCode" in partial && partial.quickCode !== undefined) {
      const __val = partial.quickCode as string;
      if (__val.length === 0) {
        errors.push({ field: "quickCode", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Product {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    name: Option<Array<string>>;
    quickCode: Option<Array<string>>;
    group: Option<Array<string>>;
    subgroup: Option<Array<string>>;
    unit: Option<Array<string>>;
    active: Option<Array<string>>;
    commission: Option<Array<string>>;
    favorite: Option<Array<string>>;
    defaults: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      name: Option<boolean>;
      quickCode: Option<boolean>;
      group: Option<boolean>;
      subgroup: Option<boolean>;
      unit: Option<boolean>;
      active: Option<boolean>;
      commission: Option<boolean>;
      favorite: Option<boolean>;
      defaults: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly quickCode: FieldController<string>;
    readonly group: FieldController<string | null>;
    readonly subgroup: FieldController<string | null>;
    readonly unit: FieldController<string | null>;
    readonly active: FieldController<boolean>;
    readonly commission: FieldController<boolean>;
    readonly favorite: FieldController<boolean>;
    readonly defaults: FieldController<ProductDefaults>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Product;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Product, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Product>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Product>,
  ): Gigaform {
    let data = $state({ ...Product.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      defaults: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      name: Option.none(),
      quickCode: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      unit: Option.none(),
      active: Option.none(),
      commission: Option.none(),
      favorite: Option.none(),
      defaults: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Name",
>>>>>>> Stashed changes
        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("name", data.name);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      quickCode: {
        path: ["quickCode"] as const,
        name: "quickCode",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Quick Code",
>>>>>>> Stashed changes
        get: () => data.quickCode,
        set: (value: string) => {
          data.quickCode = value;
        },
        getError: () => errors.quickCode,
        setError: (value: Option<Array<string>>) => {
          errors.quickCode = value;
        },
        getTainted: () => tainted.quickCode,
        setTainted: (value: Option<boolean>) => {
          tainted.quickCode = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "quickCode")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField(
            "quickCode",
            data.quickCode,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      group: {
        path: ["group"] as const,
        name: "group",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Group",
>>>>>>> Stashed changes
        get: () => data.group,
        set: (value: string | null) => {
          data.group = value;
        },
        getError: () => errors.group,
        setError: (value: Option<Array<string>>) => {
          errors.group = value;
        },
        getTainted: () => tainted.group,
        setTainted: (value: Option<boolean>) => {
          tainted.group = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "group")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("group", data.group);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      subgroup: {
        path: ["subgroup"] as const,
        name: "subgroup",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Subgroup",
>>>>>>> Stashed changes
        get: () => data.subgroup,
        set: (value: string | null) => {
          data.subgroup = value;
        },
        getError: () => errors.subgroup,
        setError: (value: Option<Array<string>>) => {
          errors.subgroup = value;
        },
        getTainted: () => tainted.subgroup,
        setTainted: (value: Option<boolean>) => {
          tainted.subgroup = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "subgroup")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("subgroup", data.subgroup);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      unit: {
        path: ["unit"] as const,
        name: "unit",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Unit",
>>>>>>> Stashed changes
        get: () => data.unit,
        set: (value: string | null) => {
          data.unit = value;
        },
        getError: () => errors.unit,
        setError: (value: Option<Array<string>>) => {
          errors.unit = value;
        },
        getTainted: () => tainted.unit,
        setTainted: (value: Option<boolean>) => {
          tainted.unit = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "unit")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("unit", data.unit);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Active",
>>>>>>> Stashed changes
        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "active")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("active", data.active);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      commission: {
        path: ["commission"] as const,
        name: "commission",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Commission",
>>>>>>> Stashed changes
        get: () => data.commission,
        set: (value: boolean) => {
          data.commission = value;
        },
        getError: () => errors.commission,
        setError: (value: Option<Array<string>>) => {
          errors.commission = value;
        },
        getTainted: () => tainted.commission,
        setTainted: (value: Option<boolean>) => {
          tainted.commission = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "commission")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField(
            "commission",
            data.commission,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      favorite: {
        path: ["favorite"] as const,
        name: "favorite",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Favorite",
>>>>>>> Stashed changes
        get: () => data.favorite,
        set: (value: boolean) => {
          data.favorite = value;
        },
        getError: () => errors.favorite,
        setError: (value: Option<Array<string>>) => {
          errors.favorite = value;
        },
        getTainted: () => tainted.favorite,
        setTainted: (value: Option<boolean>) => {
          tainted.favorite = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "favorite")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("favorite", data.favorite);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      defaults: {
        path: ["defaults"] as const,
        name: "defaults",
        constraints: { required: true },

        get: () => data.defaults,
        set: (value: ProductDefaults) => {
          data.defaults = value;
        },
        getError: () => errors.defaults,
        setError: (value: Option<Array<string>>) => {
          errors.defaults = value;
        },
        getTainted: () => tainted.defaults,
        setTainted: (value: Option<boolean>) => {
          tainted.defaults = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Product.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "defaults")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Product.validateField("defaults", data.defaults);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Product,
      Array<{ field: string; message: string }>
    > {
      return Product.fromObject(data);
    }
    function reset(newOverrides?: Partial<Product>): void {
      data = { ...Product.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        defaults: Option.none(),
      };
      tainted = {
        id: Option.none(),
        name: Option.none(),
        quickCode: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        unit: Option.none(),
        active: Option.none(),
        commission: Option.none(),
        favorite: Option.none(),
        defaults: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Product, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.name = formData.get("name") ?? "";
    obj.quickCode = formData.get("quickCode") ?? "";
    obj.group = formData.get("group") ?? "";
    obj.subgroup = formData.get("subgroup") ?? "";
    obj.unit = formData.get("unit") ?? "";
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
      const commissionVal = formData.get("commission");
      obj.commission =
        commissionVal === "true" ||
        commissionVal === "on" ||
        commissionVal === "1";
    }
    {
      const favoriteVal = formData.get("favorite");
      obj.favorite =
        favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    {
      // Collect nested object fields with prefix "defaults."
      const defaultsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("defaults.")) {
          const fieldName = key.slice("defaults.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = defaultsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.defaults = defaultsObj;
    }
    return Product.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface YearlyRecurrenceRule {
  quantityOfYears: number;
}

export namespace YearlyRecurrenceRule {
  export function defaultValue(): YearlyRecurrenceRule {
    return { quantityOfYears: 0 } as YearlyRecurrenceRule;
  }
}

export namespace YearlyRecurrenceRule {
  export function toStringifiedJSON(self: YearlyRecurrenceRule): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(
    self: YearlyRecurrenceRule,
  ): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: YearlyRecurrenceRule,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "YearlyRecurrenceRule",
      __id,
    };
    result["quantityOfYears"] = self.quantityOfYears;
    return result;
  }
}

export namespace YearlyRecurrenceRule {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<YearlyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<YearlyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "YearlyRecurrenceRule.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): YearlyRecurrenceRule | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "YearlyRecurrenceRule.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("quantityOfYears" in obj)) {
      errors.push({
        field: "quantityOfYears",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_quantityOfYears = obj["quantityOfYears"];
      instance.quantityOfYears = __raw_quantityOfYears;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as YearlyRecurrenceRule;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof YearlyRecurrenceRule>(
    field: K,
    value: YearlyRecurrenceRule[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<YearlyRecurrenceRule>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace YearlyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfYears: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { quantityOfYears: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfYears: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: YearlyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      YearlyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<YearlyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<YearlyRecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...YearlyRecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfYears: Option.none(),
    });
    let tainted = $state<Tainted>({ quantityOfYears: Option.none() });
    const fields: FieldControllers = {
      quantityOfYears: {
        path: ["quantityOfYears"] as const,
        name: "quantityOfYears",
        constraints: { required: true },

        get: () => data.quantityOfYears,
        set: (value: number) => {
          data.quantityOfYears = value;
        },
        getError: () => errors.quantityOfYears,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfYears = value;
        },
        getTainted: () => tainted.quantityOfYears,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfYears = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = YearlyRecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "quantityOfYears")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = YearlyRecurrenceRule.validateField(
            "quantityOfYears",
            data.quantityOfYears,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      YearlyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return YearlyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<YearlyRecurrenceRule>): void {
      data = { ...YearlyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), quantityOfYears: Option.none() };
      tainted = { quantityOfYears: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<YearlyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfYearsStr = formData.get("quantityOfYears");
      obj.quantityOfYears = quantityOfYearsStr
        ? parseFloat(quantityOfYearsStr as string)
        : 0;
      if (
        obj.quantityOfYears !== undefined &&
        isNaN(obj.quantityOfYears as number)
      )
        obj.quantityOfYears = 0;
    }
    return YearlyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface AppointmentNotifications {
  personalScheduleChangeNotifications: string;

  allScheduleChangeNotifications: string;
}

export namespace AppointmentNotifications {
  export function defaultValue(): AppointmentNotifications {
    return {
      personalScheduleChangeNotifications: "",
      allScheduleChangeNotifications: "",
    } as AppointmentNotifications;
  }
}

export namespace AppointmentNotifications {
  export function toStringifiedJSON(self: AppointmentNotifications): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(
    self: AppointmentNotifications,
  ): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: AppointmentNotifications,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "AppointmentNotifications",
      __id,
    };
    result["personalScheduleChangeNotifications"] =
      self.personalScheduleChangeNotifications;
    result["allScheduleChangeNotifications"] =
      self.allScheduleChangeNotifications;
    return result;
  }
}

export namespace AppointmentNotifications {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<
    AppointmentNotifications,
    Array<{ field: string; message: string }>
  > {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<
    AppointmentNotifications,
    Array<{ field: string; message: string }>
  > {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "AppointmentNotifications.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): AppointmentNotifications | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "AppointmentNotifications.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("personalScheduleChangeNotifications" in obj)) {
      errors.push({
        field: "personalScheduleChangeNotifications",
        message: "missing required field",
      });
    }
    if (!("allScheduleChangeNotifications" in obj)) {
      errors.push({
        field: "allScheduleChangeNotifications",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_personalScheduleChangeNotifications =
        obj["personalScheduleChangeNotifications"];
      instance.personalScheduleChangeNotifications =
        __raw_personalScheduleChangeNotifications;
    }
    {
      const __raw_allScheduleChangeNotifications =
        obj["allScheduleChangeNotifications"];
      instance.allScheduleChangeNotifications =
        __raw_allScheduleChangeNotifications;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as AppointmentNotifications;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof AppointmentNotifications>(
    field: K,
    value: AppointmentNotifications[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "personalScheduleChangeNotifications": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "personalScheduleChangeNotifications",
            message: "must not be empty",
          });
        }
        break;
      }
      case "allScheduleChangeNotifications": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "allScheduleChangeNotifications",
            message: "must not be empty",
          });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<AppointmentNotifications>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if (
      "personalScheduleChangeNotifications" in partial &&
      partial.personalScheduleChangeNotifications !== undefined
    ) {
      const __val = partial.personalScheduleChangeNotifications as string;
      if (__val.length === 0) {
        errors.push({
          field: "personalScheduleChangeNotifications",
          message: "must not be empty",
        });
      }
    }
    if (
      "allScheduleChangeNotifications" in partial &&
      partial.allScheduleChangeNotifications !== undefined
    ) {
      const __val = partial.allScheduleChangeNotifications as string;
      if (__val.length === 0) {
        errors.push({
          field: "allScheduleChangeNotifications",
          message: "must not be empty",
        });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace AppointmentNotifications {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    personalScheduleChangeNotifications: Option<Array<string>>;
    allScheduleChangeNotifications: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      personalScheduleChangeNotifications: Option<boolean>;
      allScheduleChangeNotifications: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly personalScheduleChangeNotifications: FieldController<string>;
    readonly allScheduleChangeNotifications: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: AppointmentNotifications;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      AppointmentNotifications,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<AppointmentNotifications>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<AppointmentNotifications>,
  ): Gigaform {
    let data = $state({
      ...AppointmentNotifications.defaultValue(),
      ...overrides,
    });
    let errors = $state<Errors>({
      _errors: Option.none(),
      personalScheduleChangeNotifications: Option.none(),
      allScheduleChangeNotifications: Option.none(),
    });
    let tainted = $state<Tainted>({
      personalScheduleChangeNotifications: Option.none(),
      allScheduleChangeNotifications: Option.none(),
    });
    const fields: FieldControllers = {
      personalScheduleChangeNotifications: {
        path: ["personalScheduleChangeNotifications"] as const,
        name: "personalScheduleChangeNotifications",
        constraints: { required: true },

        get: () => data.personalScheduleChangeNotifications,
        set: (value: string) => {
          data.personalScheduleChangeNotifications = value;
        },
        getError: () => errors.personalScheduleChangeNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.personalScheduleChangeNotifications = value;
        },
        getTainted: () => tainted.personalScheduleChangeNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.personalScheduleChangeNotifications = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = AppointmentNotifications.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "personalScheduleChangeNotifications")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = AppointmentNotifications.validateField(
            "personalScheduleChangeNotifications",
            data.personalScheduleChangeNotifications,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      allScheduleChangeNotifications: {
        path: ["allScheduleChangeNotifications"] as const,
        name: "allScheduleChangeNotifications",
        constraints: { required: true },

        get: () => data.allScheduleChangeNotifications,
        set: (value: string) => {
          data.allScheduleChangeNotifications = value;
        },
        getError: () => errors.allScheduleChangeNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.allScheduleChangeNotifications = value;
        },
        getTainted: () => tainted.allScheduleChangeNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.allScheduleChangeNotifications = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = AppointmentNotifications.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "allScheduleChangeNotifications")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = AppointmentNotifications.validateField(
            "allScheduleChangeNotifications",
            data.allScheduleChangeNotifications,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      AppointmentNotifications,
      Array<{ field: string; message: string }>
    > {
      return AppointmentNotifications.fromObject(data);
    }
    function reset(newOverrides?: Partial<AppointmentNotifications>): void {
      data = { ...AppointmentNotifications.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        personalScheduleChangeNotifications: Option.none(),
        allScheduleChangeNotifications: Option.none(),
      };
      tainted = {
        personalScheduleChangeNotifications: Option.none(),
        allScheduleChangeNotifications: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<
    AppointmentNotifications,
    Array<{ field: string; message: string }>
  > {
    const obj: Record<string, unknown> = {};
    obj.personalScheduleChangeNotifications =
      formData.get("personalScheduleChangeNotifications") ?? "";
    obj.allScheduleChangeNotifications =
      formData.get("allScheduleChangeNotifications") ?? "";
    return AppointmentNotifications.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface DirectionHue {
  bearing: number;
  hue: number;
}

export namespace DirectionHue {
  export function defaultValue(): DirectionHue {
    return { bearing: 0, hue: 0 } as DirectionHue;
  }
}

export namespace DirectionHue {
  export function toStringifiedJSON(self: DirectionHue): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: DirectionHue): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: DirectionHue,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "DirectionHue", __id };
    result["bearing"] = self.bearing;
    result["hue"] = self.hue;
    return result;
  }
}

export namespace DirectionHue {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<DirectionHue, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<DirectionHue, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "DirectionHue.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): DirectionHue | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "DirectionHue.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("bearing" in obj)) {
      errors.push({ field: "bearing", message: "missing required field" });
    }
    if (!("hue" in obj)) {
      errors.push({ field: "hue", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_bearing = obj["bearing"];
      instance.bearing = __raw_bearing;
    }
    {
      const __raw_hue = obj["hue"];
      instance.hue = __raw_hue;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as DirectionHue;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof DirectionHue>(
    field: K,
    value: DirectionHue[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<DirectionHue>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace DirectionHue {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    bearing: Option<Array<string>>;
    hue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { bearing: Option<boolean>; hue: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly bearing: FieldController<number>;
    readonly hue: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: DirectionHue;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<DirectionHue, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<DirectionHue>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<DirectionHue>,
  ): Gigaform {
    let data = $state({ ...DirectionHue.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      bearing: Option.none(),
      hue: Option.none(),
    });
    let tainted = $state<Tainted>({
      bearing: Option.none(),
      hue: Option.none(),
    });
    const fields: FieldControllers = {
      bearing: {
        path: ["bearing"] as const,
        name: "bearing",
        constraints: { required: true },

        get: () => data.bearing,
        set: (value: number) => {
          data.bearing = value;
        },
        getError: () => errors.bearing,
        setError: (value: Option<Array<string>>) => {
          errors.bearing = value;
        },
        getTainted: () => tainted.bearing,
        setTainted: (value: Option<boolean>) => {
          tainted.bearing = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = DirectionHue.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "bearing")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = DirectionHue.validateField(
            "bearing",
            data.bearing,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hue: {
        path: ["hue"] as const,
        name: "hue",
        constraints: { required: true },

        get: () => data.hue,
        set: (value: number) => {
          data.hue = value;
        },
        getError: () => errors.hue,
        setError: (value: Option<Array<string>>) => {
          errors.hue = value;
        },
        getTainted: () => tainted.hue,
        setTainted: (value: Option<boolean>) => {
          tainted.hue = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = DirectionHue.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hue")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = DirectionHue.validateField("hue", data.hue);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      DirectionHue,
      Array<{ field: string; message: string }>
    > {
      return DirectionHue.fromObject(data);
    }
    function reset(newOverrides?: Partial<DirectionHue>): void {
      data = { ...DirectionHue.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        bearing: Option.none(),
        hue: Option.none(),
      };
      tainted = { bearing: Option.none(), hue: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<DirectionHue, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const bearingStr = formData.get("bearing");
      obj.bearing = bearingStr ? parseFloat(bearingStr as string) : 0;
      if (obj.bearing !== undefined && isNaN(obj.bearing as number))
        obj.bearing = 0;
    }
    {
      const hueStr = formData.get("hue");
      obj.hue = hueStr ? parseFloat(hueStr as string) : 0;
      if (obj.hue !== undefined && isNaN(obj.hue as number)) obj.hue = 0;
    }
    return DirectionHue.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface MonthlyRecurrenceRule {
  quantityOfMonths: number;
  day: number;

  name: string;
}

export namespace MonthlyRecurrenceRule {
  export function defaultValue(): MonthlyRecurrenceRule {
    return { quantityOfMonths: 0, day: 0, name: "" } as MonthlyRecurrenceRule;
  }
}

export namespace MonthlyRecurrenceRule {
  export function toStringifiedJSON(self: MonthlyRecurrenceRule): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(
    self: MonthlyRecurrenceRule,
  ): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: MonthlyRecurrenceRule,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "MonthlyRecurrenceRule",
      __id,
    };
    result["quantityOfMonths"] = self.quantityOfMonths;
    result["day"] = self.day;
    result["name"] = self.name;
    return result;
  }
}

export namespace MonthlyRecurrenceRule {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<MonthlyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<MonthlyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "MonthlyRecurrenceRule.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): MonthlyRecurrenceRule | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "MonthlyRecurrenceRule.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("quantityOfMonths" in obj)) {
      errors.push({
        field: "quantityOfMonths",
        message: "missing required field",
      });
    }
    if (!("day" in obj)) {
      errors.push({ field: "day", message: "missing required field" });
    }
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_quantityOfMonths = obj["quantityOfMonths"];
      instance.quantityOfMonths = __raw_quantityOfMonths;
    }
    {
      const __raw_day = obj["day"];
      instance.day = __raw_day;
    }
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as MonthlyRecurrenceRule;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof MonthlyRecurrenceRule>(
    field: K,
    value: MonthlyRecurrenceRule[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<MonthlyRecurrenceRule>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace MonthlyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfMonths: Option<Array<string>>;
    day: Option<Array<string>>;
    name: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      quantityOfMonths: Option<boolean>;
      day: Option<boolean>;
      name: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfMonths: FieldController<number>;
    readonly day: FieldController<number>;
    readonly name: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: MonthlyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      MonthlyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<MonthlyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<MonthlyRecurrenceRule>,
  ): Gigaform {
    let data = $state({
      ...MonthlyRecurrenceRule.defaultValue(),
      ...overrides,
    });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfMonths: Option.none(),
      day: Option.none(),
      name: Option.none(),
    });
    let tainted = $state<Tainted>({
      quantityOfMonths: Option.none(),
      day: Option.none(),
      name: Option.none(),
    });
    const fields: FieldControllers = {
      quantityOfMonths: {
        path: ["quantityOfMonths"] as const,
        name: "quantityOfMonths",
        constraints: { required: true },

        get: () => data.quantityOfMonths,
        set: (value: number) => {
          data.quantityOfMonths = value;
        },
        getError: () => errors.quantityOfMonths,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfMonths = value;
        },
        getTainted: () => tainted.quantityOfMonths,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfMonths = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = MonthlyRecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "quantityOfMonths")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = MonthlyRecurrenceRule.validateField(
            "quantityOfMonths",
            data.quantityOfMonths,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      day: {
        path: ["day"] as const,
        name: "day",
        constraints: { required: true },

        get: () => data.day,
        set: (value: number) => {
          data.day = value;
        },
        getError: () => errors.day,
        setError: (value: Option<Array<string>>) => {
          errors.day = value;
        },
        getTainted: () => tainted.day,
        setTainted: (value: Option<boolean>) => {
          tainted.day = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = MonthlyRecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "day")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = MonthlyRecurrenceRule.validateField(
            "day",
            data.day,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = MonthlyRecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = MonthlyRecurrenceRule.validateField(
            "name",
            data.name,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      MonthlyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return MonthlyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<MonthlyRecurrenceRule>): void {
      data = { ...MonthlyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        quantityOfMonths: Option.none(),
        day: Option.none(),
        name: Option.none(),
      };
      tainted = {
        quantityOfMonths: Option.none(),
        day: Option.none(),
        name: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<MonthlyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfMonthsStr = formData.get("quantityOfMonths");
      obj.quantityOfMonths = quantityOfMonthsStr
        ? parseFloat(quantityOfMonthsStr as string)
        : 0;
      if (
        obj.quantityOfMonths !== undefined &&
        isNaN(obj.quantityOfMonths as number)
      )
        obj.quantityOfMonths = 0;
    }
    {
      const dayStr = formData.get("day");
      obj.day = dayStr ? parseFloat(dayStr as string) : 0;
      if (obj.day !== undefined && isNaN(obj.day as number)) obj.day = 0;
    }
    obj.name = formData.get("name") ?? "";
    return MonthlyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Represents {
  in: string | Employee;

  out: string | Account;
  id: string;
  dateStarted: string;
}

export namespace Represents {
  export function defaultValue(): Represents {
    return { in: "", out: "", id: "", dateStarted: "" } as Represents;
  }
}

export namespace Represents {
  export function toStringifiedJSON(self: Represents): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Represents): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Represents,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Represents", __id };
    result["in"] = self.in;
    result["out"] = self.out;
    result["id"] = self.id;
    result["dateStarted"] = self.dateStarted;
    return result;
  }
}

export namespace Represents {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Represents, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Represents, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "Represents.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Represents | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Represents.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("in" in obj)) {
      errors.push({ field: "in", message: "missing required field" });
    }
    if (!("out" in obj)) {
      errors.push({ field: "out", message: "missing required field" });
    }
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("dateStarted" in obj)) {
      errors.push({ field: "dateStarted", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_in = obj["in"];
      instance.in = __raw_in;
    }
    {
      const __raw_out = obj["out"];
      instance.out = __raw_out;
    }
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_dateStarted = obj["dateStarted"];
      instance.dateStarted = __raw_dateStarted;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Represents;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Represents>(
    field: K,
    value: Represents[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Represents>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Represents {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    in: Option<Array<string>>;
    out: Option<Array<string>>;
    id: Option<Array<string>>;
    dateStarted: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      in: Option<boolean>;
      out: Option<boolean>;
      id: Option<boolean>;
      dateStarted: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly in: FieldController<string | Employee>;
    readonly out: FieldController<string | Account>;
    readonly id: FieldController<string>;
    readonly dateStarted: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Represents;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Represents, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Represents>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Represents>,
  ): Gigaform {
    let data = $state({ ...Represents.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      dateStarted: Option.none(),
    });
    let tainted = $state<Tainted>({
      in: Option.none(),
      out: Option.none(),
      id: Option.none(),
      dateStarted: Option.none(),
    });
    const fields: FieldControllers = {
      in: {
        path: ["in"] as const,
        name: "in",
        constraints: { required: true },

        get: () => data.in,
        set: (value: string | Employee) => {
          data.in = value;
        },
        getError: () => errors.in,
        setError: (value: Option<Array<string>>) => {
          errors.in = value;
        },
        getTainted: () => tainted.in,
        setTainted: (value: Option<boolean>) => {
          tainted.in = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Represents.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "in")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Represents.validateField("in", data.in);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      out: {
        path: ["out"] as const,
        name: "out",
        constraints: { required: true },

        get: () => data.out,
        set: (value: string | Account) => {
          data.out = value;
        },
        getError: () => errors.out,
        setError: (value: Option<Array<string>>) => {
          errors.out = value;
        },
        getTainted: () => tainted.out,
        setTainted: (value: Option<boolean>) => {
          tainted.out = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Represents.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "out")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Represents.validateField("out", data.out);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Represents.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Represents.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      dateStarted: {
        path: ["dateStarted"] as const,
        name: "dateStarted",
        constraints: { required: true },

        get: () => data.dateStarted,
        set: (value: string) => {
          data.dateStarted = value;
        },
        getError: () => errors.dateStarted,
        setError: (value: Option<Array<string>>) => {
          errors.dateStarted = value;
        },
        getTainted: () => tainted.dateStarted,
        setTainted: (value: Option<boolean>) => {
          tainted.dateStarted = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Represents.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "dateStarted")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Represents.validateField(
            "dateStarted",
            data.dateStarted,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Represents,
      Array<{ field: string; message: string }>
    > {
      return Represents.fromObject(data);
    }
    function reset(newOverrides?: Partial<Represents>): void {
      data = { ...Represents.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        dateStarted: Option.none(),
      };
      tainted = {
        in: Option.none(),
        out: Option.none(),
        id: Option.none(),
        dateStarted: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Represents, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.in = formData.get("in") ?? "";
    obj.out = formData.get("out") ?? "";
    obj.id = formData.get("id") ?? "";
    obj.dateStarted = formData.get("dateStarted") ?? "";
    return Represents.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Payment {
  id: string;
  date: string;
}

export namespace Payment {
  export function defaultValue(): Payment {
    return { id: "", date: "" } as Payment;
  }
}

export namespace Payment {
  export function toStringifiedJSON(self: Payment): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Payment): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Payment,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Payment", __id };
    result["id"] = self.id;
    result["date"] = self.date;
    return result;
  }
}

export namespace Payment {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Payment, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Payment, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Payment.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Payment | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Payment.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("date" in obj)) {
      errors.push({ field: "date", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_date = obj["date"];
      instance.date = __raw_date;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Payment;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Payment>(
    field: K,
    value: Payment[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Payment>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Payment {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { id: Option<boolean>; date: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Payment;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Payment, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Payment>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Payment>,
  ): Gigaform {
    let data = $state({ ...Payment.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({ id: Option.none(), date: Option.none() });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Payment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Payment.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },

        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Payment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "date")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Payment.validateField("date", data.date);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Payment,
      Array<{ field: string; message: string }>
    > {
      return Payment.fromObject(data);
    }
    function reset(newOverrides?: Partial<Payment>): void {
      data = { ...Payment.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        date: Option.none(),
      };
      tainted = { id: Option.none(), date: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Payment, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.date = formData.get("date") ?? "";
    return Payment.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Settings {
  appointmentNotifications: AppointmentNotifications | null;
  commissions: Commissions | null;
  scheduleSettings: ScheduleSettings;
  accountOverviewSettings: OverviewSettings;
  serviceOverviewSettings: OverviewSettings;
  appointmentOverviewSettings: OverviewSettings;
  leadOverviewSettings: OverviewSettings;
  packageOverviewSettings: OverviewSettings;
  productOverviewSettings: OverviewSettings;
  orderOverviewSettings: OverviewSettings;
  taxRateOverviewSettings: OverviewSettings;

  homePage: Page;
}

export namespace Settings {
  export function defaultValue(): Settings {
    return {
      appointmentNotifications: null,
      commissions: null,
      scheduleSettings: ScheduleSettings.defaultValue(),
      accountOverviewSettings: OverviewSettings.defaultValue(),
      serviceOverviewSettings: OverviewSettings.defaultValue(),
      appointmentOverviewSettings: OverviewSettings.defaultValue(),
      leadOverviewSettings: OverviewSettings.defaultValue(),
      packageOverviewSettings: OverviewSettings.defaultValue(),
      productOverviewSettings: OverviewSettings.defaultValue(),
      orderOverviewSettings: OverviewSettings.defaultValue(),
      taxRateOverviewSettings: OverviewSettings.defaultValue(),
      homePage: "UserHome",
    } as Settings;
  }
}

export namespace Settings {
  export function toStringifiedJSON(self: Settings): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Settings): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Settings,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Settings", __id };
    if (self.appointmentNotifications !== null) {
      result["appointmentNotifications"] =
        typeof (self.appointmentNotifications as any)?.__serialize ===
        "function"
          ? (self.appointmentNotifications as any).__serialize(ctx)
          : self.appointmentNotifications;
    } else {
      result["appointmentNotifications"] = null;
    }
    if (self.commissions !== null) {
      result["commissions"] =
        typeof (self.commissions as any)?.__serialize === "function"
          ? (self.commissions as any).__serialize(ctx)
          : self.commissions;
    } else {
      result["commissions"] = null;
    }
    result["scheduleSettings"] =
      typeof (self.scheduleSettings as any)?.__serialize === "function"
        ? (self.scheduleSettings as any).__serialize(ctx)
        : self.scheduleSettings;
    result["accountOverviewSettings"] =
      typeof (self.accountOverviewSettings as any)?.__serialize === "function"
        ? (self.accountOverviewSettings as any).__serialize(ctx)
        : self.accountOverviewSettings;
    result["serviceOverviewSettings"] =
      typeof (self.serviceOverviewSettings as any)?.__serialize === "function"
        ? (self.serviceOverviewSettings as any).__serialize(ctx)
        : self.serviceOverviewSettings;
    result["appointmentOverviewSettings"] =
      typeof (self.appointmentOverviewSettings as any)?.__serialize ===
      "function"
        ? (self.appointmentOverviewSettings as any).__serialize(ctx)
        : self.appointmentOverviewSettings;
    result["leadOverviewSettings"] =
      typeof (self.leadOverviewSettings as any)?.__serialize === "function"
        ? (self.leadOverviewSettings as any).__serialize(ctx)
        : self.leadOverviewSettings;
    result["packageOverviewSettings"] =
      typeof (self.packageOverviewSettings as any)?.__serialize === "function"
        ? (self.packageOverviewSettings as any).__serialize(ctx)
        : self.packageOverviewSettings;
    result["productOverviewSettings"] =
      typeof (self.productOverviewSettings as any)?.__serialize === "function"
        ? (self.productOverviewSettings as any).__serialize(ctx)
        : self.productOverviewSettings;
    result["orderOverviewSettings"] =
      typeof (self.orderOverviewSettings as any)?.__serialize === "function"
        ? (self.orderOverviewSettings as any).__serialize(ctx)
        : self.orderOverviewSettings;
    result["taxRateOverviewSettings"] =
      typeof (self.taxRateOverviewSettings as any)?.__serialize === "function"
        ? (self.taxRateOverviewSettings as any).__serialize(ctx)
        : self.taxRateOverviewSettings;
    result["homePage"] =
      typeof (self.homePage as any)?.__serialize === "function"
        ? (self.homePage as any).__serialize(ctx)
        : self.homePage;
    return result;
  }
}

export namespace Settings {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Settings, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Settings, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Settings.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Settings | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Settings.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("appointmentNotifications" in obj)) {
      errors.push({
        field: "appointmentNotifications",
        message: "missing required field",
      });
    }
    if (!("commissions" in obj)) {
      errors.push({ field: "commissions", message: "missing required field" });
    }
    if (!("scheduleSettings" in obj)) {
      errors.push({
        field: "scheduleSettings",
        message: "missing required field",
      });
    }
    if (!("accountOverviewSettings" in obj)) {
      errors.push({
        field: "accountOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("serviceOverviewSettings" in obj)) {
      errors.push({
        field: "serviceOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("appointmentOverviewSettings" in obj)) {
      errors.push({
        field: "appointmentOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("leadOverviewSettings" in obj)) {
      errors.push({
        field: "leadOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("packageOverviewSettings" in obj)) {
      errors.push({
        field: "packageOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("productOverviewSettings" in obj)) {
      errors.push({
        field: "productOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("orderOverviewSettings" in obj)) {
      errors.push({
        field: "orderOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("taxRateOverviewSettings" in obj)) {
      errors.push({
        field: "taxRateOverviewSettings",
        message: "missing required field",
      });
    }
    if (!("homePage" in obj)) {
      errors.push({ field: "homePage", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_appointmentNotifications = obj["appointmentNotifications"];
      instance.appointmentNotifications = __raw_appointmentNotifications;
    }
    {
      const __raw_commissions = obj["commissions"];
      instance.commissions = __raw_commissions;
    }
    {
      const __raw_scheduleSettings = obj["scheduleSettings"];
      if (typeof (ScheduleSettings as any)?.__deserialize === "function") {
        const __result = (ScheduleSettings as any).__deserialize(
          __raw_scheduleSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "scheduleSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.scheduleSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.scheduleSettings = v;
          });
        } else {
          instance.scheduleSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.scheduleSettings = __raw_scheduleSettings;
      }
    }
    {
      const __raw_accountOverviewSettings = obj["accountOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_accountOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "accountOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.accountOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.accountOverviewSettings = v;
          });
        } else {
          instance.accountOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.accountOverviewSettings = __raw_accountOverviewSettings;
      }
    }
    {
      const __raw_serviceOverviewSettings = obj["serviceOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_serviceOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "serviceOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.serviceOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.serviceOverviewSettings = v;
          });
        } else {
          instance.serviceOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.serviceOverviewSettings = __raw_serviceOverviewSettings;
      }
    }
    {
      const __raw_appointmentOverviewSettings =
        obj["appointmentOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_appointmentOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "appointmentOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.appointmentOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.appointmentOverviewSettings = v;
          });
        } else {
          instance.appointmentOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.appointmentOverviewSettings =
          __raw_appointmentOverviewSettings;
      }
    }
    {
      const __raw_leadOverviewSettings = obj["leadOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_leadOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "leadOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.leadOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.leadOverviewSettings = v;
          });
        } else {
          instance.leadOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.leadOverviewSettings = __raw_leadOverviewSettings;
      }
    }
    {
      const __raw_packageOverviewSettings = obj["packageOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_packageOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "packageOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.packageOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.packageOverviewSettings = v;
          });
        } else {
          instance.packageOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.packageOverviewSettings = __raw_packageOverviewSettings;
      }
    }
    {
      const __raw_productOverviewSettings = obj["productOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_productOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "productOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.productOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.productOverviewSettings = v;
          });
        } else {
          instance.productOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.productOverviewSettings = __raw_productOverviewSettings;
      }
    }
    {
      const __raw_orderOverviewSettings = obj["orderOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_orderOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "orderOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.orderOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.orderOverviewSettings = v;
          });
        } else {
          instance.orderOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.orderOverviewSettings = __raw_orderOverviewSettings;
      }
    }
    {
      const __raw_taxRateOverviewSettings = obj["taxRateOverviewSettings"];
      if (typeof (OverviewSettings as any)?.__deserialize === "function") {
        const __result = (OverviewSettings as any).__deserialize(
          __raw_taxRateOverviewSettings,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "taxRateOverviewSettings", __result);
=======
        if (PendingRef.is(__result)) {
          instance.taxRateOverviewSettings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.taxRateOverviewSettings = v;
          });
        } else {
          instance.taxRateOverviewSettings = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.taxRateOverviewSettings = __raw_taxRateOverviewSettings;
      }
    }
    {
      const __raw_homePage = obj["homePage"];
      if (typeof (Page as any)?.__deserialize === "function") {
        const __result = (Page as any).__deserialize(__raw_homePage, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "homePage", __result);
=======
        if (PendingRef.is(__result)) {
          instance.homePage = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.homePage = v;
          });
        } else {
          instance.homePage = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.homePage = __raw_homePage;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Settings;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Settings>(
    field: K,
    value: Settings[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Settings>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Settings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    appointmentNotifications: Option<Array<string>>;
    commissions: Option<Array<string>>;
    scheduleSettings: Option<Array<string>>;
    accountOverviewSettings: Option<Array<string>>;
    serviceOverviewSettings: Option<Array<string>>;
    appointmentOverviewSettings: Option<Array<string>>;
    leadOverviewSettings: Option<Array<string>>;
    packageOverviewSettings: Option<Array<string>>;
    productOverviewSettings: Option<Array<string>>;
    orderOverviewSettings: Option<Array<string>>;
    taxRateOverviewSettings: Option<Array<string>>;
    homePage: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      appointmentNotifications: Option<boolean>;
      commissions: Option<boolean>;
      scheduleSettings: Option<boolean>;
      accountOverviewSettings: Option<boolean>;
      serviceOverviewSettings: Option<boolean>;
      appointmentOverviewSettings: Option<boolean>;
      leadOverviewSettings: Option<boolean>;
      packageOverviewSettings: Option<boolean>;
      productOverviewSettings: Option<boolean>;
      orderOverviewSettings: Option<boolean>;
      taxRateOverviewSettings: Option<boolean>;
      homePage: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly appointmentNotifications: FieldController<AppointmentNotifications | null>;
    readonly commissions: FieldController<Commissions | null>;
    readonly scheduleSettings: FieldController<ScheduleSettings>;
    readonly accountOverviewSettings: FieldController<OverviewSettings>;
    readonly serviceOverviewSettings: FieldController<OverviewSettings>;
    readonly appointmentOverviewSettings: FieldController<OverviewSettings>;
    readonly leadOverviewSettings: FieldController<OverviewSettings>;
    readonly packageOverviewSettings: FieldController<OverviewSettings>;
    readonly productOverviewSettings: FieldController<OverviewSettings>;
    readonly orderOverviewSettings: FieldController<OverviewSettings>;
    readonly taxRateOverviewSettings: FieldController<OverviewSettings>;
    readonly homePage: FieldController<Page>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Settings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Settings, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Settings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Settings>,
  ): Gigaform {
    let data = $state({ ...Settings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      appointmentNotifications: Option.none(),
      commissions: Option.none(),
      scheduleSettings: Option.none(),
      accountOverviewSettings: Option.none(),
      serviceOverviewSettings: Option.none(),
      appointmentOverviewSettings: Option.none(),
      leadOverviewSettings: Option.none(),
      packageOverviewSettings: Option.none(),
      productOverviewSettings: Option.none(),
      orderOverviewSettings: Option.none(),
      taxRateOverviewSettings: Option.none(),
      homePage: Option.none(),
    });
    let tainted = $state<Tainted>({
      appointmentNotifications: Option.none(),
      commissions: Option.none(),
      scheduleSettings: Option.none(),
      accountOverviewSettings: Option.none(),
      serviceOverviewSettings: Option.none(),
      appointmentOverviewSettings: Option.none(),
      leadOverviewSettings: Option.none(),
      packageOverviewSettings: Option.none(),
      productOverviewSettings: Option.none(),
      orderOverviewSettings: Option.none(),
      taxRateOverviewSettings: Option.none(),
      homePage: Option.none(),
    });
    const fields: FieldControllers = {
      appointmentNotifications: {
        path: ["appointmentNotifications"] as const,
        name: "appointmentNotifications",
        constraints: { required: true },

        get: () => data.appointmentNotifications,
        set: (value: AppointmentNotifications | null) => {
          data.appointmentNotifications = value;
        },
        getError: () => errors.appointmentNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.appointmentNotifications = value;
        },
        getTainted: () => tainted.appointmentNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.appointmentNotifications = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "appointmentNotifications")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "appointmentNotifications",
            data.appointmentNotifications,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      commissions: {
        path: ["commissions"] as const,
        name: "commissions",
        constraints: { required: true },

        get: () => data.commissions,
        set: (value: Commissions | null) => {
          data.commissions = value;
        },
        getError: () => errors.commissions,
        setError: (value: Option<Array<string>>) => {
          errors.commissions = value;
        },
        getTainted: () => tainted.commissions,
        setTainted: (value: Option<boolean>) => {
          tainted.commissions = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "commissions")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "commissions",
            data.commissions,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      scheduleSettings: {
        path: ["scheduleSettings"] as const,
        name: "scheduleSettings",
        constraints: { required: true },

        get: () => data.scheduleSettings,
        set: (value: ScheduleSettings) => {
          data.scheduleSettings = value;
        },
        getError: () => errors.scheduleSettings,
        setError: (value: Option<Array<string>>) => {
          errors.scheduleSettings = value;
        },
        getTainted: () => tainted.scheduleSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.scheduleSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "scheduleSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "scheduleSettings",
            data.scheduleSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      accountOverviewSettings: {
        path: ["accountOverviewSettings"] as const,
        name: "accountOverviewSettings",
        constraints: { required: true },

        get: () => data.accountOverviewSettings,
        set: (value: OverviewSettings) => {
          data.accountOverviewSettings = value;
        },
        getError: () => errors.accountOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.accountOverviewSettings = value;
        },
        getTainted: () => tainted.accountOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.accountOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "accountOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "accountOverviewSettings",
            data.accountOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      serviceOverviewSettings: {
        path: ["serviceOverviewSettings"] as const,
        name: "serviceOverviewSettings",
        constraints: { required: true },

        get: () => data.serviceOverviewSettings,
        set: (value: OverviewSettings) => {
          data.serviceOverviewSettings = value;
        },
        getError: () => errors.serviceOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.serviceOverviewSettings = value;
        },
        getTainted: () => tainted.serviceOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.serviceOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "serviceOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "serviceOverviewSettings",
            data.serviceOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      appointmentOverviewSettings: {
        path: ["appointmentOverviewSettings"] as const,
        name: "appointmentOverviewSettings",
        constraints: { required: true },

        get: () => data.appointmentOverviewSettings,
        set: (value: OverviewSettings) => {
          data.appointmentOverviewSettings = value;
        },
        getError: () => errors.appointmentOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.appointmentOverviewSettings = value;
        },
        getTainted: () => tainted.appointmentOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.appointmentOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "appointmentOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "appointmentOverviewSettings",
            data.appointmentOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      leadOverviewSettings: {
        path: ["leadOverviewSettings"] as const,
        name: "leadOverviewSettings",
        constraints: { required: true },

        get: () => data.leadOverviewSettings,
        set: (value: OverviewSettings) => {
          data.leadOverviewSettings = value;
        },
        getError: () => errors.leadOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.leadOverviewSettings = value;
        },
        getTainted: () => tainted.leadOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.leadOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "leadOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "leadOverviewSettings",
            data.leadOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      packageOverviewSettings: {
        path: ["packageOverviewSettings"] as const,
        name: "packageOverviewSettings",
        constraints: { required: true },

        get: () => data.packageOverviewSettings,
        set: (value: OverviewSettings) => {
          data.packageOverviewSettings = value;
        },
        getError: () => errors.packageOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.packageOverviewSettings = value;
        },
        getTainted: () => tainted.packageOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.packageOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "packageOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "packageOverviewSettings",
            data.packageOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      productOverviewSettings: {
        path: ["productOverviewSettings"] as const,
        name: "productOverviewSettings",
        constraints: { required: true },

        get: () => data.productOverviewSettings,
        set: (value: OverviewSettings) => {
          data.productOverviewSettings = value;
        },
        getError: () => errors.productOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.productOverviewSettings = value;
        },
        getTainted: () => tainted.productOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.productOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "productOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "productOverviewSettings",
            data.productOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      orderOverviewSettings: {
        path: ["orderOverviewSettings"] as const,
        name: "orderOverviewSettings",
        constraints: { required: true },

        get: () => data.orderOverviewSettings,
        set: (value: OverviewSettings) => {
          data.orderOverviewSettings = value;
        },
        getError: () => errors.orderOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.orderOverviewSettings = value;
        },
        getTainted: () => tainted.orderOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.orderOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "orderOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "orderOverviewSettings",
            data.orderOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      taxRateOverviewSettings: {
        path: ["taxRateOverviewSettings"] as const,
        name: "taxRateOverviewSettings",
        constraints: { required: true },

        get: () => data.taxRateOverviewSettings,
        set: (value: OverviewSettings) => {
          data.taxRateOverviewSettings = value;
        },
        getError: () => errors.taxRateOverviewSettings,
        setError: (value: Option<Array<string>>) => {
          errors.taxRateOverviewSettings = value;
        },
        getTainted: () => tainted.taxRateOverviewSettings,
        setTainted: (value: Option<boolean>) => {
          tainted.taxRateOverviewSettings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "taxRateOverviewSettings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField(
            "taxRateOverviewSettings",
            data.taxRateOverviewSettings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      homePage: {
        path: ["homePage"] as const,
        name: "homePage",
        constraints: { required: true },

        get: () => data.homePage,
        set: (value: Page) => {
          data.homePage = value;
        },
        getError: () => errors.homePage,
        setError: (value: Option<Array<string>>) => {
          errors.homePage = value;
        },
        getTainted: () => tainted.homePage,
        setTainted: (value: Option<boolean>) => {
          tainted.homePage = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Settings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "homePage")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Settings.validateField("homePage", data.homePage);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Settings,
      Array<{ field: string; message: string }>
    > {
      return Settings.fromObject(data);
    }
    function reset(newOverrides?: Partial<Settings>): void {
      data = { ...Settings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        appointmentNotifications: Option.none(),
        commissions: Option.none(),
        scheduleSettings: Option.none(),
        accountOverviewSettings: Option.none(),
        serviceOverviewSettings: Option.none(),
        appointmentOverviewSettings: Option.none(),
        leadOverviewSettings: Option.none(),
        packageOverviewSettings: Option.none(),
        productOverviewSettings: Option.none(),
        orderOverviewSettings: Option.none(),
        taxRateOverviewSettings: Option.none(),
        homePage: Option.none(),
      };
      tainted = {
        appointmentNotifications: Option.none(),
        commissions: Option.none(),
        scheduleSettings: Option.none(),
        accountOverviewSettings: Option.none(),
        serviceOverviewSettings: Option.none(),
        appointmentOverviewSettings: Option.none(),
        leadOverviewSettings: Option.none(),
        packageOverviewSettings: Option.none(),
        productOverviewSettings: Option.none(),
        orderOverviewSettings: Option.none(),
        taxRateOverviewSettings: Option.none(),
        homePage: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Settings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.appointmentNotifications =
      formData.get("appointmentNotifications") ?? "";
    obj.commissions = formData.get("commissions") ?? "";
    {
      // Collect nested object fields with prefix "scheduleSettings."
      const scheduleSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("scheduleSettings.")) {
          const fieldName = key.slice("scheduleSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = scheduleSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.scheduleSettings = scheduleSettingsObj;
    }
    {
      // Collect nested object fields with prefix "accountOverviewSettings."
      const accountOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("accountOverviewSettings.")) {
          const fieldName = key.slice("accountOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = accountOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.accountOverviewSettings = accountOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "serviceOverviewSettings."
      const serviceOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("serviceOverviewSettings.")) {
          const fieldName = key.slice("serviceOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = serviceOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.serviceOverviewSettings = serviceOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "appointmentOverviewSettings."
      const appointmentOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("appointmentOverviewSettings.")) {
          const fieldName = key.slice("appointmentOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = appointmentOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.appointmentOverviewSettings = appointmentOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "leadOverviewSettings."
      const leadOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("leadOverviewSettings.")) {
          const fieldName = key.slice("leadOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = leadOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.leadOverviewSettings = leadOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "packageOverviewSettings."
      const packageOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("packageOverviewSettings.")) {
          const fieldName = key.slice("packageOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = packageOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.packageOverviewSettings = packageOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "productOverviewSettings."
      const productOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("productOverviewSettings.")) {
          const fieldName = key.slice("productOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = productOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.productOverviewSettings = productOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "orderOverviewSettings."
      const orderOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("orderOverviewSettings.")) {
          const fieldName = key.slice("orderOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = orderOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.orderOverviewSettings = orderOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "taxRateOverviewSettings."
      const taxRateOverviewSettingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("taxRateOverviewSettings.")) {
          const fieldName = key.slice("taxRateOverviewSettings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = taxRateOverviewSettingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.taxRateOverviewSettings = taxRateOverviewSettingsObj;
    }
    {
      // Collect nested object fields with prefix "homePage."
      const homePageObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("homePage.")) {
          const fieldName = key.slice("homePage.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = homePageObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.homePage = homePageObj;
    }
    return Settings.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Color {
  red: number;
  green: number;
  blue: number;
}

export namespace Color {
  export function defaultValue(): Color {
    return { red: 0, green: 0, blue: 0 } as Color;
  }
}

export namespace Color {
  export function toStringifiedJSON(self: Color): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Color): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Color,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Color", __id };
    result["red"] = self.red;
    result["green"] = self.green;
    result["blue"] = self.blue;
    return result;
  }
}

export namespace Color {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Color, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Color, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Color.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Color | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Color.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("red" in obj)) {
      errors.push({ field: "red", message: "missing required field" });
    }
    if (!("green" in obj)) {
      errors.push({ field: "green", message: "missing required field" });
    }
    if (!("blue" in obj)) {
      errors.push({ field: "blue", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_red = obj["red"];
      instance.red = __raw_red;
    }
    {
      const __raw_green = obj["green"];
      instance.green = __raw_green;
    }
    {
      const __raw_blue = obj["blue"];
      instance.blue = __raw_blue;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Color;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Color>(
    field: K,
    value: Color[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Color>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Color {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    red: Option<Array<string>>;
    green: Option<Array<string>>;
    blue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { red: Option<boolean>; green: Option<boolean>; blue: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly red: FieldController<number>;
    readonly green: FieldController<number>;
    readonly blue: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Color;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Color, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Color>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Color>,
  ): Gigaform {
    let data = $state({ ...Color.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      red: Option.none(),
      green: Option.none(),
      blue: Option.none(),
    });
    let tainted = $state<Tainted>({
      red: Option.none(),
      green: Option.none(),
      blue: Option.none(),
    });
    const fields: FieldControllers = {
      red: {
        path: ["red"] as const,
        name: "red",
        constraints: { required: true },

        get: () => data.red,
        set: (value: number) => {
          data.red = value;
        },
        getError: () => errors.red,
        setError: (value: Option<Array<string>>) => {
          errors.red = value;
        },
        getTainted: () => tainted.red,
        setTainted: (value: Option<boolean>) => {
          tainted.red = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Color.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "red")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Color.validateField("red", data.red);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      green: {
        path: ["green"] as const,
        name: "green",
        constraints: { required: true },

        get: () => data.green,
        set: (value: number) => {
          data.green = value;
        },
        getError: () => errors.green,
        setError: (value: Option<Array<string>>) => {
          errors.green = value;
        },
        getTainted: () => tainted.green,
        setTainted: (value: Option<boolean>) => {
          tainted.green = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Color.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "green")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Color.validateField("green", data.green);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      blue: {
        path: ["blue"] as const,
        name: "blue",
        constraints: { required: true },

        get: () => data.blue,
        set: (value: number) => {
          data.blue = value;
        },
        getError: () => errors.blue,
        setError: (value: Option<Array<string>>) => {
          errors.blue = value;
        },
        getTainted: () => tainted.blue,
        setTainted: (value: Option<boolean>) => {
          tainted.blue = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Color.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "blue")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Color.validateField("blue", data.blue);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Color,
      Array<{ field: string; message: string }>
    > {
      return Color.fromObject(data);
    }
    function reset(newOverrides?: Partial<Color>): void {
      data = { ...Color.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        red: Option.none(),
        green: Option.none(),
        blue: Option.none(),
      };
      tainted = {
        red: Option.none(),
        green: Option.none(),
        blue: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Color, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const redStr = formData.get("red");
      obj.red = redStr ? parseFloat(redStr as string) : 0;
      if (obj.red !== undefined && isNaN(obj.red as number)) obj.red = 0;
    }
    {
      const greenStr = formData.get("green");
      obj.green = greenStr ? parseFloat(greenStr as string) : 0;
      if (obj.green !== undefined && isNaN(obj.green as number)) obj.green = 0;
    }
    {
      const blueStr = formData.get("blue");
      obj.blue = blueStr ? parseFloat(blueStr as string) : 0;
      if (obj.blue !== undefined && isNaN(obj.blue as number)) obj.blue = 0;
    }
    return Color.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface CompanyName {
  companyName: string;
}

export namespace CompanyName {
  export function defaultValue(): CompanyName {
    return { companyName: "" } as CompanyName;
  }
}

export namespace CompanyName {
  export function toStringifiedJSON(self: CompanyName): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: CompanyName): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: CompanyName,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "CompanyName", __id };
    result["companyName"] = self.companyName;
    return result;
  }
}

export namespace CompanyName {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<CompanyName, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<CompanyName, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "CompanyName.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): CompanyName | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "CompanyName.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("companyName" in obj)) {
      errors.push({ field: "companyName", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_companyName = obj["companyName"];
      instance.companyName = __raw_companyName;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as CompanyName;
  }
<<<<<<< Updated upstream
}

export namespace CompanyName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    companyName: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { companyName: Option<boolean> };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly companyName: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: CompanyName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<CompanyName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<CompanyName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<CompanyName>,
  ): Gigaform {
    let data = $state({ ...CompanyName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      companyName: Option.none(),
    });
    let tainted = $state<Tainted>({ companyName: Option.none() });
    const fields: FieldControllers = {
      companyName: {
        path: ["companyName"] as const,
        name: "companyName",
        constraints: { required: true },

=======
  export function validateField<K extends keyof CompanyName>(
    field: K,
    value: CompanyName[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "companyName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "companyName", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<CompanyName>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("companyName" in partial && partial.companyName !== undefined) {
      const __val = partial.companyName as string;
      if (__val.length === 0) {
        errors.push({ field: "companyName", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace CompanyName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    companyName: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { companyName: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly companyName: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: CompanyName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<CompanyName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<CompanyName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<CompanyName>,
  ): Gigaform {
    let data = $state({ ...CompanyName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      companyName: Option.none(),
    });
    let tainted = $state<Tainted>({ companyName: Option.none() });
    const fields: FieldControllers = {
      companyName: {
        path: ["companyName"] as const,
        name: "companyName",
        constraints: { required: true },
        label: "Company Name",
>>>>>>> Stashed changes
        get: () => data.companyName,
        set: (value: string) => {
          data.companyName = value;
        },
        getError: () => errors.companyName,
        setError: (value: Option<Array<string>>) => {
          errors.companyName = value;
        },
        getTainted: () => tainted.companyName,
        setTainted: (value: Option<boolean>) => {
          tainted.companyName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = CompanyName.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "companyName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = CompanyName.validateField(
            "companyName",
            data.companyName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      CompanyName,
      Array<{ field: string; message: string }>
    > {
      return CompanyName.fromObject(data);
    }
    function reset(newOverrides?: Partial<CompanyName>): void {
      data = { ...CompanyName.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), companyName: Option.none() };
      tainted = { companyName: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<CompanyName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.companyName = formData.get("companyName") ?? "";
    return CompanyName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Appointment {
  id: string;

  title: string;

  status: Status;
<<<<<<< Updated upstream
  begins: string;
  duration: number;
  timeZone: string;
  offsetMs: number;
  allDay: boolean;
  multiDay: boolean;
  employees: (string | Employee)[];

  location: string | Site;
  description: string | null;

  colors: Colors;
=======

  begins: string;

  duration: number;

  timeZone: string;

  offsetMs: number;

  allDay: boolean;

  multiDay: boolean;

  employees: (string | Employee)[];

  location: string | Site;

  description: string | null;

  colors: Colors;

>>>>>>> Stashed changes
  recurrenceRule: RecurrenceRule | null;
}

export namespace Appointment {
  export function defaultValue(): Appointment {
    return {
      id: "",
      title: "",
      status: "Scheduled",
      begins: "",
      duration: 0,
      timeZone: "",
      offsetMs: 0,
      allDay: false,
      multiDay: false,
      employees: [],
      location: "",
      description: null,
      colors: { main: "#000000", hover: "#333333", active: "#666666" },
      recurrenceRule: null,
    } as Appointment;
  }
}

export namespace Appointment {
  export function toStringifiedJSON(self: Appointment): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Appointment): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Appointment,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Appointment", __id };
    result["id"] = self.id;
    result["title"] = self.title;
    result["status"] =
      typeof (self.status as any)?.__serialize === "function"
        ? (self.status as any).__serialize(ctx)
        : self.status;
    result["begins"] = self.begins;
    result["duration"] = self.duration;
    result["timeZone"] = self.timeZone;
    result["offsetMs"] = self.offsetMs;
    result["allDay"] = self.allDay;
    result["multiDay"] = self.multiDay;
    result["employees"] = self.employees.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["location"] = self.location;
    if (self.description !== null) {
      result["description"] =
        typeof (self.description as any)?.__serialize === "function"
          ? (self.description as any).__serialize(ctx)
          : self.description;
    } else {
      result["description"] = null;
    }
    result["colors"] =
      typeof (self.colors as any)?.__serialize === "function"
        ? (self.colors as any).__serialize(ctx)
        : self.colors;
    if (self.recurrenceRule !== null) {
      result["recurrenceRule"] =
        typeof (self.recurrenceRule as any)?.__serialize === "function"
          ? (self.recurrenceRule as any).__serialize(ctx)
          : self.recurrenceRule;
    } else {
      result["recurrenceRule"] = null;
    }
    return result;
  }
}

export namespace Appointment {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Appointment, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Appointment, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "Appointment.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Appointment | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Appointment.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("title" in obj)) {
      errors.push({ field: "title", message: "missing required field" });
    }
    if (!("status" in obj)) {
      errors.push({ field: "status", message: "missing required field" });
    }
    if (!("begins" in obj)) {
      errors.push({ field: "begins", message: "missing required field" });
    }
    if (!("duration" in obj)) {
      errors.push({ field: "duration", message: "missing required field" });
    }
    if (!("timeZone" in obj)) {
      errors.push({ field: "timeZone", message: "missing required field" });
    }
    if (!("offsetMs" in obj)) {
      errors.push({ field: "offsetMs", message: "missing required field" });
    }
    if (!("allDay" in obj)) {
      errors.push({ field: "allDay", message: "missing required field" });
    }
    if (!("multiDay" in obj)) {
      errors.push({ field: "multiDay", message: "missing required field" });
    }
    if (!("employees" in obj)) {
      errors.push({ field: "employees", message: "missing required field" });
    }
    if (!("location" in obj)) {
      errors.push({ field: "location", message: "missing required field" });
    }
    if (!("description" in obj)) {
      errors.push({ field: "description", message: "missing required field" });
    }
    if (!("colors" in obj)) {
      errors.push({ field: "colors", message: "missing required field" });
    }
    if (!("recurrenceRule" in obj)) {
      errors.push({
        field: "recurrenceRule",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_title = obj["title"];
      instance.title = __raw_title;
    }
    {
      const __raw_status = obj["status"];
      if (typeof (Status as any)?.__deserialize === "function") {
        const __result = (Status as any).__deserialize(__raw_status, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "status", __result);
      } else {
        instance.status = __raw_status;
      }
    }
    {
      const __raw_begins = obj["begins"];
      instance.begins = __raw_begins;
    }
    {
      const __raw_duration = obj["duration"];
      instance.duration = __raw_duration;
    }
    {
      const __raw_timeZone = obj["timeZone"];
      instance.timeZone = __raw_timeZone;
    }
    {
      const __raw_offsetMs = obj["offsetMs"];
      instance.offsetMs = __raw_offsetMs;
    }
    {
      const __raw_allDay = obj["allDay"];
      instance.allDay = __raw_allDay;
    }
    {
      const __raw_multiDay = obj["multiDay"];
      instance.multiDay = __raw_multiDay;
    }
    {
      const __raw_employees = obj["employees"];
      instance.employees = __raw_employees;
    }
    {
      const __raw_location = obj["location"];
      instance.location = __raw_location;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    {
      const __raw_colors = obj["colors"];
      if (typeof (Colors as any)?.__deserialize === "function") {
        const __result = (Colors as any).__deserialize(__raw_colors, ctx);
        ctx.assignOrDefer(instance, "colors", __result);
      } else {
        instance.colors = __raw_colors;
      }
    }
    {
      const __raw_recurrenceRule = obj["recurrenceRule"];
      instance.recurrenceRule = __raw_recurrenceRule;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Appointment;
  }
}

export namespace Appointment {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    title: Option<Array<string>>;
    status: Option<Array<string>>;
    begins: Option<Array<string>>;
    duration: Option<Array<string>>;
    timeZone: Option<Array<string>>;
    offsetMs: Option<Array<string>>;
    allDay: Option<Array<string>>;
    multiDay: Option<Array<string>>;
    employees: Option<Array<string>>;
    location: Option<Array<string>>;
    description: Option<Array<string>>;
    colors: Option<Array<string>>;
    recurrenceRule: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      title: Option<boolean>;
      status: Option<boolean>;
      begins: Option<boolean>;
      duration: Option<boolean>;
      timeZone: Option<boolean>;
      offsetMs: Option<boolean>;
      allDay: Option<boolean>;
      multiDay: Option<boolean>;
      employees: Option<boolean>;
      location: Option<boolean>;
      description: Option<boolean>;
      colors: Option<boolean>;
      recurrenceRule: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly title: FieldController<string>;
    readonly status: FieldController<Status>;
    readonly begins: FieldController<string>;
    readonly duration: FieldController<number>;
    readonly timeZone: FieldController<string>;
    readonly offsetMs: FieldController<number>;
    readonly allDay: FieldController<boolean>;
    readonly multiDay: FieldController<boolean>;
    readonly employees: ArrayFieldController<string | Employee>;
    readonly location: FieldController<string | Site>;
    readonly description: FieldController<string | null>;
    readonly colors: FieldController<Colors>;
    readonly recurrenceRule: FieldController<RecurrenceRule | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Appointment;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Appointment, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Appointment>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Appointment>,
  ): Gigaform {
    let data = $state({ ...Appointment.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      title: Option.none(),
      status: Option.none(),
      begins: Option.none(),
      duration: Option.none(),
      timeZone: Option.none(),
      offsetMs: Option.none(),
      allDay: Option.none(),
      multiDay: Option.none(),
      employees: Option.none(),
      location: Option.none(),
      description: Option.none(),
      colors: Option.none(),
      recurrenceRule: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      title: Option.none(),
      status: Option.none(),
      begins: Option.none(),
      duration: Option.none(),
      timeZone: Option.none(),
      offsetMs: Option.none(),
      allDay: Option.none(),
      multiDay: Option.none(),
      employees: Option.none(),
      location: Option.none(),
      description: Option.none(),
      colors: Option.none(),
      recurrenceRule: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
        },
      },
      title: {
        path: ["title"] as const,
        name: "title",
        constraints: { required: true },

        get: () => data.title,
        set: (value: string) => {
          data.title = value;
        },
        getError: () => errors.title,
        setError: (value: Option<Array<string>>) => {
          errors.title = value;
        },
        getTainted: () => tainted.title,
        setTainted: (value: Option<boolean>) => {
          tainted.title = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "title")
              .map((e) => e.message);
          }
          return [];
        },
      },
      status: {
        path: ["status"] as const,
        name: "status",
        constraints: { required: true },

        get: () => data.status,
        set: (value: Status) => {
          data.status = value;
        },
        getError: () => errors.status,
        setError: (value: Option<Array<string>>) => {
          errors.status = value;
        },
        getTainted: () => tainted.status,
        setTainted: (value: Option<boolean>) => {
          tainted.status = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "status")
              .map((e) => e.message);
          }
          return [];
        },
      },
      begins: {
        path: ["begins"] as const,
        name: "begins",
        constraints: { required: true },

        get: () => data.begins,
        set: (value: string) => {
          data.begins = value;
        },
        getError: () => errors.begins,
        setError: (value: Option<Array<string>>) => {
          errors.begins = value;
        },
        getTainted: () => tainted.begins,
        setTainted: (value: Option<boolean>) => {
          tainted.begins = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "begins")
              .map((e) => e.message);
          }
          return [];
        },
      },
      duration: {
        path: ["duration"] as const,
        name: "duration",
        constraints: { required: true },

        get: () => data.duration,
        set: (value: number) => {
          data.duration = value;
        },
        getError: () => errors.duration,
        setError: (value: Option<Array<string>>) => {
          errors.duration = value;
        },
        getTainted: () => tainted.duration,
        setTainted: (value: Option<boolean>) => {
          tainted.duration = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "duration")
              .map((e) => e.message);
          }
          return [];
        },
      },
      timeZone: {
        path: ["timeZone"] as const,
        name: "timeZone",
        constraints: { required: true },

        get: () => data.timeZone,
        set: (value: string) => {
          data.timeZone = value;
        },
        getError: () => errors.timeZone,
        setError: (value: Option<Array<string>>) => {
          errors.timeZone = value;
        },
        getTainted: () => tainted.timeZone,
        setTainted: (value: Option<boolean>) => {
          tainted.timeZone = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "timeZone")
              .map((e) => e.message);
          }
          return [];
        },
      },
      offsetMs: {
        path: ["offsetMs"] as const,
        name: "offsetMs",
        constraints: { required: true },

        get: () => data.offsetMs,
        set: (value: number) => {
          data.offsetMs = value;
        },
        getError: () => errors.offsetMs,
        setError: (value: Option<Array<string>>) => {
          errors.offsetMs = value;
        },
        getTainted: () => tainted.offsetMs,
        setTainted: (value: Option<boolean>) => {
          tainted.offsetMs = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "offsetMs")
              .map((e) => e.message);
          }
          return [];
        },
      },
      allDay: {
        path: ["allDay"] as const,
        name: "allDay",
        constraints: { required: true },

        get: () => data.allDay,
        set: (value: boolean) => {
          data.allDay = value;
        },
        getError: () => errors.allDay,
        setError: (value: Option<Array<string>>) => {
          errors.allDay = value;
        },
        getTainted: () => tainted.allDay,
        setTainted: (value: Option<boolean>) => {
          tainted.allDay = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "allDay")
              .map((e) => e.message);
          }
          return [];
        },
      },
      multiDay: {
        path: ["multiDay"] as const,
        name: "multiDay",
        constraints: { required: true },

        get: () => data.multiDay,
        set: (value: boolean) => {
          data.multiDay = value;
        },
        getError: () => errors.multiDay,
        setError: (value: Option<Array<string>>) => {
          errors.multiDay = value;
        },
        getTainted: () => tainted.multiDay,
        setTainted: (value: Option<boolean>) => {
          tainted.multiDay = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "multiDay")
              .map((e) => e.message);
          }
          return [];
        },
      },
      employees: {
        path: ["employees"] as const,
        name: "employees",
        constraints: { required: true },

        get: () => data.employees,
        set: (value: (string | Employee)[]) => {
          data.employees = value;
        },
        getError: () => errors.employees,
        setError: (value: Option<Array<string>>) => {
          errors.employees = value;
        },
        getTainted: () => tainted.employees,
        setTainted: (value: Option<boolean>) => {
          tainted.employees = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "employees")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["employees", index] as const,
          name: `employees.${index}`,
          constraints: { required: true },
          get: () => data.employees[index],
          set: (value: string | Employee) => {
            data.employees[index] = value;
          },
          getError: () => errors.employees,
          setError: (value: Option<Array<string>>) => {
            errors.employees = value;
          },
          getTainted: () => tainted.employees,
          setTainted: (value: Option<boolean>) => {
            tainted.employees = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Employee) => {
          data.employees.push(item);
        },
        remove: (index: number) => {
          data.employees.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.employees[a], data.employees[b]] = [
            data.employees[b],
            data.employees[a],
          ];
        },
      },
      location: {
        path: ["location"] as const,
        name: "location",
        constraints: { required: true },

        get: () => data.location,
        set: (value: string | Site) => {
          data.location = value;
        },
        getError: () => errors.location,
        setError: (value: Option<Array<string>>) => {
          errors.location = value;
        },
        getTainted: () => tainted.location,
        setTainted: (value: Option<boolean>) => {
          tainted.location = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "location")
              .map((e) => e.message);
          }
          return [];
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },

        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "description")
              .map((e) => e.message);
          }
          return [];
        },
      },
      colors: {
        path: ["colors"] as const,
        name: "colors",
        constraints: { required: true },

        get: () => data.colors,
        set: (value: Colors) => {
          data.colors = value;
        },
        getError: () => errors.colors,
        setError: (value: Option<Array<string>>) => {
          errors.colors = value;
        },
        getTainted: () => tainted.colors,
        setTainted: (value: Option<boolean>) => {
          tainted.colors = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "colors")
              .map((e) => e.message);
          }
          return [];
        },
      },
      recurrenceRule: {
        path: ["recurrenceRule"] as const,
        name: "recurrenceRule",
        constraints: { required: true },

        get: () => data.recurrenceRule,
        set: (value: RecurrenceRule | null) => {
          data.recurrenceRule = value;
        },
        getError: () => errors.recurrenceRule,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceRule = value;
        },
        getTainted: () => tainted.recurrenceRule,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceRule = value;
        },
        validate: (): Array<string> => {
          const result = Appointment.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "recurrenceRule")
              .map((e) => e.message);
          }
          return [];
        },
      },
    };
    function validate(): Result<
      Appointment,
      Array<{ field: string; message: string }>
    > {
      return Appointment.fromObject(data);
    }
    function reset(newOverrides?: Partial<Appointment>): void {
      data = { ...Appointment.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        title: Option.none(),
        status: Option.none(),
        begins: Option.none(),
        duration: Option.none(),
        timeZone: Option.none(),
        offsetMs: Option.none(),
        allDay: Option.none(),
        multiDay: Option.none(),
        employees: Option.none(),
        location: Option.none(),
        description: Option.none(),
        colors: Option.none(),
        recurrenceRule: Option.none(),
      };
      tainted = {
        id: Option.none(),
        title: Option.none(),
        status: Option.none(),
        begins: Option.none(),
        duration: Option.none(),
        timeZone: Option.none(),
        offsetMs: Option.none(),
        allDay: Option.none(),
        multiDay: Option.none(),
        employees: Option.none(),
        location: Option.none(),
        description: Option.none(),
        colors: Option.none(),
        recurrenceRule: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Appointment, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.title = formData.get("title") ?? "";
    {
      // Collect nested object fields with prefix "status."
      const statusObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("status.")) {
          const fieldName = key.slice("status.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = statusObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.status = statusObj;
    }
    obj.begins = formData.get("begins") ?? "";
    {
      const durationStr = formData.get("duration");
      obj.duration = durationStr ? parseFloat(durationStr as string) : 0;
      if (obj.duration !== undefined && isNaN(obj.duration as number))
        obj.duration = 0;
    }
    obj.timeZone = formData.get("timeZone") ?? "";
    {
      const offsetMsStr = formData.get("offsetMs");
      obj.offsetMs = offsetMsStr ? parseFloat(offsetMsStr as string) : 0;
      if (obj.offsetMs !== undefined && isNaN(obj.offsetMs as number))
        obj.offsetMs = 0;
    }
    {
      const allDayVal = formData.get("allDay");
      obj.allDay =
        allDayVal === "true" || allDayVal === "on" || allDayVal === "1";
    }
    {
      const multiDayVal = formData.get("multiDay");
      obj.multiDay =
        multiDayVal === "true" || multiDayVal === "on" || multiDayVal === "1";
    }
    {
      // Collect array items from indexed form fields
      const employeesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("employees." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("employees." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("employees." + idx + ".")) {
              const fieldName = key.slice(
                "employees.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          employeesItems.push(item);
        }
=======
        if (PendingRef.is(__result)) {
          instance.status = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.status = v;
          });
        } else {
          instance.status = __result;
        }
      } else {
        instance.status = __raw_status;
      }
    }
    {
      const __raw_begins = obj["begins"];
      instance.begins = __raw_begins;
    }
    {
      const __raw_duration = obj["duration"];
      instance.duration = __raw_duration;
    }
    {
      const __raw_timeZone = obj["timeZone"];
      instance.timeZone = __raw_timeZone;
    }
    {
      const __raw_offsetMs = obj["offsetMs"];
      instance.offsetMs = __raw_offsetMs;
    }
    {
      const __raw_allDay = obj["allDay"];
      instance.allDay = __raw_allDay;
    }
    {
      const __raw_multiDay = obj["multiDay"];
      instance.multiDay = __raw_multiDay;
    }
    {
      const __raw_employees = obj["employees"];
      instance.employees = __raw_employees;
    }
    {
      const __raw_location = obj["location"];
      instance.location = __raw_location;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    {
      const __raw_colors = obj["colors"];
      if (typeof (Colors as any)?.__deserialize === "function") {
        const __result = (Colors as any).__deserialize(__raw_colors, ctx);
        if (PendingRef.is(__result)) {
          instance.colors = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.colors = v;
          });
        } else {
          instance.colors = __result;
        }
      } else {
        instance.colors = __raw_colors;
      }
    }
    {
      const __raw_recurrenceRule = obj["recurrenceRule"];
      instance.recurrenceRule = __raw_recurrenceRule;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Appointment;
  }
  export function validateField<K extends keyof Appointment>(
    field: K,
    value: Appointment[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "title": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "title", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Appointment>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("title" in partial && partial.title !== undefined) {
      const __val = partial.title as string;
      if (__val.length === 0) {
        errors.push({ field: "title", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace Appointment {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    title: Option<Array<string>>;
    status: Option<Array<string>>;
    begins: Option<Array<string>>;
    duration: Option<Array<string>>;
    timeZone: Option<Array<string>>;
    offsetMs: Option<Array<string>>;
    allDay: Option<Array<string>>;
    multiDay: Option<Array<string>>;
    employees: Option<Array<string>>;
    location: Option<Array<string>>;
    description: Option<Array<string>>;
    colors: Option<Array<string>>;
    recurrenceRule: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      title: Option<boolean>;
      status: Option<boolean>;
      begins: Option<boolean>;
      duration: Option<boolean>;
      timeZone: Option<boolean>;
      offsetMs: Option<boolean>;
      allDay: Option<boolean>;
      multiDay: Option<boolean>;
      employees: Option<boolean>;
      location: Option<boolean>;
      description: Option<boolean>;
      colors: Option<boolean>;
      recurrenceRule: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly title: FieldController<string>;
    readonly status: FieldController<Status>;
    readonly begins: FieldController<string>;
    readonly duration: FieldController<number>;
    readonly timeZone: FieldController<string>;
    readonly offsetMs: FieldController<number>;
    readonly allDay: FieldController<boolean>;
    readonly multiDay: FieldController<boolean>;
    readonly employees: ArrayFieldController<string | Employee>;
    readonly location: FieldController<string | Site>;
    readonly description: FieldController<string | null>;
    readonly colors: FieldController<Colors>;
    readonly recurrenceRule: FieldController<RecurrenceRule | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Appointment;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Appointment, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Appointment>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Appointment>,
  ): Gigaform {
    let data = $state({ ...Appointment.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      title: Option.none(),
      status: Option.none(),
      begins: Option.none(),
      duration: Option.none(),
      timeZone: Option.none(),
      offsetMs: Option.none(),
      allDay: Option.none(),
      multiDay: Option.none(),
      employees: Option.none(),
      location: Option.none(),
      description: Option.none(),
      colors: Option.none(),
      recurrenceRule: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      title: Option.none(),
      status: Option.none(),
      begins: Option.none(),
      duration: Option.none(),
      timeZone: Option.none(),
      offsetMs: Option.none(),
      allDay: Option.none(),
      multiDay: Option.none(),
      employees: Option.none(),
      location: Option.none(),
      description: Option.none(),
      colors: Option.none(),
      recurrenceRule: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
        },
      },
      title: {
        path: ["title"] as const,
        name: "title",
        constraints: { required: true },
        label: "Title",
        get: () => data.title,
        set: (value: string) => {
          data.title = value;
        },
        getError: () => errors.title,
        setError: (value: Option<Array<string>>) => {
          errors.title = value;
        },
        getTainted: () => tainted.title,
        setTainted: (value: Option<boolean>) => {
          tainted.title = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("title", data.title);
          return fieldErrors.map((e) => e.message);
        },
      },
      status: {
        path: ["status"] as const,
        name: "status",
        constraints: { required: true },
        label: "Status",
        get: () => data.status,
        set: (value: Status) => {
          data.status = value;
        },
        getError: () => errors.status,
        setError: (value: Option<Array<string>>) => {
          errors.status = value;
        },
        getTainted: () => tainted.status,
        setTainted: (value: Option<boolean>) => {
          tainted.status = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("status", data.status);
          return fieldErrors.map((e) => e.message);
        },
      },
      begins: {
        path: ["begins"] as const,
        name: "begins",
        constraints: { required: true },
        label: "Begins",
        get: () => data.begins,
        set: (value: string) => {
          data.begins = value;
        },
        getError: () => errors.begins,
        setError: (value: Option<Array<string>>) => {
          errors.begins = value;
        },
        getTainted: () => tainted.begins,
        setTainted: (value: Option<boolean>) => {
          tainted.begins = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("begins", data.begins);
          return fieldErrors.map((e) => e.message);
        },
      },
      duration: {
        path: ["duration"] as const,
        name: "duration",
        constraints: { required: true },
        label: "Duration",
        get: () => data.duration,
        set: (value: number) => {
          data.duration = value;
        },
        getError: () => errors.duration,
        setError: (value: Option<Array<string>>) => {
          errors.duration = value;
        },
        getTainted: () => tainted.duration,
        setTainted: (value: Option<boolean>) => {
          tainted.duration = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "duration",
            data.duration,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      timeZone: {
        path: ["timeZone"] as const,
        name: "timeZone",
        constraints: { required: true },
        label: "Time Zone",
        get: () => data.timeZone,
        set: (value: string) => {
          data.timeZone = value;
        },
        getError: () => errors.timeZone,
        setError: (value: Option<Array<string>>) => {
          errors.timeZone = value;
        },
        getTainted: () => tainted.timeZone,
        setTainted: (value: Option<boolean>) => {
          tainted.timeZone = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "timeZone",
            data.timeZone,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      offsetMs: {
        path: ["offsetMs"] as const,
        name: "offsetMs",
        constraints: { required: true },

        get: () => data.offsetMs,
        set: (value: number) => {
          data.offsetMs = value;
        },
        getError: () => errors.offsetMs,
        setError: (value: Option<Array<string>>) => {
          errors.offsetMs = value;
        },
        getTainted: () => tainted.offsetMs,
        setTainted: (value: Option<boolean>) => {
          tainted.offsetMs = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "offsetMs",
            data.offsetMs,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      allDay: {
        path: ["allDay"] as const,
        name: "allDay",
        constraints: { required: true },
        label: "All Day",
        get: () => data.allDay,
        set: (value: boolean) => {
          data.allDay = value;
        },
        getError: () => errors.allDay,
        setError: (value: Option<Array<string>>) => {
          errors.allDay = value;
        },
        getTainted: () => tainted.allDay,
        setTainted: (value: Option<boolean>) => {
          tainted.allDay = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("allDay", data.allDay);
          return fieldErrors.map((e) => e.message);
        },
      },
      multiDay: {
        path: ["multiDay"] as const,
        name: "multiDay",
        constraints: { required: true },
        label: "Multi Day",
        get: () => data.multiDay,
        set: (value: boolean) => {
          data.multiDay = value;
        },
        getError: () => errors.multiDay,
        setError: (value: Option<Array<string>>) => {
          errors.multiDay = value;
        },
        getTainted: () => tainted.multiDay,
        setTainted: (value: Option<boolean>) => {
          tainted.multiDay = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "multiDay",
            data.multiDay,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      employees: {
        path: ["employees"] as const,
        name: "employees",
        constraints: { required: true },
        label: "Employees",
        get: () => data.employees,
        set: (value: (string | Employee)[]) => {
          data.employees = value;
        },
        getError: () => errors.employees,
        setError: (value: Option<Array<string>>) => {
          errors.employees = value;
        },
        getTainted: () => tainted.employees,
        setTainted: (value: Option<boolean>) => {
          tainted.employees = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "employees",
            data.employees,
          );
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["employees", index] as const,
          name: `employees.${index}`,
          constraints: { required: true },
          get: () => data.employees[index],
          set: (value: string | Employee) => {
            data.employees[index] = value;
          },
          getError: () => errors.employees,
          setError: (value: Option<Array<string>>) => {
            errors.employees = value;
          },
          getTainted: () => tainted.employees,
          setTainted: (value: Option<boolean>) => {
            tainted.employees = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Employee) => {
          data.employees.push(item);
        },
        remove: (index: number) => {
          data.employees.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.employees[a], data.employees[b]] = [
            data.employees[b],
            data.employees[a],
          ];
        },
      },
      location: {
        path: ["location"] as const,
        name: "location",
        constraints: { required: true },
        label: "Location",
        get: () => data.location,
        set: (value: string | Site) => {
          data.location = value;
        },
        getError: () => errors.location,
        setError: (value: Option<Array<string>>) => {
          errors.location = value;
        },
        getTainted: () => tainted.location,
        setTainted: (value: Option<boolean>) => {
          tainted.location = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "location",
            data.location,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
        label: "Description",
        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      colors: {
        path: ["colors"] as const,
        name: "colors",
        constraints: { required: true },

        get: () => data.colors,
        set: (value: Colors) => {
          data.colors = value;
        },
        getError: () => errors.colors,
        setError: (value: Option<Array<string>>) => {
          errors.colors = value;
        },
        getTainted: () => tainted.colors,
        setTainted: (value: Option<boolean>) => {
          tainted.colors = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField("colors", data.colors);
          return fieldErrors.map((e) => e.message);
        },
      },
      recurrenceRule: {
        path: ["recurrenceRule"] as const,
        name: "recurrenceRule",
        constraints: { required: true },

        get: () => data.recurrenceRule,
        set: (value: RecurrenceRule | null) => {
          data.recurrenceRule = value;
        },
        getError: () => errors.recurrenceRule,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceRule = value;
        },
        getTainted: () => tainted.recurrenceRule,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceRule = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Appointment.validateField(
            "recurrenceRule",
            data.recurrenceRule,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
    };
    function validate(): Result<
      Appointment,
      Array<{ field: string; message: string }>
    > {
      return Appointment.fromObject(data);
    }
    function reset(newOverrides?: Partial<Appointment>): void {
      data = { ...Appointment.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        title: Option.none(),
        status: Option.none(),
        begins: Option.none(),
        duration: Option.none(),
        timeZone: Option.none(),
        offsetMs: Option.none(),
        allDay: Option.none(),
        multiDay: Option.none(),
        employees: Option.none(),
        location: Option.none(),
        description: Option.none(),
        colors: Option.none(),
        recurrenceRule: Option.none(),
      };
      tainted = {
        id: Option.none(),
        title: Option.none(),
        status: Option.none(),
        begins: Option.none(),
        duration: Option.none(),
        timeZone: Option.none(),
        offsetMs: Option.none(),
        allDay: Option.none(),
        multiDay: Option.none(),
        employees: Option.none(),
        location: Option.none(),
        description: Option.none(),
        colors: Option.none(),
        recurrenceRule: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Appointment, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.title = formData.get("title") ?? "";
    {
      // Collect nested object fields with prefix "status."
      const statusObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("status.")) {
          const fieldName = key.slice("status.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = statusObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.status = statusObj;
    }
    obj.begins = formData.get("begins") ?? "";
    {
      const durationStr = formData.get("duration");
      obj.duration = durationStr ? parseFloat(durationStr as string) : 0;
      if (obj.duration !== undefined && isNaN(obj.duration as number))
        obj.duration = 0;
    }
    obj.timeZone = formData.get("timeZone") ?? "";
    {
      const offsetMsStr = formData.get("offsetMs");
      obj.offsetMs = offsetMsStr ? parseFloat(offsetMsStr as string) : 0;
      if (obj.offsetMs !== undefined && isNaN(obj.offsetMs as number))
        obj.offsetMs = 0;
    }
    {
      const allDayVal = formData.get("allDay");
      obj.allDay =
        allDayVal === "true" || allDayVal === "on" || allDayVal === "1";
    }
    {
      const multiDayVal = formData.get("multiDay");
      obj.multiDay =
        multiDayVal === "true" || multiDayVal === "on" || multiDayVal === "1";
    }
    {
      // Collect array items from indexed form fields
      const employeesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("employees." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("employees." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("employees." + idx + ".")) {
              const fieldName = key.slice(
                "employees.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          employeesItems.push(item);
        }
>>>>>>> Stashed changes
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.employees = employeesItems;
    }
    obj.location = formData.get("location") ?? "";
    obj.description = formData.get("description") ?? "";
    {
      // Collect nested object fields with prefix "colors."
      const colorsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("colors.")) {
          const fieldName = key.slice("colors.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = colorsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.colors = colorsObj;
    }
    obj.recurrenceRule = formData.get("recurrenceRule") ?? "";
    return Appointment.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Package {
  id: string;
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
  date: string;
}

export namespace Package {
  export function defaultValue(): Package {
    return { id: "", date: "" } as Package;
  }
}

export namespace Package {
  export function toStringifiedJSON(self: Package): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Package): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Package,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Package", __id };
    result["id"] = self.id;
    result["date"] = self.date;
    return result;
  }
}

export namespace Package {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Package, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Package, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Package.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Package | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Package.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("date" in obj)) {
      errors.push({ field: "date", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_date = obj["date"];
      instance.date = __raw_date;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Package;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Package>(
    field: K,
    value: Package[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Package>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Package {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { id: Option<boolean>; date: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Package;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Package, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Package>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Package>,
  ): Gigaform {
    let data = $state({ ...Package.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({ id: Option.none(), date: Option.none() });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Package.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Package.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Date",
>>>>>>> Stashed changes
        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Package.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "date")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Package.validateField("date", data.date);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Package,
      Array<{ field: string; message: string }>
    > {
      return Package.fromObject(data);
    }
    function reset(newOverrides?: Partial<Package>): void {
      data = { ...Package.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        date: Option.none(),
      };
      tainted = { id: Option.none(), date: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Package, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.date = formData.get("date") ?? "";
    return Package.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface ScheduleSettings {
  daysPerWeek: number;

  rowHeight: RowHeight;
  visibleRoutes: string[];
  detailedCards: boolean;
}

export namespace ScheduleSettings {
  export function defaultValue(): ScheduleSettings {
    return {
      daysPerWeek: 0,
      rowHeight: "Medium",
      visibleRoutes: [],
      detailedCards: false,
    } as ScheduleSettings;
  }
}

export namespace ScheduleSettings {
  export function toStringifiedJSON(self: ScheduleSettings): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: ScheduleSettings): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: ScheduleSettings,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "ScheduleSettings",
      __id,
    };
    result["daysPerWeek"] = self.daysPerWeek;
    result["rowHeight"] =
      typeof (self.rowHeight as any)?.__serialize === "function"
        ? (self.rowHeight as any).__serialize(ctx)
        : self.rowHeight;
    result["visibleRoutes"] = self.visibleRoutes.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["detailedCards"] = self.detailedCards;
    return result;
  }
}

export namespace ScheduleSettings {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<ScheduleSettings, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<ScheduleSettings, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "ScheduleSettings.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): ScheduleSettings | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "ScheduleSettings.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("daysPerWeek" in obj)) {
      errors.push({ field: "daysPerWeek", message: "missing required field" });
    }
    if (!("rowHeight" in obj)) {
      errors.push({ field: "rowHeight", message: "missing required field" });
    }
    if (!("visibleRoutes" in obj)) {
      errors.push({
        field: "visibleRoutes",
        message: "missing required field",
      });
    }
    if (!("detailedCards" in obj)) {
      errors.push({
        field: "detailedCards",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_daysPerWeek = obj["daysPerWeek"];
      instance.daysPerWeek = __raw_daysPerWeek;
    }
    {
      const __raw_rowHeight = obj["rowHeight"];
      if (typeof (RowHeight as any)?.__deserialize === "function") {
        const __result = (RowHeight as any).__deserialize(__raw_rowHeight, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "rowHeight", __result);
      } else {
        instance.rowHeight = __raw_rowHeight;
      }
    }
    {
      const __raw_visibleRoutes = obj["visibleRoutes"];
      instance.visibleRoutes = __raw_visibleRoutes;
    }
    {
      const __raw_detailedCards = obj["detailedCards"];
      instance.detailedCards = __raw_detailedCards;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as ScheduleSettings;
  }
}

export namespace ScheduleSettings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    daysPerWeek: Option<Array<string>>;
    rowHeight: Option<Array<string>>;
    visibleRoutes: Option<Array<string>>;
    detailedCards: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      daysPerWeek: Option<boolean>;
      rowHeight: Option<boolean>;
      visibleRoutes: Option<boolean>;
      detailedCards: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly daysPerWeek: FieldController<number>;
    readonly rowHeight: FieldController<RowHeight>;
    readonly visibleRoutes: ArrayFieldController<string>;
    readonly detailedCards: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ScheduleSettings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ScheduleSettings,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ScheduleSettings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ScheduleSettings>,
  ): Gigaform {
    let data = $state({ ...ScheduleSettings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      daysPerWeek: Option.none(),
      rowHeight: Option.none(),
      visibleRoutes: Option.none(),
      detailedCards: Option.none(),
    });
    let tainted = $state<Tainted>({
      daysPerWeek: Option.none(),
      rowHeight: Option.none(),
      visibleRoutes: Option.none(),
      detailedCards: Option.none(),
    });
    const fields: FieldControllers = {
      daysPerWeek: {
        path: ["daysPerWeek"] as const,
        name: "daysPerWeek",
        constraints: { required: true },

        get: () => data.daysPerWeek,
        set: (value: number) => {
          data.daysPerWeek = value;
        },
        getError: () => errors.daysPerWeek,
        setError: (value: Option<Array<string>>) => {
          errors.daysPerWeek = value;
        },
        getTainted: () => tainted.daysPerWeek,
        setTainted: (value: Option<boolean>) => {
          tainted.daysPerWeek = value;
        },
        validate: (): Array<string> => {
          const result = ScheduleSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "daysPerWeek")
              .map((e) => e.message);
          }
          return [];
        },
      },
      rowHeight: {
        path: ["rowHeight"] as const,
        name: "rowHeight",
        constraints: { required: true },

        get: () => data.rowHeight,
        set: (value: RowHeight) => {
          data.rowHeight = value;
        },
        getError: () => errors.rowHeight,
        setError: (value: Option<Array<string>>) => {
          errors.rowHeight = value;
        },
        getTainted: () => tainted.rowHeight,
        setTainted: (value: Option<boolean>) => {
          tainted.rowHeight = value;
        },
        validate: (): Array<string> => {
          const result = ScheduleSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "rowHeight")
              .map((e) => e.message);
          }
          return [];
        },
      },
      visibleRoutes: {
        path: ["visibleRoutes"] as const,
        name: "visibleRoutes",
        constraints: { required: true },

        get: () => data.visibleRoutes,
        set: (value: string[]) => {
          data.visibleRoutes = value;
        },
        getError: () => errors.visibleRoutes,
        setError: (value: Option<Array<string>>) => {
          errors.visibleRoutes = value;
        },
        getTainted: () => tainted.visibleRoutes,
        setTainted: (value: Option<boolean>) => {
          tainted.visibleRoutes = value;
        },
        validate: (): Array<string> => {
          const result = ScheduleSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "visibleRoutes")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["visibleRoutes", index] as const,
          name: `visibleRoutes.${index}`,
          constraints: { required: true },
          get: () => data.visibleRoutes[index],
          set: (value: string) => {
            data.visibleRoutes[index] = value;
          },
          getError: () => errors.visibleRoutes,
          setError: (value: Option<Array<string>>) => {
            errors.visibleRoutes = value;
          },
          getTainted: () => tainted.visibleRoutes,
          setTainted: (value: Option<boolean>) => {
            tainted.visibleRoutes = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.visibleRoutes.push(item);
        },
        remove: (index: number) => {
          data.visibleRoutes.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.visibleRoutes[a], data.visibleRoutes[b]] = [
            data.visibleRoutes[b],
            data.visibleRoutes[a],
          ];
        },
      },
      detailedCards: {
        path: ["detailedCards"] as const,
        name: "detailedCards",
        constraints: { required: true },

        get: () => data.detailedCards,
        set: (value: boolean) => {
          data.detailedCards = value;
        },
        getError: () => errors.detailedCards,
        setError: (value: Option<Array<string>>) => {
          errors.detailedCards = value;
        },
        getTainted: () => tainted.detailedCards,
        setTainted: (value: Option<boolean>) => {
          tainted.detailedCards = value;
        },
        validate: (): Array<string> => {
          const result = ScheduleSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "detailedCards")
              .map((e) => e.message);
          }
          return [];
        },
      },
    };
    function validate(): Result<
      ScheduleSettings,
      Array<{ field: string; message: string }>
    > {
      return ScheduleSettings.fromObject(data);
    }
    function reset(newOverrides?: Partial<ScheduleSettings>): void {
      data = { ...ScheduleSettings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        daysPerWeek: Option.none(),
        rowHeight: Option.none(),
        visibleRoutes: Option.none(),
        detailedCards: Option.none(),
      };
      tainted = {
        daysPerWeek: Option.none(),
        rowHeight: Option.none(),
        visibleRoutes: Option.none(),
        detailedCards: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ScheduleSettings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const daysPerWeekStr = formData.get("daysPerWeek");
      obj.daysPerWeek = daysPerWeekStr
        ? parseFloat(daysPerWeekStr as string)
        : 0;
      if (obj.daysPerWeek !== undefined && isNaN(obj.daysPerWeek as number))
        obj.daysPerWeek = 0;
    }
    {
      // Collect nested object fields with prefix "rowHeight."
      const rowHeightObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("rowHeight.")) {
          const fieldName = key.slice("rowHeight.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = rowHeightObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.rowHeight = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.rowHeight = v;
          });
        } else {
          instance.rowHeight = __result;
        }
      } else {
        instance.rowHeight = __raw_rowHeight;
      }
    }
    {
      const __raw_visibleRoutes = obj["visibleRoutes"];
      instance.visibleRoutes = __raw_visibleRoutes;
    }
    {
      const __raw_detailedCards = obj["detailedCards"];
      instance.detailedCards = __raw_detailedCards;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as ScheduleSettings;
  }
  export function validateField<K extends keyof ScheduleSettings>(
    field: K,
    value: ScheduleSettings[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<ScheduleSettings>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace ScheduleSettings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    daysPerWeek: Option<Array<string>>;
    rowHeight: Option<Array<string>>;
    visibleRoutes: Option<Array<string>>;
    detailedCards: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      daysPerWeek: Option<boolean>;
      rowHeight: Option<boolean>;
      visibleRoutes: Option<boolean>;
      detailedCards: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly daysPerWeek: FieldController<number>;
    readonly rowHeight: FieldController<RowHeight>;
    readonly visibleRoutes: ArrayFieldController<string>;
    readonly detailedCards: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ScheduleSettings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ScheduleSettings,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ScheduleSettings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ScheduleSettings>,
  ): Gigaform {
    let data = $state({ ...ScheduleSettings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      daysPerWeek: Option.none(),
      rowHeight: Option.none(),
      visibleRoutes: Option.none(),
      detailedCards: Option.none(),
    });
    let tainted = $state<Tainted>({
      daysPerWeek: Option.none(),
      rowHeight: Option.none(),
      visibleRoutes: Option.none(),
      detailedCards: Option.none(),
    });
    const fields: FieldControllers = {
      daysPerWeek: {
        path: ["daysPerWeek"] as const,
        name: "daysPerWeek",
        constraints: { required: true },

        get: () => data.daysPerWeek,
        set: (value: number) => {
          data.daysPerWeek = value;
        },
        getError: () => errors.daysPerWeek,
        setError: (value: Option<Array<string>>) => {
          errors.daysPerWeek = value;
        },
        getTainted: () => tainted.daysPerWeek,
        setTainted: (value: Option<boolean>) => {
          tainted.daysPerWeek = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "daysPerWeek",
            data.daysPerWeek,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      rowHeight: {
        path: ["rowHeight"] as const,
        name: "rowHeight",
        constraints: { required: true },

        get: () => data.rowHeight,
        set: (value: RowHeight) => {
          data.rowHeight = value;
        },
        getError: () => errors.rowHeight,
        setError: (value: Option<Array<string>>) => {
          errors.rowHeight = value;
        },
        getTainted: () => tainted.rowHeight,
        setTainted: (value: Option<boolean>) => {
          tainted.rowHeight = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "rowHeight",
            data.rowHeight,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      visibleRoutes: {
        path: ["visibleRoutes"] as const,
        name: "visibleRoutes",
        constraints: { required: true },

        get: () => data.visibleRoutes,
        set: (value: string[]) => {
          data.visibleRoutes = value;
        },
        getError: () => errors.visibleRoutes,
        setError: (value: Option<Array<string>>) => {
          errors.visibleRoutes = value;
        },
        getTainted: () => tainted.visibleRoutes,
        setTainted: (value: Option<boolean>) => {
          tainted.visibleRoutes = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "visibleRoutes",
            data.visibleRoutes,
          );
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["visibleRoutes", index] as const,
          name: `visibleRoutes.${index}`,
          constraints: { required: true },
          get: () => data.visibleRoutes[index],
          set: (value: string) => {
            data.visibleRoutes[index] = value;
          },
          getError: () => errors.visibleRoutes,
          setError: (value: Option<Array<string>>) => {
            errors.visibleRoutes = value;
          },
          getTainted: () => tainted.visibleRoutes,
          setTainted: (value: Option<boolean>) => {
            tainted.visibleRoutes = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.visibleRoutes.push(item);
        },
        remove: (index: number) => {
          data.visibleRoutes.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.visibleRoutes[a], data.visibleRoutes[b]] = [
            data.visibleRoutes[b],
            data.visibleRoutes[a],
          ];
        },
      },
      detailedCards: {
        path: ["detailedCards"] as const,
        name: "detailedCards",
        constraints: { required: true },

        get: () => data.detailedCards,
        set: (value: boolean) => {
          data.detailedCards = value;
        },
        getError: () => errors.detailedCards,
        setError: (value: Option<Array<string>>) => {
          errors.detailedCards = value;
        },
        getTainted: () => tainted.detailedCards,
        setTainted: (value: Option<boolean>) => {
          tainted.detailedCards = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = ScheduleSettings.validateField(
            "detailedCards",
            data.detailedCards,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
    };
    function validate(): Result<
      ScheduleSettings,
      Array<{ field: string; message: string }>
    > {
      return ScheduleSettings.fromObject(data);
    }
    function reset(newOverrides?: Partial<ScheduleSettings>): void {
      data = { ...ScheduleSettings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        daysPerWeek: Option.none(),
        rowHeight: Option.none(),
        visibleRoutes: Option.none(),
        detailedCards: Option.none(),
      };
      tainted = {
        daysPerWeek: Option.none(),
        rowHeight: Option.none(),
        visibleRoutes: Option.none(),
        detailedCards: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ScheduleSettings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const daysPerWeekStr = formData.get("daysPerWeek");
      obj.daysPerWeek = daysPerWeekStr
        ? parseFloat(daysPerWeekStr as string)
        : 0;
      if (obj.daysPerWeek !== undefined && isNaN(obj.daysPerWeek as number))
        obj.daysPerWeek = 0;
    }
    {
      // Collect nested object fields with prefix "rowHeight."
      const rowHeightObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("rowHeight.")) {
          const fieldName = key.slice("rowHeight.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = rowHeightObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.rowHeight = rowHeightObj;
    }
    obj.visibleRoutes = formData.getAll("visibleRoutes") as Array<string>;
    {
      const detailedCardsVal = formData.get("detailedCards");
      obj.detailedCards =
        detailedCardsVal === "true" ||
        detailedCardsVal === "on" ||
        detailedCardsVal === "1";
    }
    return ScheduleSettings.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface DailyRecurrenceRule {
  quantityOfDays: number;
}

export namespace DailyRecurrenceRule {
  export function defaultValue(): DailyRecurrenceRule {
    return { quantityOfDays: 0 } as DailyRecurrenceRule;
  }
}

export namespace DailyRecurrenceRule {
  export function toStringifiedJSON(self: DailyRecurrenceRule): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: DailyRecurrenceRule): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: DailyRecurrenceRule,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "DailyRecurrenceRule",
      __id,
    };
    result["quantityOfDays"] = self.quantityOfDays;
    return result;
  }
}

export namespace DailyRecurrenceRule {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<DailyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<DailyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "DailyRecurrenceRule.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): DailyRecurrenceRule | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "DailyRecurrenceRule.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("quantityOfDays" in obj)) {
      errors.push({
        field: "quantityOfDays",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_quantityOfDays = obj["quantityOfDays"];
      instance.quantityOfDays = __raw_quantityOfDays;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as DailyRecurrenceRule;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof DailyRecurrenceRule>(
    field: K,
    value: DailyRecurrenceRule[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<DailyRecurrenceRule>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace DailyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfDays: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { quantityOfDays: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfDays: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: DailyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      DailyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<DailyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<DailyRecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...DailyRecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfDays: Option.none(),
    });
    let tainted = $state<Tainted>({ quantityOfDays: Option.none() });
    const fields: FieldControllers = {
      quantityOfDays: {
        path: ["quantityOfDays"] as const,
        name: "quantityOfDays",
        constraints: { required: true },

        get: () => data.quantityOfDays,
        set: (value: number) => {
          data.quantityOfDays = value;
        },
        getError: () => errors.quantityOfDays,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfDays = value;
        },
        getTainted: () => tainted.quantityOfDays,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfDays = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = DailyRecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "quantityOfDays")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = DailyRecurrenceRule.validateField(
            "quantityOfDays",
            data.quantityOfDays,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      DailyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return DailyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<DailyRecurrenceRule>): void {
      data = { ...DailyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), quantityOfDays: Option.none() };
      tainted = { quantityOfDays: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<DailyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfDaysStr = formData.get("quantityOfDays");
      obj.quantityOfDays = quantityOfDaysStr
        ? parseFloat(quantityOfDaysStr as string)
        : 0;
      if (
        obj.quantityOfDays !== undefined &&
        isNaN(obj.quantityOfDays as number)
      )
        obj.quantityOfDays = 0;
    }
    return DailyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface SignUpCredentials {
  firstName: FirstName;
  lastName: LastName;
  email: EmailParts;
  password: Password;
  rememberMe: boolean;
}

export namespace SignUpCredentials {
  export function defaultValue(): SignUpCredentials {
    return {
      firstName: FirstName.defaultValue(),
      lastName: LastName.defaultValue(),
      email: EmailParts.defaultValue(),
      password: Password.defaultValue(),
      rememberMe: false,
    } as SignUpCredentials;
  }
}

export namespace SignUpCredentials {
  export function toStringifiedJSON(self: SignUpCredentials): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: SignUpCredentials): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: SignUpCredentials,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "SignUpCredentials",
      __id,
    };
    result["firstName"] =
      typeof (self.firstName as any)?.__serialize === "function"
        ? (self.firstName as any).__serialize(ctx)
        : self.firstName;
    result["lastName"] =
      typeof (self.lastName as any)?.__serialize === "function"
        ? (self.lastName as any).__serialize(ctx)
        : self.lastName;
    result["email"] =
      typeof (self.email as any)?.__serialize === "function"
        ? (self.email as any).__serialize(ctx)
        : self.email;
    result["password"] =
      typeof (self.password as any)?.__serialize === "function"
        ? (self.password as any).__serialize(ctx)
        : self.password;
    result["rememberMe"] = self.rememberMe;
    return result;
  }
}

export namespace SignUpCredentials {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<SignUpCredentials, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<SignUpCredentials, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "SignUpCredentials.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): SignUpCredentials | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "SignUpCredentials.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("firstName" in obj)) {
      errors.push({ field: "firstName", message: "missing required field" });
    }
    if (!("lastName" in obj)) {
      errors.push({ field: "lastName", message: "missing required field" });
    }
    if (!("email" in obj)) {
      errors.push({ field: "email", message: "missing required field" });
    }
    if (!("password" in obj)) {
      errors.push({ field: "password", message: "missing required field" });
    }
    if (!("rememberMe" in obj)) {
      errors.push({ field: "rememberMe", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_firstName = obj["firstName"];
      if (typeof (FirstName as any)?.__deserialize === "function") {
        const __result = (FirstName as any).__deserialize(__raw_firstName, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "firstName", __result);
=======
        if (PendingRef.is(__result)) {
          instance.firstName = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.firstName = v;
          });
        } else {
          instance.firstName = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.firstName = __raw_firstName;
      }
    }
    {
      const __raw_lastName = obj["lastName"];
      if (typeof (LastName as any)?.__deserialize === "function") {
        const __result = (LastName as any).__deserialize(__raw_lastName, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "lastName", __result);
=======
        if (PendingRef.is(__result)) {
          instance.lastName = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.lastName = v;
          });
        } else {
          instance.lastName = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.lastName = __raw_lastName;
      }
    }
    {
      const __raw_email = obj["email"];
      if (typeof (EmailParts as any)?.__deserialize === "function") {
        const __result = (EmailParts as any).__deserialize(__raw_email, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "email", __result);
=======
        if (PendingRef.is(__result)) {
          instance.email = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.email = v;
          });
        } else {
          instance.email = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.email = __raw_email;
      }
    }
    {
      const __raw_password = obj["password"];
      if (typeof (Password as any)?.__deserialize === "function") {
        const __result = (Password as any).__deserialize(__raw_password, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "password", __result);
=======
        if (PendingRef.is(__result)) {
          instance.password = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.password = v;
          });
        } else {
          instance.password = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.password = __raw_password;
      }
    }
    {
      const __raw_rememberMe = obj["rememberMe"];
      instance.rememberMe = __raw_rememberMe;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as SignUpCredentials;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof SignUpCredentials>(
    field: K,
    value: SignUpCredentials[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<SignUpCredentials>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace SignUpCredentials {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    firstName: Option<Array<string>>;
    lastName: Option<Array<string>>;
    email: Option<Array<string>>;
    password: Option<Array<string>>;
    rememberMe: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      firstName: Option<boolean>;
      lastName: Option<boolean>;
      email: Option<boolean>;
      password: Option<boolean>;
      rememberMe: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly firstName: FieldController<FirstName>;
    readonly lastName: FieldController<LastName>;
    readonly email: FieldController<EmailParts>;
    readonly password: FieldController<Password>;
    readonly rememberMe: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: SignUpCredentials;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      SignUpCredentials,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<SignUpCredentials>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<SignUpCredentials>,
  ): Gigaform {
    let data = $state({ ...SignUpCredentials.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      firstName: Option.none(),
      lastName: Option.none(),
      email: Option.none(),
      password: Option.none(),
      rememberMe: Option.none(),
    });
    let tainted = $state<Tainted>({
      firstName: Option.none(),
      lastName: Option.none(),
      email: Option.none(),
      password: Option.none(),
      rememberMe: Option.none(),
    });
    const fields: FieldControllers = {
      firstName: {
        path: ["firstName"] as const,
        name: "firstName",
        constraints: { required: true },

        get: () => data.firstName,
        set: (value: FirstName) => {
          data.firstName = value;
        },
        getError: () => errors.firstName,
        setError: (value: Option<Array<string>>) => {
          errors.firstName = value;
        },
        getTainted: () => tainted.firstName,
        setTainted: (value: Option<boolean>) => {
          tainted.firstName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = SignUpCredentials.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "firstName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = SignUpCredentials.validateField(
            "firstName",
            data.firstName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      lastName: {
        path: ["lastName"] as const,
        name: "lastName",
        constraints: { required: true },

        get: () => data.lastName,
        set: (value: LastName) => {
          data.lastName = value;
        },
        getError: () => errors.lastName,
        setError: (value: Option<Array<string>>) => {
          errors.lastName = value;
        },
        getTainted: () => tainted.lastName,
        setTainted: (value: Option<boolean>) => {
          tainted.lastName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = SignUpCredentials.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lastName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = SignUpCredentials.validateField(
            "lastName",
            data.lastName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: EmailParts) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = SignUpCredentials.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "email")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = SignUpCredentials.validateField(
            "email",
            data.email,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      password: {
        path: ["password"] as const,
        name: "password",
        constraints: { required: true },

        get: () => data.password,
        set: (value: Password) => {
          data.password = value;
        },
        getError: () => errors.password,
        setError: (value: Option<Array<string>>) => {
          errors.password = value;
        },
        getTainted: () => tainted.password,
        setTainted: (value: Option<boolean>) => {
          tainted.password = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = SignUpCredentials.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "password")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = SignUpCredentials.validateField(
            "password",
            data.password,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      rememberMe: {
        path: ["rememberMe"] as const,
        name: "rememberMe",
        constraints: { required: true },

        get: () => data.rememberMe,
        set: (value: boolean) => {
          data.rememberMe = value;
        },
        getError: () => errors.rememberMe,
        setError: (value: Option<Array<string>>) => {
          errors.rememberMe = value;
        },
        getTainted: () => tainted.rememberMe,
        setTainted: (value: Option<boolean>) => {
          tainted.rememberMe = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = SignUpCredentials.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "rememberMe")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = SignUpCredentials.validateField(
            "rememberMe",
            data.rememberMe,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      SignUpCredentials,
      Array<{ field: string; message: string }>
    > {
      return SignUpCredentials.fromObject(data);
    }
    function reset(newOverrides?: Partial<SignUpCredentials>): void {
      data = { ...SignUpCredentials.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        firstName: Option.none(),
        lastName: Option.none(),
        email: Option.none(),
        password: Option.none(),
        rememberMe: Option.none(),
      };
      tainted = {
        firstName: Option.none(),
        lastName: Option.none(),
        email: Option.none(),
        password: Option.none(),
        rememberMe: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<SignUpCredentials, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "firstName."
      const firstNameObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("firstName.")) {
          const fieldName = key.slice("firstName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = firstNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.firstName = firstNameObj;
    }
    {
      // Collect nested object fields with prefix "lastName."
      const lastNameObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("lastName.")) {
          const fieldName = key.slice("lastName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = lastNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.lastName = lastNameObj;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.email = emailObj;
    }
    {
      // Collect nested object fields with prefix "password."
      const passwordObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("password.")) {
          const fieldName = key.slice("password.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = passwordObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.password = passwordObj;
    }
    {
      const rememberMeVal = formData.get("rememberMe");
      obj.rememberMe =
        rememberMeVal === "true" ||
        rememberMeVal === "on" ||
        rememberMeVal === "1";
    }
    return SignUpCredentials.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface OverviewSettings {
  rowHeight: RowHeight;

  cardOrRow: OverviewDisplay;
  perPage: number;
  columnConfigs: ColumnConfig[];
}

export namespace OverviewSettings {
  export function defaultValue(): OverviewSettings {
    return {
      rowHeight: "Medium",
      cardOrRow: "Table",
      perPage: 0,
      columnConfigs: [],
    } as OverviewSettings;
  }
}

export namespace OverviewSettings {
  export function toStringifiedJSON(self: OverviewSettings): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: OverviewSettings): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: OverviewSettings,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "OverviewSettings",
      __id,
    };
    result["rowHeight"] =
      typeof (self.rowHeight as any)?.__serialize === "function"
        ? (self.rowHeight as any).__serialize(ctx)
        : self.rowHeight;
    result["cardOrRow"] =
      typeof (self.cardOrRow as any)?.__serialize === "function"
        ? (self.cardOrRow as any).__serialize(ctx)
        : self.cardOrRow;
    result["perPage"] = self.perPage;
    result["columnConfigs"] = self.columnConfigs.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    return result;
  }
}

export namespace OverviewSettings {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<OverviewSettings, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<OverviewSettings, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "OverviewSettings.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): OverviewSettings | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "OverviewSettings.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("rowHeight" in obj)) {
      errors.push({ field: "rowHeight", message: "missing required field" });
    }
    if (!("cardOrRow" in obj)) {
      errors.push({ field: "cardOrRow", message: "missing required field" });
    }
    if (!("perPage" in obj)) {
      errors.push({ field: "perPage", message: "missing required field" });
    }
    if (!("columnConfigs" in obj)) {
      errors.push({
        field: "columnConfigs",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_rowHeight = obj["rowHeight"];
      if (typeof (RowHeight as any)?.__deserialize === "function") {
        const __result = (RowHeight as any).__deserialize(__raw_rowHeight, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "rowHeight", __result);
      } else {
        instance.rowHeight = __raw_rowHeight;
      }
    }
    {
      const __raw_cardOrRow = obj["cardOrRow"];
      if (typeof (OverviewDisplay as any)?.__deserialize === "function") {
        const __result = (OverviewDisplay as any).__deserialize(
          __raw_cardOrRow,
          ctx,
        );
        ctx.assignOrDefer(instance, "cardOrRow", __result);
      } else {
        instance.cardOrRow = __raw_cardOrRow;
      }
    }
    {
      const __raw_perPage = obj["perPage"];
      instance.perPage = __raw_perPage;
    }
    {
      const __raw_columnConfigs = obj["columnConfigs"];
      instance.columnConfigs = __raw_columnConfigs;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as OverviewSettings;
  }
}

export namespace OverviewSettings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    rowHeight: Option<Array<string>>;
    cardOrRow: Option<Array<string>>;
    perPage: Option<Array<string>>;
    columnConfigs: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      rowHeight: Option<boolean>;
      cardOrRow: Option<boolean>;
      perPage: Option<boolean>;
      columnConfigs: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly rowHeight: FieldController<RowHeight>;
    readonly cardOrRow: FieldController<OverviewDisplay>;
    readonly perPage: FieldController<number>;
    readonly columnConfigs: ArrayFieldController<ColumnConfig>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: OverviewSettings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      OverviewSettings,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<OverviewSettings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<OverviewSettings>,
  ): Gigaform {
    let data = $state({ ...OverviewSettings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      rowHeight: Option.none(),
      cardOrRow: Option.none(),
      perPage: Option.none(),
      columnConfigs: Option.none(),
    });
    let tainted = $state<Tainted>({
      rowHeight: Option.none(),
      cardOrRow: Option.none(),
      perPage: Option.none(),
      columnConfigs: Option.none(),
    });
    const fields: FieldControllers = {
      rowHeight: {
        path: ["rowHeight"] as const,
        name: "rowHeight",
        constraints: { required: true },

        get: () => data.rowHeight,
        set: (value: RowHeight) => {
          data.rowHeight = value;
        },
        getError: () => errors.rowHeight,
        setError: (value: Option<Array<string>>) => {
          errors.rowHeight = value;
        },
        getTainted: () => tainted.rowHeight,
        setTainted: (value: Option<boolean>) => {
          tainted.rowHeight = value;
        },
        validate: (): Array<string> => {
          const result = OverviewSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "rowHeight")
              .map((e) => e.message);
          }
          return [];
        },
      },
      cardOrRow: {
        path: ["cardOrRow"] as const,
        name: "cardOrRow",
        constraints: { required: true },

        get: () => data.cardOrRow,
        set: (value: OverviewDisplay) => {
          data.cardOrRow = value;
        },
        getError: () => errors.cardOrRow,
        setError: (value: Option<Array<string>>) => {
          errors.cardOrRow = value;
        },
        getTainted: () => tainted.cardOrRow,
        setTainted: (value: Option<boolean>) => {
          tainted.cardOrRow = value;
        },
        validate: (): Array<string> => {
          const result = OverviewSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "cardOrRow")
              .map((e) => e.message);
          }
          return [];
        },
      },
      perPage: {
        path: ["perPage"] as const,
        name: "perPage",
        constraints: { required: true },

        get: () => data.perPage,
        set: (value: number) => {
          data.perPage = value;
        },
        getError: () => errors.perPage,
        setError: (value: Option<Array<string>>) => {
          errors.perPage = value;
        },
        getTainted: () => tainted.perPage,
        setTainted: (value: Option<boolean>) => {
          tainted.perPage = value;
        },
        validate: (): Array<string> => {
          const result = OverviewSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "perPage")
              .map((e) => e.message);
          }
          return [];
        },
      },
      columnConfigs: {
        path: ["columnConfigs"] as const,
        name: "columnConfigs",
        constraints: { required: true },

        get: () => data.columnConfigs,
        set: (value: ColumnConfig[]) => {
          data.columnConfigs = value;
        },
        getError: () => errors.columnConfigs,
        setError: (value: Option<Array<string>>) => {
          errors.columnConfigs = value;
        },
        getTainted: () => tainted.columnConfigs,
        setTainted: (value: Option<boolean>) => {
          tainted.columnConfigs = value;
        },
        validate: (): Array<string> => {
          const result = OverviewSettings.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "columnConfigs")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["columnConfigs", index] as const,
          name: `columnConfigs.${index}`,
          constraints: { required: true },
          get: () => data.columnConfigs[index],
          set: (value: ColumnConfig) => {
            data.columnConfigs[index] = value;
          },
          getError: () => errors.columnConfigs,
          setError: (value: Option<Array<string>>) => {
            errors.columnConfigs = value;
          },
          getTainted: () => tainted.columnConfigs,
          setTainted: (value: Option<boolean>) => {
            tainted.columnConfigs = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: ColumnConfig) => {
          data.columnConfigs.push(item);
        },
        remove: (index: number) => {
          data.columnConfigs.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.columnConfigs[a], data.columnConfigs[b]] = [
            data.columnConfigs[b],
            data.columnConfigs[a],
          ];
        },
      },
    };
    function validate(): Result<
      OverviewSettings,
      Array<{ field: string; message: string }>
    > {
      return OverviewSettings.fromObject(data);
    }
    function reset(newOverrides?: Partial<OverviewSettings>): void {
      data = { ...OverviewSettings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        rowHeight: Option.none(),
        cardOrRow: Option.none(),
        perPage: Option.none(),
        columnConfigs: Option.none(),
      };
      tainted = {
        rowHeight: Option.none(),
        cardOrRow: Option.none(),
        perPage: Option.none(),
        columnConfigs: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<OverviewSettings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "rowHeight."
      const rowHeightObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("rowHeight.")) {
          const fieldName = key.slice("rowHeight.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = rowHeightObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.rowHeight = rowHeightObj;
    }
    {
      // Collect nested object fields with prefix "cardOrRow."
      const cardOrRowObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("cardOrRow.")) {
          const fieldName = key.slice("cardOrRow.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = cardOrRowObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.rowHeight = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.rowHeight = v;
          });
        } else {
          instance.rowHeight = __result;
        }
      } else {
        instance.rowHeight = __raw_rowHeight;
      }
    }
    {
      const __raw_cardOrRow = obj["cardOrRow"];
      if (typeof (OverviewDisplay as any)?.__deserialize === "function") {
        const __result = (OverviewDisplay as any).__deserialize(
          __raw_cardOrRow,
          ctx,
        );
        if (PendingRef.is(__result)) {
          instance.cardOrRow = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.cardOrRow = v;
          });
        } else {
          instance.cardOrRow = __result;
        }
      } else {
        instance.cardOrRow = __raw_cardOrRow;
      }
    }
    {
      const __raw_perPage = obj["perPage"];
      instance.perPage = __raw_perPage;
    }
    {
      const __raw_columnConfigs = obj["columnConfigs"];
      instance.columnConfigs = __raw_columnConfigs;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as OverviewSettings;
  }
  export function validateField<K extends keyof OverviewSettings>(
    field: K,
    value: OverviewSettings[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<OverviewSettings>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace OverviewSettings {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    rowHeight: Option<Array<string>>;
    cardOrRow: Option<Array<string>>;
    perPage: Option<Array<string>>;
    columnConfigs: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      rowHeight: Option<boolean>;
      cardOrRow: Option<boolean>;
      perPage: Option<boolean>;
      columnConfigs: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly rowHeight: FieldController<RowHeight>;
    readonly cardOrRow: FieldController<OverviewDisplay>;
    readonly perPage: FieldController<number>;
    readonly columnConfigs: ArrayFieldController<ColumnConfig>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: OverviewSettings;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      OverviewSettings,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<OverviewSettings>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<OverviewSettings>,
  ): Gigaform {
    let data = $state({ ...OverviewSettings.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      rowHeight: Option.none(),
      cardOrRow: Option.none(),
      perPage: Option.none(),
      columnConfigs: Option.none(),
    });
    let tainted = $state<Tainted>({
      rowHeight: Option.none(),
      cardOrRow: Option.none(),
      perPage: Option.none(),
      columnConfigs: Option.none(),
    });
    const fields: FieldControllers = {
      rowHeight: {
        path: ["rowHeight"] as const,
        name: "rowHeight",
        constraints: { required: true },

        get: () => data.rowHeight,
        set: (value: RowHeight) => {
          data.rowHeight = value;
        },
        getError: () => errors.rowHeight,
        setError: (value: Option<Array<string>>) => {
          errors.rowHeight = value;
        },
        getTainted: () => tainted.rowHeight,
        setTainted: (value: Option<boolean>) => {
          tainted.rowHeight = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "rowHeight",
            data.rowHeight,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      cardOrRow: {
        path: ["cardOrRow"] as const,
        name: "cardOrRow",
        constraints: { required: true },

        get: () => data.cardOrRow,
        set: (value: OverviewDisplay) => {
          data.cardOrRow = value;
        },
        getError: () => errors.cardOrRow,
        setError: (value: Option<Array<string>>) => {
          errors.cardOrRow = value;
        },
        getTainted: () => tainted.cardOrRow,
        setTainted: (value: Option<boolean>) => {
          tainted.cardOrRow = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "cardOrRow",
            data.cardOrRow,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      perPage: {
        path: ["perPage"] as const,
        name: "perPage",
        constraints: { required: true },

        get: () => data.perPage,
        set: (value: number) => {
          data.perPage = value;
        },
        getError: () => errors.perPage,
        setError: (value: Option<Array<string>>) => {
          errors.perPage = value;
        },
        getTainted: () => tainted.perPage,
        setTainted: (value: Option<boolean>) => {
          tainted.perPage = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "perPage",
            data.perPage,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      columnConfigs: {
        path: ["columnConfigs"] as const,
        name: "columnConfigs",
        constraints: { required: true },

        get: () => data.columnConfigs,
        set: (value: ColumnConfig[]) => {
          data.columnConfigs = value;
        },
        getError: () => errors.columnConfigs,
        setError: (value: Option<Array<string>>) => {
          errors.columnConfigs = value;
        },
        getTainted: () => tainted.columnConfigs,
        setTainted: (value: Option<boolean>) => {
          tainted.columnConfigs = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = OverviewSettings.validateField(
            "columnConfigs",
            data.columnConfigs,
          );
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["columnConfigs", index] as const,
          name: `columnConfigs.${index}`,
          constraints: { required: true },
          get: () => data.columnConfigs[index],
          set: (value: ColumnConfig) => {
            data.columnConfigs[index] = value;
          },
          getError: () => errors.columnConfigs,
          setError: (value: Option<Array<string>>) => {
            errors.columnConfigs = value;
          },
          getTainted: () => tainted.columnConfigs,
          setTainted: (value: Option<boolean>) => {
            tainted.columnConfigs = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: ColumnConfig) => {
          data.columnConfigs.push(item);
        },
        remove: (index: number) => {
          data.columnConfigs.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.columnConfigs[a], data.columnConfigs[b]] = [
            data.columnConfigs[b],
            data.columnConfigs[a],
          ];
        },
      },
    };
    function validate(): Result<
      OverviewSettings,
      Array<{ field: string; message: string }>
    > {
      return OverviewSettings.fromObject(data);
    }
    function reset(newOverrides?: Partial<OverviewSettings>): void {
      data = { ...OverviewSettings.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        rowHeight: Option.none(),
        cardOrRow: Option.none(),
        perPage: Option.none(),
        columnConfigs: Option.none(),
      };
      tainted = {
        rowHeight: Option.none(),
        cardOrRow: Option.none(),
        perPage: Option.none(),
        columnConfigs: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<OverviewSettings, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "rowHeight."
      const rowHeightObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("rowHeight.")) {
          const fieldName = key.slice("rowHeight.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = rowHeightObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.rowHeight = rowHeightObj;
    }
    {
      // Collect nested object fields with prefix "cardOrRow."
      const cardOrRowObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("cardOrRow.")) {
          const fieldName = key.slice("cardOrRow.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = cardOrRowObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.cardOrRow = cardOrRowObj;
    }
    {
      const perPageStr = formData.get("perPage");
      obj.perPage = perPageStr ? parseFloat(perPageStr as string) : 0;
      if (obj.perPage !== undefined && isNaN(obj.perPage as number))
        obj.perPage = 0;
    }
    {
      // Collect array items from indexed form fields
      const columnConfigsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("columnConfigs." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("columnConfigs." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("columnConfigs." + idx + ".")) {
              const fieldName = key.slice(
                "columnConfigs.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          columnConfigsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.columnConfigs = columnConfigsItems;
    }
    return OverviewSettings.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface FirstName {
  name: string;
}

export namespace FirstName {
  export function defaultValue(): FirstName {
    return { name: "" } as FirstName;
  }
}

export namespace FirstName {
  export function toStringifiedJSON(self: FirstName): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: FirstName): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: FirstName,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "FirstName", __id };
    result["name"] = self.name;
    return result;
  }
}

export namespace FirstName {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<FirstName, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<FirstName, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "FirstName.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): FirstName | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "FirstName.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as FirstName;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof FirstName>(
    field: K,
    value: FirstName[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<FirstName>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace FirstName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    name: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { name: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly name: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: FirstName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<FirstName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<FirstName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<FirstName>,
  ): Gigaform {
    let data = $state({ ...FirstName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      name: Option.none(),
    });
    let tainted = $state<Tainted>({ name: Option.none() });
    const fields: FieldControllers = {
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = FirstName.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = FirstName.validateField("name", data.name);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      FirstName,
      Array<{ field: string; message: string }>
    > {
      return FirstName.fromObject(data);
    }
    function reset(newOverrides?: Partial<FirstName>): void {
      data = { ...FirstName.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), name: Option.none() };
      tainted = { name: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<FirstName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.name = formData.get("name") ?? "";
    return FirstName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Account {
  id: string;

  taxRate: string | TaxRate;

  site: string | Site;
<<<<<<< Updated upstream
  salesRep: Represents[] | null;
  orders: Ordered[];
  activity: Did[];
  customFields: [string, string][];
  accountName: AccountName;

  sector: Sector;
  memo: string | null;
  phones: PhoneNumber[];
  email: Email;

  leadSource: string;
  colors: Colors;
  needsReview: boolean;
=======

  salesRep: Represents[] | null;

  orders: Ordered[];

  activity: Did[];

  customFields: [string, string][];

  accountName: AccountName;

  sector: Sector;

  memo: string | null;

  phones: PhoneNumber[];

  email: Email;

  leadSource: string;

  colors: Colors;

  needsReview: boolean;

>>>>>>> Stashed changes
  hasAlert: boolean;

  accountType: string;

  subtype: string;
<<<<<<< Updated upstream
  isTaxExempt: boolean;

  paymentTerms: string;
  tags: string[];
=======

  isTaxExempt: boolean;

  paymentTerms: string;

  tags: string[];

>>>>>>> Stashed changes
  dateAdded: string;
}

export namespace Account {
  export function defaultValue(): Account {
    return {
      id: "",
      taxRate: "",
      site: "",
      salesRep: null,
      orders: [],
      activity: [],
      customFields: [],
      accountName: AccountName.defaultValue(),
      sector: "Residential",
      memo: null,
      phones: [],
      email: Email.defaultValue(),
      leadSource: "",
      colors: Colors.defaultValue(),
      needsReview: false,
      hasAlert: false,
      accountType: "",
      subtype: "",
      isTaxExempt: false,
      paymentTerms: "",
      tags: [],
      dateAdded: "",
    } as Account;
  }
}

export namespace Account {
  export function toStringifiedJSON(self: Account): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Account): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Account,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Account", __id };
    result["id"] = self.id;
    result["taxRate"] = self.taxRate;
    result["site"] = self.site;
    if (self.salesRep !== null) {
      result["salesRep"] =
        typeof (self.salesRep as any)?.__serialize === "function"
          ? (self.salesRep as any).__serialize(ctx)
          : self.salesRep;
    } else {
      result["salesRep"] = null;
    }
    result["orders"] = self.orders.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["activity"] = self.activity.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["customFields"] = self.customFields.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["accountName"] =
      typeof (self.accountName as any)?.__serialize === "function"
        ? (self.accountName as any).__serialize(ctx)
        : self.accountName;
    result["sector"] =
      typeof (self.sector as any)?.__serialize === "function"
        ? (self.sector as any).__serialize(ctx)
        : self.sector;
    if (self.memo !== null) {
      result["memo"] =
        typeof (self.memo as any)?.__serialize === "function"
          ? (self.memo as any).__serialize(ctx)
          : self.memo;
    } else {
      result["memo"] = null;
    }
    result["phones"] = self.phones.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["email"] =
      typeof (self.email as any)?.__serialize === "function"
        ? (self.email as any).__serialize(ctx)
        : self.email;
    result["leadSource"] = self.leadSource;
    result["colors"] =
      typeof (self.colors as any)?.__serialize === "function"
        ? (self.colors as any).__serialize(ctx)
        : self.colors;
    result["needsReview"] = self.needsReview;
    result["hasAlert"] = self.hasAlert;
    result["accountType"] = self.accountType;
    result["subtype"] = self.subtype;
    result["isTaxExempt"] = self.isTaxExempt;
    result["paymentTerms"] = self.paymentTerms;
    result["tags"] = self.tags.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["dateAdded"] = self.dateAdded;
    return result;
  }
}

export namespace Account {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Account, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Account, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Account.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Account | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Account.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("taxRate" in obj)) {
      errors.push({ field: "taxRate", message: "missing required field" });
    }
    if (!("site" in obj)) {
      errors.push({ field: "site", message: "missing required field" });
    }
    if (!("salesRep" in obj)) {
      errors.push({ field: "salesRep", message: "missing required field" });
    }
    if (!("orders" in obj)) {
      errors.push({ field: "orders", message: "missing required field" });
    }
    if (!("activity" in obj)) {
      errors.push({ field: "activity", message: "missing required field" });
    }
    if (!("customFields" in obj)) {
      errors.push({ field: "customFields", message: "missing required field" });
    }
    if (!("accountName" in obj)) {
      errors.push({ field: "accountName", message: "missing required field" });
    }
    if (!("sector" in obj)) {
      errors.push({ field: "sector", message: "missing required field" });
    }
    if (!("memo" in obj)) {
      errors.push({ field: "memo", message: "missing required field" });
    }
    if (!("phones" in obj)) {
      errors.push({ field: "phones", message: "missing required field" });
    }
    if (!("email" in obj)) {
      errors.push({ field: "email", message: "missing required field" });
    }
    if (!("leadSource" in obj)) {
      errors.push({ field: "leadSource", message: "missing required field" });
    }
    if (!("colors" in obj)) {
      errors.push({ field: "colors", message: "missing required field" });
    }
    if (!("needsReview" in obj)) {
      errors.push({ field: "needsReview", message: "missing required field" });
    }
    if (!("hasAlert" in obj)) {
      errors.push({ field: "hasAlert", message: "missing required field" });
    }
    if (!("accountType" in obj)) {
      errors.push({ field: "accountType", message: "missing required field" });
    }
    if (!("subtype" in obj)) {
      errors.push({ field: "subtype", message: "missing required field" });
    }
    if (!("isTaxExempt" in obj)) {
      errors.push({ field: "isTaxExempt", message: "missing required field" });
    }
    if (!("paymentTerms" in obj)) {
      errors.push({ field: "paymentTerms", message: "missing required field" });
    }
    if (!("tags" in obj)) {
      errors.push({ field: "tags", message: "missing required field" });
    }
    if (!("dateAdded" in obj)) {
      errors.push({ field: "dateAdded", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_taxRate = obj["taxRate"];
      instance.taxRate = __raw_taxRate;
    }
    {
      const __raw_site = obj["site"];
      instance.site = __raw_site;
    }
    {
      const __raw_salesRep = obj["salesRep"];
      instance.salesRep = __raw_salesRep;
    }
    {
      const __raw_orders = obj["orders"];
      instance.orders = __raw_orders;
    }
    {
      const __raw_activity = obj["activity"];
      instance.activity = __raw_activity;
    }
    {
      const __raw_customFields = obj["customFields"];
      instance.customFields = __raw_customFields;
    }
    {
      const __raw_accountName = obj["accountName"];
      if (typeof (AccountName as any)?.__deserialize === "function") {
        const __result = (AccountName as any).__deserialize(
          __raw_accountName,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "accountName", __result);
=======
        if (PendingRef.is(__result)) {
          instance.accountName = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.accountName = v;
          });
        } else {
          instance.accountName = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.accountName = __raw_accountName;
      }
    }
    {
      const __raw_sector = obj["sector"];
      if (typeof (Sector as any)?.__deserialize === "function") {
        const __result = (Sector as any).__deserialize(__raw_sector, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "sector", __result);
=======
        if (PendingRef.is(__result)) {
          instance.sector = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.sector = v;
          });
        } else {
          instance.sector = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.sector = __raw_sector;
      }
    }
    {
      const __raw_memo = obj["memo"];
      instance.memo = __raw_memo;
    }
    {
      const __raw_phones = obj["phones"];
      instance.phones = __raw_phones;
    }
    {
      const __raw_email = obj["email"];
      if (typeof (Email as any)?.__deserialize === "function") {
        const __result = (Email as any).__deserialize(__raw_email, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "email", __result);
=======
        if (PendingRef.is(__result)) {
          instance.email = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.email = v;
          });
        } else {
          instance.email = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.email = __raw_email;
      }
    }
    {
      const __raw_leadSource = obj["leadSource"];
      instance.leadSource = __raw_leadSource;
    }
    {
      const __raw_colors = obj["colors"];
      if (typeof (Colors as any)?.__deserialize === "function") {
        const __result = (Colors as any).__deserialize(__raw_colors, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "colors", __result);
=======
        if (PendingRef.is(__result)) {
          instance.colors = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.colors = v;
          });
        } else {
          instance.colors = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.colors = __raw_colors;
      }
    }
    {
      const __raw_needsReview = obj["needsReview"];
      instance.needsReview = __raw_needsReview;
    }
    {
      const __raw_hasAlert = obj["hasAlert"];
      instance.hasAlert = __raw_hasAlert;
    }
    {
      const __raw_accountType = obj["accountType"];
      instance.accountType = __raw_accountType;
    }
    {
      const __raw_subtype = obj["subtype"];
      instance.subtype = __raw_subtype;
    }
    {
      const __raw_isTaxExempt = obj["isTaxExempt"];
      instance.isTaxExempt = __raw_isTaxExempt;
    }
    {
      const __raw_paymentTerms = obj["paymentTerms"];
      instance.paymentTerms = __raw_paymentTerms;
    }
    {
      const __raw_tags = obj["tags"];
      instance.tags = __raw_tags;
    }
    {
      const __raw_dateAdded = obj["dateAdded"];
      instance.dateAdded = __raw_dateAdded;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Account;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Account>(
    field: K,
    value: Account[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "leadSource": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "leadSource", message: "must not be empty" });
        }
        break;
      }
      case "accountType": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "accountType", message: "must not be empty" });
        }
        break;
      }
      case "subtype": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "subtype", message: "must not be empty" });
        }
        break;
      }
      case "paymentTerms": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "paymentTerms", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Account>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("leadSource" in partial && partial.leadSource !== undefined) {
      const __val = partial.leadSource as string;
      if (__val.length === 0) {
        errors.push({ field: "leadSource", message: "must not be empty" });
      }
    }
    if ("accountType" in partial && partial.accountType !== undefined) {
      const __val = partial.accountType as string;
      if (__val.length === 0) {
        errors.push({ field: "accountType", message: "must not be empty" });
      }
    }
    if ("subtype" in partial && partial.subtype !== undefined) {
      const __val = partial.subtype as string;
      if (__val.length === 0) {
        errors.push({ field: "subtype", message: "must not be empty" });
      }
    }
    if ("paymentTerms" in partial && partial.paymentTerms !== undefined) {
      const __val = partial.paymentTerms as string;
      if (__val.length === 0) {
        errors.push({ field: "paymentTerms", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Account {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    taxRate: Option<Array<string>>;
    site: Option<Array<string>>;
    salesRep: Option<Array<string>>;
    orders: Option<Array<string>>;
    activity: Option<Array<string>>;
    customFields: Option<Array<string>>;
    accountName: Option<Array<string>>;
    sector: Option<Array<string>>;
    memo: Option<Array<string>>;
    phones: Option<Array<string>>;
    email: Option<Array<string>>;
    leadSource: Option<Array<string>>;
    colors: Option<Array<string>>;
    needsReview: Option<Array<string>>;
    hasAlert: Option<Array<string>>;
    accountType: Option<Array<string>>;
    subtype: Option<Array<string>>;
    isTaxExempt: Option<Array<string>>;
    paymentTerms: Option<Array<string>>;
    tags: Option<Array<string>>;
    dateAdded: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      taxRate: Option<boolean>;
      site: Option<boolean>;
      salesRep: Option<boolean>;
      orders: Option<boolean>;
      activity: Option<boolean>;
      customFields: Option<boolean>;
      accountName: Option<boolean>;
      sector: Option<boolean>;
      memo: Option<boolean>;
      phones: Option<boolean>;
      email: Option<boolean>;
      leadSource: Option<boolean>;
      colors: Option<boolean>;
      needsReview: Option<boolean>;
      hasAlert: Option<boolean>;
      accountType: Option<boolean>;
      subtype: Option<boolean>;
      isTaxExempt: Option<boolean>;
      paymentTerms: Option<boolean>;
      tags: Option<boolean>;
      dateAdded: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly taxRate: FieldController<string | TaxRate>;
    readonly site: FieldController<string | Site>;
    readonly salesRep: FieldController<Represents[] | null>;
    readonly orders: ArrayFieldController<Ordered>;
    readonly activity: ArrayFieldController<Did>;
    readonly customFields: ArrayFieldController<[string, string]>;
    readonly accountName: FieldController<AccountName>;
    readonly sector: FieldController<Sector>;
    readonly memo: FieldController<string | null>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly email: FieldController<Email>;
    readonly leadSource: FieldController<string>;
    readonly colors: FieldController<Colors>;
    readonly needsReview: FieldController<boolean>;
    readonly hasAlert: FieldController<boolean>;
    readonly accountType: FieldController<string>;
    readonly subtype: FieldController<string>;
    readonly isTaxExempt: FieldController<boolean>;
    readonly paymentTerms: FieldController<string>;
    readonly tags: ArrayFieldController<string>;
    readonly dateAdded: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Account;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Account, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Account>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Account>,
  ): Gigaform {
    let data = $state({ ...Account.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      taxRate: Option.none(),
      site: Option.none(),
      salesRep: Option.none(),
      orders: Option.none(),
      activity: Option.none(),
      customFields: Option.none(),
      accountName: Option.none(),
      sector: Option.none(),
      memo: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      colors: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      dateAdded: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      taxRate: Option.none(),
      site: Option.none(),
      salesRep: Option.none(),
      orders: Option.none(),
      activity: Option.none(),
      customFields: Option.none(),
      accountName: Option.none(),
      sector: Option.none(),
      memo: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      colors: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      dateAdded: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      taxRate: {
        path: ["taxRate"] as const,
        name: "taxRate",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Tax Rate",
>>>>>>> Stashed changes
        get: () => data.taxRate,
        set: (value: string | TaxRate) => {
          data.taxRate = value;
        },
        getError: () => errors.taxRate,
        setError: (value: Option<Array<string>>) => {
          errors.taxRate = value;
        },
        getTainted: () => tainted.taxRate,
        setTainted: (value: Option<boolean>) => {
          tainted.taxRate = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "taxRate")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("taxRate", data.taxRate);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      site: {
        path: ["site"] as const,
        name: "site",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Site",
>>>>>>> Stashed changes
        get: () => data.site,
        set: (value: string | Site) => {
          data.site = value;
        },
        getError: () => errors.site,
        setError: (value: Option<Array<string>>) => {
          errors.site = value;
        },
        getTainted: () => tainted.site,
        setTainted: (value: Option<boolean>) => {
          tainted.site = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "site")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("site", data.site);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Sales Rep",
>>>>>>> Stashed changes
        get: () => data.salesRep,
        set: (value: Represents[] | null) => {
          data.salesRep = value;
        },
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "salesRep")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("salesRep", data.salesRep);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      orders: {
        path: ["orders"] as const,
        name: "orders",
        constraints: { required: true },

        get: () => data.orders,
        set: (value: Ordered[]) => {
          data.orders = value;
        },
        getError: () => errors.orders,
        setError: (value: Option<Array<string>>) => {
          errors.orders = value;
        },
        getTainted: () => tainted.orders,
        setTainted: (value: Option<boolean>) => {
          tainted.orders = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "orders")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("orders", data.orders);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["orders", index] as const,
          name: `orders.${index}`,
          constraints: { required: true },
          get: () => data.orders[index],
          set: (value: Ordered) => {
            data.orders[index] = value;
          },
          getError: () => errors.orders,
          setError: (value: Option<Array<string>>) => {
            errors.orders = value;
          },
          getTainted: () => tainted.orders,
          setTainted: (value: Option<boolean>) => {
            tainted.orders = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Ordered) => {
          data.orders.push(item);
        },
        remove: (index: number) => {
          data.orders.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.orders[a], data.orders[b]] = [data.orders[b], data.orders[a]];
        },
      },
      activity: {
        path: ["activity"] as const,
        name: "activity",
        constraints: { required: true },

        get: () => data.activity,
        set: (value: Did[]) => {
          data.activity = value;
        },
        getError: () => errors.activity,
        setError: (value: Option<Array<string>>) => {
          errors.activity = value;
        },
        getTainted: () => tainted.activity,
        setTainted: (value: Option<boolean>) => {
          tainted.activity = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "activity")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("activity", data.activity);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["activity", index] as const,
          name: `activity.${index}`,
          constraints: { required: true },
          get: () => data.activity[index],
          set: (value: Did) => {
            data.activity[index] = value;
          },
          getError: () => errors.activity,
          setError: (value: Option<Array<string>>) => {
            errors.activity = value;
          },
          getTainted: () => tainted.activity,
          setTainted: (value: Option<boolean>) => {
            tainted.activity = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Did) => {
          data.activity.push(item);
        },
        remove: (index: number) => {
          data.activity.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.activity[a], data.activity[b]] = [
            data.activity[b],
            data.activity[a],
          ];
        },
      },
      customFields: {
        path: ["customFields"] as const,
        name: "customFields",
        constraints: { required: true },

        get: () => data.customFields,
        set: (value: [string, string][]) => {
          data.customFields = value;
        },
        getError: () => errors.customFields,
        setError: (value: Option<Array<string>>) => {
          errors.customFields = value;
        },
        getTainted: () => tainted.customFields,
        setTainted: (value: Option<boolean>) => {
          tainted.customFields = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "customFields")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "customFields",
            data.customFields,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["customFields", index] as const,
          name: `customFields.${index}`,
          constraints: { required: true },
          get: () => data.customFields[index],
          set: (value: [string, string]) => {
            data.customFields[index] = value;
          },
          getError: () => errors.customFields,
          setError: (value: Option<Array<string>>) => {
            errors.customFields = value;
          },
          getTainted: () => tainted.customFields,
          setTainted: (value: Option<boolean>) => {
            tainted.customFields = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: [string, string]) => {
          data.customFields.push(item);
        },
        remove: (index: number) => {
          data.customFields.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.customFields[a], data.customFields[b]] = [
            data.customFields[b],
            data.customFields[a],
          ];
        },
      },
      accountName: {
        path: ["accountName"] as const,
        name: "accountName",
        constraints: { required: true },

        get: () => data.accountName,
        set: (value: AccountName) => {
          data.accountName = value;
        },
        getError: () => errors.accountName,
        setError: (value: Option<Array<string>>) => {
          errors.accountName = value;
        },
        getTainted: () => tainted.accountName,
        setTainted: (value: Option<boolean>) => {
          tainted.accountName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "accountName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "accountName",
            data.accountName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      sector: {
        path: ["sector"] as const,
        name: "sector",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Sector",
>>>>>>> Stashed changes
        get: () => data.sector,
        set: (value: Sector) => {
          data.sector = value;
        },
        getError: () => errors.sector,
        setError: (value: Option<Array<string>>) => {
          errors.sector = value;
        },
        getTainted: () => tainted.sector,
        setTainted: (value: Option<boolean>) => {
          tainted.sector = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "sector")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("sector", data.sector);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      memo: {
        path: ["memo"] as const,
        name: "memo",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Memo",
>>>>>>> Stashed changes
        get: () => data.memo,
        set: (value: string | null) => {
          data.memo = value;
        },
        getError: () => errors.memo,
        setError: (value: Option<Array<string>>) => {
          errors.memo = value;
        },
        getTainted: () => tainted.memo,
        setTainted: (value: Option<boolean>) => {
          tainted.memo = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "memo")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("memo", data.memo);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "phones")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("phones", data.phones);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index],
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.phones[a], data.phones[b]] = [data.phones[b], data.phones[a]];
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Email",
>>>>>>> Stashed changes
        get: () => data.email,
        set: (value: Email) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "email")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("email", data.email);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      leadSource: {
        path: ["leadSource"] as const,
        name: "leadSource",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Lead Source",
>>>>>>> Stashed changes
        get: () => data.leadSource,
        set: (value: string) => {
          data.leadSource = value;
        },
        getError: () => errors.leadSource,
        setError: (value: Option<Array<string>>) => {
          errors.leadSource = value;
        },
        getTainted: () => tainted.leadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.leadSource = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "leadSource")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "leadSource",
            data.leadSource,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      colors: {
        path: ["colors"] as const,
        name: "colors",
        constraints: { required: true },

        get: () => data.colors,
        set: (value: Colors) => {
          data.colors = value;
        },
        getError: () => errors.colors,
        setError: (value: Option<Array<string>>) => {
          errors.colors = value;
        },
        getTainted: () => tainted.colors,
        setTainted: (value: Option<boolean>) => {
          tainted.colors = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "colors")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("colors", data.colors);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      needsReview: {
        path: ["needsReview"] as const,
        name: "needsReview",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Needs Review",
>>>>>>> Stashed changes
        get: () => data.needsReview,
        set: (value: boolean) => {
          data.needsReview = value;
        },
        getError: () => errors.needsReview,
        setError: (value: Option<Array<string>>) => {
          errors.needsReview = value;
        },
        getTainted: () => tainted.needsReview,
        setTainted: (value: Option<boolean>) => {
          tainted.needsReview = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "needsReview")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "needsReview",
            data.needsReview,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasAlert: {
        path: ["hasAlert"] as const,
        name: "hasAlert",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Has Alert",
>>>>>>> Stashed changes
        get: () => data.hasAlert,
        set: (value: boolean) => {
          data.hasAlert = value;
        },
        getError: () => errors.hasAlert,
        setError: (value: Option<Array<string>>) => {
          errors.hasAlert = value;
        },
        getTainted: () => tainted.hasAlert,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAlert = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasAlert")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("hasAlert", data.hasAlert);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      accountType: {
        path: ["accountType"] as const,
        name: "accountType",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Account Type",
>>>>>>> Stashed changes
        get: () => data.accountType,
        set: (value: string) => {
          data.accountType = value;
        },
        getError: () => errors.accountType,
        setError: (value: Option<Array<string>>) => {
          errors.accountType = value;
        },
        getTainted: () => tainted.accountType,
        setTainted: (value: Option<boolean>) => {
          tainted.accountType = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "accountType")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "accountType",
            data.accountType,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      subtype: {
        path: ["subtype"] as const,
        name: "subtype",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Subtype",
>>>>>>> Stashed changes
        get: () => data.subtype,
        set: (value: string) => {
          data.subtype = value;
        },
        getError: () => errors.subtype,
        setError: (value: Option<Array<string>>) => {
          errors.subtype = value;
        },
        getTainted: () => tainted.subtype,
        setTainted: (value: Option<boolean>) => {
          tainted.subtype = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "subtype")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("subtype", data.subtype);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      isTaxExempt: {
        path: ["isTaxExempt"] as const,
        name: "isTaxExempt",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Tax Exempt",
>>>>>>> Stashed changes
        get: () => data.isTaxExempt,
        set: (value: boolean) => {
          data.isTaxExempt = value;
        },
        getError: () => errors.isTaxExempt,
        setError: (value: Option<Array<string>>) => {
          errors.isTaxExempt = value;
        },
        getTainted: () => tainted.isTaxExempt,
        setTainted: (value: Option<boolean>) => {
          tainted.isTaxExempt = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "isTaxExempt")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "isTaxExempt",
            data.isTaxExempt,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      paymentTerms: {
        path: ["paymentTerms"] as const,
        name: "paymentTerms",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Payment Terms",
>>>>>>> Stashed changes
        get: () => data.paymentTerms,
        set: (value: string) => {
          data.paymentTerms = value;
        },
        getError: () => errors.paymentTerms,
        setError: (value: Option<Array<string>>) => {
          errors.paymentTerms = value;
        },
        getTainted: () => tainted.paymentTerms,
        setTainted: (value: Option<boolean>) => {
          tainted.paymentTerms = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "paymentTerms")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "paymentTerms",
            data.paymentTerms,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      tags: {
        path: ["tags"] as const,
        name: "tags",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Tags",
>>>>>>> Stashed changes
        get: () => data.tags,
        set: (value: string[]) => {
          data.tags = value;
        },
        getError: () => errors.tags,
        setError: (value: Option<Array<string>>) => {
          errors.tags = value;
        },
        getTainted: () => tainted.tags,
        setTainted: (value: Option<boolean>) => {
          tainted.tags = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "tags")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField("tags", data.tags);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["tags", index] as const,
          name: `tags.${index}`,
          constraints: { required: true },
          get: () => data.tags[index],
          set: (value: string) => {
            data.tags[index] = value;
          },
          getError: () => errors.tags,
          setError: (value: Option<Array<string>>) => {
            errors.tags = value;
          },
          getTainted: () => tainted.tags,
          setTainted: (value: Option<boolean>) => {
            tainted.tags = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.tags.push(item);
        },
        remove: (index: number) => {
          data.tags.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.tags[a], data.tags[b]] = [data.tags[b], data.tags[a]];
        },
      },
      dateAdded: {
        path: ["dateAdded"] as const,
        name: "dateAdded",
        constraints: { required: true },

        get: () => data.dateAdded,
        set: (value: string) => {
          data.dateAdded = value;
        },
        getError: () => errors.dateAdded,
        setError: (value: Option<Array<string>>) => {
          errors.dateAdded = value;
        },
        getTainted: () => tainted.dateAdded,
        setTainted: (value: Option<boolean>) => {
          tainted.dateAdded = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Account.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "dateAdded")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Account.validateField(
            "dateAdded",
            data.dateAdded,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Account,
      Array<{ field: string; message: string }>
    > {
      return Account.fromObject(data);
    }
    function reset(newOverrides?: Partial<Account>): void {
      data = { ...Account.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        taxRate: Option.none(),
        site: Option.none(),
        salesRep: Option.none(),
        orders: Option.none(),
        activity: Option.none(),
        customFields: Option.none(),
        accountName: Option.none(),
        sector: Option.none(),
        memo: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        colors: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        dateAdded: Option.none(),
      };
      tainted = {
        id: Option.none(),
        taxRate: Option.none(),
        site: Option.none(),
        salesRep: Option.none(),
        orders: Option.none(),
        activity: Option.none(),
        customFields: Option.none(),
        accountName: Option.none(),
        sector: Option.none(),
        memo: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        colors: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        dateAdded: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Account, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.taxRate = formData.get("taxRate") ?? "";
    obj.site = formData.get("site") ?? "";
    obj.salesRep = formData.get("salesRep") ?? "";
    {
      // Collect array items from indexed form fields
      const ordersItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("orders." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("orders." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("orders." + idx + ".")) {
              const fieldName = key.slice(
                "orders.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          ordersItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.orders = ordersItems;
    }
    {
      // Collect array items from indexed form fields
      const activityItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("activity." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("activity." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("activity." + idx + ".")) {
              const fieldName = key.slice(
                "activity.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          activityItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.activity = activityItems;
    }
    {
      // Collect array items from indexed form fields
      const customFieldsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("customFields." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("customFields." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("customFields." + idx + ".")) {
              const fieldName = key.slice(
                "customFields.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          customFieldsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.customFields = customFieldsItems;
    }
    {
      // Collect nested object fields with prefix "accountName."
      const accountNameObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("accountName.")) {
          const fieldName = key.slice("accountName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = accountNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.accountName = accountNameObj;
    }
    {
      // Collect nested object fields with prefix "sector."
      const sectorObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("sector.")) {
          const fieldName = key.slice("sector.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = sectorObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.sector = sectorObj;
    }
    obj.memo = formData.get("memo") ?? "";
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.email = emailObj;
    }
    obj.leadSource = formData.get("leadSource") ?? "";
    {
      // Collect nested object fields with prefix "colors."
      const colorsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("colors.")) {
          const fieldName = key.slice("colors.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = colorsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.colors = colorsObj;
    }
    {
      const needsReviewVal = formData.get("needsReview");
      obj.needsReview =
        needsReviewVal === "true" ||
        needsReviewVal === "on" ||
        needsReviewVal === "1";
    }
    {
      const hasAlertVal = formData.get("hasAlert");
      obj.hasAlert =
        hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
    }
    obj.accountType = formData.get("accountType") ?? "";
    obj.subtype = formData.get("subtype") ?? "";
    {
      const isTaxExemptVal = formData.get("isTaxExempt");
      obj.isTaxExempt =
        isTaxExemptVal === "true" ||
        isTaxExemptVal === "on" ||
        isTaxExemptVal === "1";
    }
    obj.paymentTerms = formData.get("paymentTerms") ?? "";
    obj.tags = formData.getAll("tags") as Array<string>;
    obj.dateAdded = formData.get("dateAdded") ?? "";
    return Account.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Edited {
  fieldName: string;
  oldValue: string | null;
  newValue: string | null;
}

export namespace Edited {
  export function defaultValue(): Edited {
    return { fieldName: "", oldValue: null, newValue: null } as Edited;
  }
}

export namespace Edited {
  export function toStringifiedJSON(self: Edited): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Edited): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Edited,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Edited", __id };
    result["fieldName"] = self.fieldName;
    if (self.oldValue !== null) {
      result["oldValue"] =
        typeof (self.oldValue as any)?.__serialize === "function"
          ? (self.oldValue as any).__serialize(ctx)
          : self.oldValue;
    } else {
      result["oldValue"] = null;
    }
    if (self.newValue !== null) {
      result["newValue"] =
        typeof (self.newValue as any)?.__serialize === "function"
          ? (self.newValue as any).__serialize(ctx)
          : self.newValue;
    } else {
      result["newValue"] = null;
    }
    return result;
  }
}

export namespace Edited {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Edited, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Edited, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Edited.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Edited | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Edited.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("fieldName" in obj)) {
      errors.push({ field: "fieldName", message: "missing required field" });
    }
    if (!("oldValue" in obj)) {
      errors.push({ field: "oldValue", message: "missing required field" });
    }
    if (!("newValue" in obj)) {
      errors.push({ field: "newValue", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_fieldName = obj["fieldName"];
      instance.fieldName = __raw_fieldName;
    }
    {
      const __raw_oldValue = obj["oldValue"];
      instance.oldValue = __raw_oldValue;
    }
    {
      const __raw_newValue = obj["newValue"];
      instance.newValue = __raw_newValue;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Edited;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Edited>(
    field: K,
    value: Edited[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "fieldName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "fieldName", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Edited>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("fieldName" in partial && partial.fieldName !== undefined) {
      const __val = partial.fieldName as string;
      if (__val.length === 0) {
        errors.push({ field: "fieldName", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Edited {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    fieldName: Option<Array<string>>;
    oldValue: Option<Array<string>>;
    newValue: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      fieldName: Option<boolean>;
      oldValue: Option<boolean>;
      newValue: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly fieldName: FieldController<string>;
    readonly oldValue: FieldController<string | null>;
    readonly newValue: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Edited;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Edited, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Edited>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Edited>,
  ): Gigaform {
    let data = $state({ ...Edited.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      fieldName: Option.none(),
      oldValue: Option.none(),
      newValue: Option.none(),
    });
    let tainted = $state<Tainted>({
      fieldName: Option.none(),
      oldValue: Option.none(),
      newValue: Option.none(),
    });
    const fields: FieldControllers = {
      fieldName: {
        path: ["fieldName"] as const,
        name: "fieldName",
        constraints: { required: true },

        get: () => data.fieldName,
        set: (value: string) => {
          data.fieldName = value;
        },
        getError: () => errors.fieldName,
        setError: (value: Option<Array<string>>) => {
          errors.fieldName = value;
        },
        getTainted: () => tainted.fieldName,
        setTainted: (value: Option<boolean>) => {
          tainted.fieldName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Edited.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "fieldName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Edited.validateField("fieldName", data.fieldName);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      oldValue: {
        path: ["oldValue"] as const,
        name: "oldValue",
        constraints: { required: true },

        get: () => data.oldValue,
        set: (value: string | null) => {
          data.oldValue = value;
        },
        getError: () => errors.oldValue,
        setError: (value: Option<Array<string>>) => {
          errors.oldValue = value;
        },
        getTainted: () => tainted.oldValue,
        setTainted: (value: Option<boolean>) => {
          tainted.oldValue = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Edited.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "oldValue")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Edited.validateField("oldValue", data.oldValue);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      newValue: {
        path: ["newValue"] as const,
        name: "newValue",
        constraints: { required: true },

        get: () => data.newValue,
        set: (value: string | null) => {
          data.newValue = value;
        },
        getError: () => errors.newValue,
        setError: (value: Option<Array<string>>) => {
          errors.newValue = value;
        },
        getTainted: () => tainted.newValue,
        setTainted: (value: Option<boolean>) => {
          tainted.newValue = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Edited.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "newValue")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Edited.validateField("newValue", data.newValue);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Edited,
      Array<{ field: string; message: string }>
    > {
      return Edited.fromObject(data);
    }
    function reset(newOverrides?: Partial<Edited>): void {
      data = { ...Edited.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        fieldName: Option.none(),
        oldValue: Option.none(),
        newValue: Option.none(),
      };
      tainted = {
        fieldName: Option.none(),
        oldValue: Option.none(),
        newValue: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Edited, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.fieldName = formData.get("fieldName") ?? "";
    obj.oldValue = formData.get("oldValue") ?? "";
    obj.newValue = formData.get("newValue") ?? "";
    return Edited.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Order {
  id: string;

  account: string | Account;

  stage: OrderStage;
<<<<<<< Updated upstream
  number: number;
=======

  number: number;

>>>>>>> Stashed changes
  payments: (string | Payment)[];

  opportunity: string;

  reference: string;

  leadSource: string;

  salesRep: string | Employee;

  group: string;

  subgroup: string;
<<<<<<< Updated upstream
  isPosted: boolean;
  needsReview: boolean;

  actionItem: string;
  upsale: number;
  dateCreated: string;

  appointment: string | Appointment;
  lastTechs: (string | Employee)[];
  package: (string | Package)[] | null;
  promotion: (string | Promotion)[] | null;
  balance: number;
  due: string;
  total: number;

  site: string | Site;
  billedItems: BilledItem[];

  memo: string;
  discount: number;
  tip: number;
=======

  isPosted: boolean;

  needsReview: boolean;

  actionItem: string;

  upsale: number;

  dateCreated: string;

  appointment: string | Appointment;

  lastTechs: (string | Employee)[];

  package: (string | Package)[] | null;

  promotion: (string | Promotion)[] | null;

  balance: number;

  due: string;

  total: number;

  site: string | Site;

  billedItems: BilledItem[];

  memo: string;

  discount: number;

  tip: number;

>>>>>>> Stashed changes
  commissions: number[];
}

export namespace Order {
  export function defaultValue(): Order {
    return {
      id: "",
      account: "",
      stage: "Estimate",
      number: 0,
      payments: [],
      opportunity: "",
      reference: "",
      leadSource: "",
      salesRep: "",
      group: "",
      subgroup: "",
      isPosted: false,
      needsReview: false,
      actionItem: "",
      upsale: 0,
      dateCreated: "",
      appointment: "",
      lastTechs: [],
      package: null,
      promotion: null,
      balance: 0,
      due: "",
      total: 0,
      site: "",
      billedItems: [],
      memo: "",
      discount: 0,
      tip: 0,
      commissions: [],
    } as Order;
  }
}

export namespace Order {
  export function toStringifiedJSON(self: Order): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Order): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Order,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Order", __id };
    result["id"] = self.id;
    result["account"] = self.account;
    result["stage"] =
      typeof (self.stage as any)?.__serialize === "function"
        ? (self.stage as any).__serialize(ctx)
        : self.stage;
    result["number"] = self.number;
    result["payments"] = self.payments.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["opportunity"] = self.opportunity;
    result["reference"] = self.reference;
    result["leadSource"] = self.leadSource;
    result["salesRep"] = self.salesRep;
    result["group"] = self.group;
    result["subgroup"] = self.subgroup;
    result["isPosted"] = self.isPosted;
    result["needsReview"] = self.needsReview;
    result["actionItem"] = self.actionItem;
    result["upsale"] = self.upsale;
    result["dateCreated"] = self.dateCreated;
    result["appointment"] = self.appointment;
    result["lastTechs"] = self.lastTechs.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    if (self.package !== null) {
      result["package"] =
        typeof (self.package as any)?.__serialize === "function"
          ? (self.package as any).__serialize(ctx)
          : self.package;
    } else {
      result["package"] = null;
    }
    if (self.promotion !== null) {
      result["promotion"] =
        typeof (self.promotion as any)?.__serialize === "function"
          ? (self.promotion as any).__serialize(ctx)
          : self.promotion;
    } else {
      result["promotion"] = null;
    }
    result["balance"] = self.balance;
    result["due"] = self.due;
    result["total"] = self.total;
    result["site"] = self.site;
    result["billedItems"] = self.billedItems.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["memo"] = self.memo;
    result["discount"] = self.discount;
    result["tip"] = self.tip;
    result["commissions"] = self.commissions.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    return result;
  }
}

export namespace Order {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Order, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Order, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Order.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Order | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Order.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("account" in obj)) {
      errors.push({ field: "account", message: "missing required field" });
    }
    if (!("stage" in obj)) {
      errors.push({ field: "stage", message: "missing required field" });
    }
    if (!("number" in obj)) {
      errors.push({ field: "number", message: "missing required field" });
    }
    if (!("payments" in obj)) {
      errors.push({ field: "payments", message: "missing required field" });
    }
    if (!("opportunity" in obj)) {
      errors.push({ field: "opportunity", message: "missing required field" });
    }
    if (!("reference" in obj)) {
      errors.push({ field: "reference", message: "missing required field" });
    }
    if (!("leadSource" in obj)) {
      errors.push({ field: "leadSource", message: "missing required field" });
    }
    if (!("salesRep" in obj)) {
      errors.push({ field: "salesRep", message: "missing required field" });
    }
    if (!("group" in obj)) {
      errors.push({ field: "group", message: "missing required field" });
    }
    if (!("subgroup" in obj)) {
      errors.push({ field: "subgroup", message: "missing required field" });
    }
    if (!("isPosted" in obj)) {
      errors.push({ field: "isPosted", message: "missing required field" });
    }
    if (!("needsReview" in obj)) {
      errors.push({ field: "needsReview", message: "missing required field" });
    }
    if (!("actionItem" in obj)) {
      errors.push({ field: "actionItem", message: "missing required field" });
    }
    if (!("upsale" in obj)) {
      errors.push({ field: "upsale", message: "missing required field" });
    }
    if (!("dateCreated" in obj)) {
      errors.push({ field: "dateCreated", message: "missing required field" });
    }
    if (!("appointment" in obj)) {
      errors.push({ field: "appointment", message: "missing required field" });
    }
    if (!("lastTechs" in obj)) {
      errors.push({ field: "lastTechs", message: "missing required field" });
    }
    if (!("package" in obj)) {
      errors.push({ field: "package", message: "missing required field" });
    }
    if (!("promotion" in obj)) {
      errors.push({ field: "promotion", message: "missing required field" });
    }
    if (!("balance" in obj)) {
      errors.push({ field: "balance", message: "missing required field" });
    }
    if (!("due" in obj)) {
      errors.push({ field: "due", message: "missing required field" });
    }
    if (!("total" in obj)) {
      errors.push({ field: "total", message: "missing required field" });
    }
    if (!("site" in obj)) {
      errors.push({ field: "site", message: "missing required field" });
    }
    if (!("billedItems" in obj)) {
      errors.push({ field: "billedItems", message: "missing required field" });
    }
    if (!("memo" in obj)) {
      errors.push({ field: "memo", message: "missing required field" });
    }
    if (!("discount" in obj)) {
      errors.push({ field: "discount", message: "missing required field" });
    }
    if (!("tip" in obj)) {
      errors.push({ field: "tip", message: "missing required field" });
    }
    if (!("commissions" in obj)) {
      errors.push({ field: "commissions", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_account = obj["account"];
      instance.account = __raw_account;
    }
    {
      const __raw_stage = obj["stage"];
      if (typeof (OrderStage as any)?.__deserialize === "function") {
        const __result = (OrderStage as any).__deserialize(__raw_stage, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "stage", __result);
      } else {
        instance.stage = __raw_stage;
      }
    }
    {
      const __raw_number = obj["number"];
      instance.number = __raw_number;
    }
    {
      const __raw_payments = obj["payments"];
      instance.payments = __raw_payments;
    }
    {
      const __raw_opportunity = obj["opportunity"];
      instance.opportunity = __raw_opportunity;
    }
    {
      const __raw_reference = obj["reference"];
      instance.reference = __raw_reference;
    }
    {
      const __raw_leadSource = obj["leadSource"];
      instance.leadSource = __raw_leadSource;
    }
    {
      const __raw_salesRep = obj["salesRep"];
      instance.salesRep = __raw_salesRep;
    }
    {
      const __raw_group = obj["group"];
      instance.group = __raw_group;
    }
    {
      const __raw_subgroup = obj["subgroup"];
      instance.subgroup = __raw_subgroup;
    }
    {
      const __raw_isPosted = obj["isPosted"];
      instance.isPosted = __raw_isPosted;
    }
    {
      const __raw_needsReview = obj["needsReview"];
      instance.needsReview = __raw_needsReview;
    }
    {
      const __raw_actionItem = obj["actionItem"];
      instance.actionItem = __raw_actionItem;
    }
    {
      const __raw_upsale = obj["upsale"];
      instance.upsale = __raw_upsale;
    }
    {
      const __raw_dateCreated = obj["dateCreated"];
      instance.dateCreated = __raw_dateCreated;
    }
    {
      const __raw_appointment = obj["appointment"];
      instance.appointment = __raw_appointment;
    }
    {
      const __raw_lastTechs = obj["lastTechs"];
      instance.lastTechs = __raw_lastTechs;
    }
    {
      const __raw_package = obj["package"];
      instance.package = __raw_package;
    }
    {
      const __raw_promotion = obj["promotion"];
      instance.promotion = __raw_promotion;
    }
    {
      const __raw_balance = obj["balance"];
      instance.balance = __raw_balance;
    }
    {
      const __raw_due = obj["due"];
      instance.due = __raw_due;
    }
    {
      const __raw_total = obj["total"];
      instance.total = __raw_total;
    }
    {
      const __raw_site = obj["site"];
      instance.site = __raw_site;
    }
    {
      const __raw_billedItems = obj["billedItems"];
      instance.billedItems = __raw_billedItems;
    }
    {
      const __raw_memo = obj["memo"];
      instance.memo = __raw_memo;
    }
    {
      const __raw_discount = obj["discount"];
      instance.discount = __raw_discount;
    }
    {
      const __raw_tip = obj["tip"];
      instance.tip = __raw_tip;
    }
    {
      const __raw_commissions = obj["commissions"];
      instance.commissions = __raw_commissions;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Order;
  }
}

export namespace Order {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    account: Option<Array<string>>;
    stage: Option<Array<string>>;
    number: Option<Array<string>>;
    payments: Option<Array<string>>;
    opportunity: Option<Array<string>>;
    reference: Option<Array<string>>;
    leadSource: Option<Array<string>>;
    salesRep: Option<Array<string>>;
    group: Option<Array<string>>;
    subgroup: Option<Array<string>>;
    isPosted: Option<Array<string>>;
    needsReview: Option<Array<string>>;
    actionItem: Option<Array<string>>;
    upsale: Option<Array<string>>;
    dateCreated: Option<Array<string>>;
    appointment: Option<Array<string>>;
    lastTechs: Option<Array<string>>;
    package: Option<Array<string>>;
    promotion: Option<Array<string>>;
    balance: Option<Array<string>>;
    due: Option<Array<string>>;
    total: Option<Array<string>>;
    site: Option<Array<string>>;
    billedItems: Option<Array<string>>;
    memo: Option<Array<string>>;
    discount: Option<Array<string>>;
    tip: Option<Array<string>>;
    commissions: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      account: Option<boolean>;
      stage: Option<boolean>;
      number: Option<boolean>;
      payments: Option<boolean>;
      opportunity: Option<boolean>;
      reference: Option<boolean>;
      leadSource: Option<boolean>;
      salesRep: Option<boolean>;
      group: Option<boolean>;
      subgroup: Option<boolean>;
      isPosted: Option<boolean>;
      needsReview: Option<boolean>;
      actionItem: Option<boolean>;
      upsale: Option<boolean>;
      dateCreated: Option<boolean>;
      appointment: Option<boolean>;
      lastTechs: Option<boolean>;
      package: Option<boolean>;
      promotion: Option<boolean>;
      balance: Option<boolean>;
      due: Option<boolean>;
      total: Option<boolean>;
      site: Option<boolean>;
      billedItems: Option<boolean>;
      memo: Option<boolean>;
      discount: Option<boolean>;
      tip: Option<boolean>;
      commissions: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly account: FieldController<string | Account>;
    readonly stage: FieldController<OrderStage>;
    readonly number: FieldController<number>;
    readonly payments: ArrayFieldController<string | Payment>;
    readonly opportunity: FieldController<string>;
    readonly reference: FieldController<string>;
    readonly leadSource: FieldController<string>;
    readonly salesRep: FieldController<string | Employee>;
    readonly group: FieldController<string>;
    readonly subgroup: FieldController<string>;
    readonly isPosted: FieldController<boolean>;
    readonly needsReview: FieldController<boolean>;
    readonly actionItem: FieldController<string>;
    readonly upsale: FieldController<number>;
    readonly dateCreated: FieldController<string>;
    readonly appointment: FieldController<string | Appointment>;
    readonly lastTechs: ArrayFieldController<string | Employee>;
    readonly package: FieldController<(string | Package)[] | null>;
    readonly promotion: FieldController<(string | Promotion)[] | null>;
    readonly balance: FieldController<number>;
    readonly due: FieldController<string>;
    readonly total: FieldController<number>;
    readonly site: FieldController<string | Site>;
    readonly billedItems: ArrayFieldController<BilledItem>;
    readonly memo: FieldController<string>;
    readonly discount: FieldController<number>;
    readonly tip: FieldController<number>;
    readonly commissions: ArrayFieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Order;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Order, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Order>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Order>,
  ): Gigaform {
    let data = $state({ ...Order.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      account: Option.none(),
      stage: Option.none(),
      number: Option.none(),
      payments: Option.none(),
      opportunity: Option.none(),
      reference: Option.none(),
      leadSource: Option.none(),
      salesRep: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      isPosted: Option.none(),
      needsReview: Option.none(),
      actionItem: Option.none(),
      upsale: Option.none(),
      dateCreated: Option.none(),
      appointment: Option.none(),
      lastTechs: Option.none(),
      package: Option.none(),
      promotion: Option.none(),
      balance: Option.none(),
      due: Option.none(),
      total: Option.none(),
      site: Option.none(),
      billedItems: Option.none(),
      memo: Option.none(),
      discount: Option.none(),
      tip: Option.none(),
      commissions: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      account: Option.none(),
      stage: Option.none(),
      number: Option.none(),
      payments: Option.none(),
      opportunity: Option.none(),
      reference: Option.none(),
      leadSource: Option.none(),
      salesRep: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      isPosted: Option.none(),
      needsReview: Option.none(),
      actionItem: Option.none(),
      upsale: Option.none(),
      dateCreated: Option.none(),
      appointment: Option.none(),
      lastTechs: Option.none(),
      package: Option.none(),
      promotion: Option.none(),
      balance: Option.none(),
      due: Option.none(),
      total: Option.none(),
      site: Option.none(),
      billedItems: Option.none(),
      memo: Option.none(),
      discount: Option.none(),
      tip: Option.none(),
      commissions: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
        },
      },
      account: {
        path: ["account"] as const,
        name: "account",
        constraints: { required: true },

        get: () => data.account,
        set: (value: string | Account) => {
          data.account = value;
        },
        getError: () => errors.account,
        setError: (value: Option<Array<string>>) => {
          errors.account = value;
        },
        getTainted: () => tainted.account,
        setTainted: (value: Option<boolean>) => {
          tainted.account = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "account")
              .map((e) => e.message);
          }
          return [];
        },
      },
      stage: {
        path: ["stage"] as const,
        name: "stage",
        constraints: { required: true },

        get: () => data.stage,
        set: (value: OrderStage) => {
          data.stage = value;
        },
        getError: () => errors.stage,
        setError: (value: Option<Array<string>>) => {
          errors.stage = value;
        },
        getTainted: () => tainted.stage,
        setTainted: (value: Option<boolean>) => {
          tainted.stage = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "stage")
              .map((e) => e.message);
          }
          return [];
        },
      },
      number: {
        path: ["number"] as const,
        name: "number",
        constraints: { required: true },

        get: () => data.number,
        set: (value: number) => {
          data.number = value;
        },
        getError: () => errors.number,
        setError: (value: Option<Array<string>>) => {
          errors.number = value;
        },
        getTainted: () => tainted.number,
        setTainted: (value: Option<boolean>) => {
          tainted.number = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "number")
              .map((e) => e.message);
          }
          return [];
        },
      },
      payments: {
        path: ["payments"] as const,
        name: "payments",
        constraints: { required: true },

        get: () => data.payments,
        set: (value: (string | Payment)[]) => {
          data.payments = value;
        },
        getError: () => errors.payments,
        setError: (value: Option<Array<string>>) => {
          errors.payments = value;
        },
        getTainted: () => tainted.payments,
        setTainted: (value: Option<boolean>) => {
          tainted.payments = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "payments")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["payments", index] as const,
          name: `payments.${index}`,
          constraints: { required: true },
          get: () => data.payments[index],
          set: (value: string | Payment) => {
            data.payments[index] = value;
          },
          getError: () => errors.payments,
          setError: (value: Option<Array<string>>) => {
            errors.payments = value;
          },
          getTainted: () => tainted.payments,
          setTainted: (value: Option<boolean>) => {
            tainted.payments = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Payment) => {
          data.payments.push(item);
        },
        remove: (index: number) => {
          data.payments.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.payments[a], data.payments[b]] = [
            data.payments[b],
            data.payments[a],
          ];
        },
      },
      opportunity: {
        path: ["opportunity"] as const,
        name: "opportunity",
        constraints: { required: true },

        get: () => data.opportunity,
        set: (value: string) => {
          data.opportunity = value;
        },
        getError: () => errors.opportunity,
        setError: (value: Option<Array<string>>) => {
          errors.opportunity = value;
        },
        getTainted: () => tainted.opportunity,
        setTainted: (value: Option<boolean>) => {
          tainted.opportunity = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "opportunity")
              .map((e) => e.message);
          }
          return [];
        },
      },
      reference: {
        path: ["reference"] as const,
        name: "reference",
        constraints: { required: true },

        get: () => data.reference,
        set: (value: string) => {
          data.reference = value;
        },
        getError: () => errors.reference,
        setError: (value: Option<Array<string>>) => {
          errors.reference = value;
        },
        getTainted: () => tainted.reference,
        setTainted: (value: Option<boolean>) => {
          tainted.reference = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "reference")
              .map((e) => e.message);
          }
          return [];
        },
      },
      leadSource: {
        path: ["leadSource"] as const,
        name: "leadSource",
        constraints: { required: true },

        get: () => data.leadSource,
        set: (value: string) => {
          data.leadSource = value;
        },
        getError: () => errors.leadSource,
        setError: (value: Option<Array<string>>) => {
          errors.leadSource = value;
        },
        getTainted: () => tainted.leadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.leadSource = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "leadSource")
              .map((e) => e.message);
          }
          return [];
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },

        get: () => data.salesRep,
        set: (value: string | Employee) => {
          data.salesRep = value;
        },
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "salesRep")
              .map((e) => e.message);
          }
          return [];
        },
      },
      group: {
        path: ["group"] as const,
        name: "group",
        constraints: { required: true },

        get: () => data.group,
        set: (value: string) => {
          data.group = value;
        },
        getError: () => errors.group,
        setError: (value: Option<Array<string>>) => {
          errors.group = value;
        },
        getTainted: () => tainted.group,
        setTainted: (value: Option<boolean>) => {
          tainted.group = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "group")
              .map((e) => e.message);
          }
          return [];
        },
      },
      subgroup: {
        path: ["subgroup"] as const,
        name: "subgroup",
        constraints: { required: true },

        get: () => data.subgroup,
        set: (value: string) => {
          data.subgroup = value;
        },
        getError: () => errors.subgroup,
        setError: (value: Option<Array<string>>) => {
          errors.subgroup = value;
        },
        getTainted: () => tainted.subgroup,
        setTainted: (value: Option<boolean>) => {
          tainted.subgroup = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "subgroup")
              .map((e) => e.message);
          }
          return [];
        },
      },
      isPosted: {
        path: ["isPosted"] as const,
        name: "isPosted",
        constraints: { required: true },

        get: () => data.isPosted,
        set: (value: boolean) => {
          data.isPosted = value;
        },
        getError: () => errors.isPosted,
        setError: (value: Option<Array<string>>) => {
          errors.isPosted = value;
        },
        getTainted: () => tainted.isPosted,
        setTainted: (value: Option<boolean>) => {
          tainted.isPosted = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "isPosted")
              .map((e) => e.message);
          }
          return [];
        },
      },
      needsReview: {
        path: ["needsReview"] as const,
        name: "needsReview",
        constraints: { required: true },

        get: () => data.needsReview,
        set: (value: boolean) => {
          data.needsReview = value;
        },
        getError: () => errors.needsReview,
        setError: (value: Option<Array<string>>) => {
          errors.needsReview = value;
        },
        getTainted: () => tainted.needsReview,
        setTainted: (value: Option<boolean>) => {
          tainted.needsReview = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "needsReview")
              .map((e) => e.message);
          }
          return [];
        },
      },
      actionItem: {
        path: ["actionItem"] as const,
        name: "actionItem",
        constraints: { required: true },

        get: () => data.actionItem,
        set: (value: string) => {
          data.actionItem = value;
        },
        getError: () => errors.actionItem,
        setError: (value: Option<Array<string>>) => {
          errors.actionItem = value;
        },
        getTainted: () => tainted.actionItem,
        setTainted: (value: Option<boolean>) => {
          tainted.actionItem = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "actionItem")
              .map((e) => e.message);
          }
          return [];
        },
      },
      upsale: {
        path: ["upsale"] as const,
        name: "upsale",
        constraints: { required: true },

        get: () => data.upsale,
        set: (value: number) => {
          data.upsale = value;
        },
        getError: () => errors.upsale,
        setError: (value: Option<Array<string>>) => {
          errors.upsale = value;
        },
        getTainted: () => tainted.upsale,
        setTainted: (value: Option<boolean>) => {
          tainted.upsale = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "upsale")
              .map((e) => e.message);
          }
          return [];
        },
      },
      dateCreated: {
        path: ["dateCreated"] as const,
        name: "dateCreated",
        constraints: { required: true },

        get: () => data.dateCreated,
        set: (value: string) => {
          data.dateCreated = value;
        },
        getError: () => errors.dateCreated,
        setError: (value: Option<Array<string>>) => {
          errors.dateCreated = value;
        },
        getTainted: () => tainted.dateCreated,
        setTainted: (value: Option<boolean>) => {
          tainted.dateCreated = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "dateCreated")
              .map((e) => e.message);
          }
          return [];
        },
      },
      appointment: {
        path: ["appointment"] as const,
        name: "appointment",
        constraints: { required: true },

        get: () => data.appointment,
        set: (value: string | Appointment) => {
          data.appointment = value;
        },
        getError: () => errors.appointment,
        setError: (value: Option<Array<string>>) => {
          errors.appointment = value;
        },
        getTainted: () => tainted.appointment,
        setTainted: (value: Option<boolean>) => {
          tainted.appointment = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "appointment")
              .map((e) => e.message);
          }
          return [];
        },
      },
      lastTechs: {
        path: ["lastTechs"] as const,
        name: "lastTechs",
        constraints: { required: true },

        get: () => data.lastTechs,
        set: (value: (string | Employee)[]) => {
          data.lastTechs = value;
        },
        getError: () => errors.lastTechs,
        setError: (value: Option<Array<string>>) => {
          errors.lastTechs = value;
        },
        getTainted: () => tainted.lastTechs,
        setTainted: (value: Option<boolean>) => {
          tainted.lastTechs = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lastTechs")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["lastTechs", index] as const,
          name: `lastTechs.${index}`,
          constraints: { required: true },
          get: () => data.lastTechs[index],
          set: (value: string | Employee) => {
            data.lastTechs[index] = value;
          },
          getError: () => errors.lastTechs,
          setError: (value: Option<Array<string>>) => {
            errors.lastTechs = value;
          },
          getTainted: () => tainted.lastTechs,
          setTainted: (value: Option<boolean>) => {
            tainted.lastTechs = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Employee) => {
          data.lastTechs.push(item);
        },
        remove: (index: number) => {
          data.lastTechs.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.lastTechs[a], data.lastTechs[b]] = [
            data.lastTechs[b],
            data.lastTechs[a],
          ];
        },
      },
      package: {
        path: ["package"] as const,
        name: "package",
        constraints: { required: true },

        get: () => data.package,
        set: (value: (string | Package)[] | null) => {
          data.package = value;
        },
        getError: () => errors.package,
        setError: (value: Option<Array<string>>) => {
          errors.package = value;
        },
        getTainted: () => tainted.package,
        setTainted: (value: Option<boolean>) => {
          tainted.package = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "package")
              .map((e) => e.message);
          }
          return [];
        },
      },
      promotion: {
        path: ["promotion"] as const,
        name: "promotion",
        constraints: { required: true },

        get: () => data.promotion,
        set: (value: (string | Promotion)[] | null) => {
          data.promotion = value;
        },
        getError: () => errors.promotion,
        setError: (value: Option<Array<string>>) => {
          errors.promotion = value;
        },
        getTainted: () => tainted.promotion,
        setTainted: (value: Option<boolean>) => {
          tainted.promotion = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "promotion")
              .map((e) => e.message);
          }
          return [];
        },
      },
      balance: {
        path: ["balance"] as const,
        name: "balance",
        constraints: { required: true },

        get: () => data.balance,
        set: (value: number) => {
          data.balance = value;
        },
        getError: () => errors.balance,
        setError: (value: Option<Array<string>>) => {
          errors.balance = value;
        },
        getTainted: () => tainted.balance,
        setTainted: (value: Option<boolean>) => {
          tainted.balance = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "balance")
              .map((e) => e.message);
          }
          return [];
        },
      },
      due: {
        path: ["due"] as const,
        name: "due",
        constraints: { required: true },

        get: () => data.due,
        set: (value: string) => {
          data.due = value;
        },
        getError: () => errors.due,
        setError: (value: Option<Array<string>>) => {
          errors.due = value;
        },
        getTainted: () => tainted.due,
        setTainted: (value: Option<boolean>) => {
          tainted.due = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "due")
              .map((e) => e.message);
          }
          return [];
        },
      },
      total: {
        path: ["total"] as const,
        name: "total",
        constraints: { required: true },

        get: () => data.total,
        set: (value: number) => {
          data.total = value;
        },
        getError: () => errors.total,
        setError: (value: Option<Array<string>>) => {
          errors.total = value;
        },
        getTainted: () => tainted.total,
        setTainted: (value: Option<boolean>) => {
          tainted.total = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "total")
              .map((e) => e.message);
          }
          return [];
        },
      },
      site: {
        path: ["site"] as const,
        name: "site",
        constraints: { required: true },

        get: () => data.site,
        set: (value: string | Site) => {
          data.site = value;
        },
        getError: () => errors.site,
        setError: (value: Option<Array<string>>) => {
          errors.site = value;
        },
        getTainted: () => tainted.site,
        setTainted: (value: Option<boolean>) => {
          tainted.site = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "site")
              .map((e) => e.message);
          }
          return [];
        },
      },
      billedItems: {
        path: ["billedItems"] as const,
        name: "billedItems",
        constraints: { required: true },

        get: () => data.billedItems,
        set: (value: BilledItem[]) => {
          data.billedItems = value;
        },
        getError: () => errors.billedItems,
        setError: (value: Option<Array<string>>) => {
          errors.billedItems = value;
        },
        getTainted: () => tainted.billedItems,
        setTainted: (value: Option<boolean>) => {
          tainted.billedItems = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "billedItems")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["billedItems", index] as const,
          name: `billedItems.${index}`,
          constraints: { required: true },
          get: () => data.billedItems[index],
          set: (value: BilledItem) => {
            data.billedItems[index] = value;
          },
          getError: () => errors.billedItems,
          setError: (value: Option<Array<string>>) => {
            errors.billedItems = value;
          },
          getTainted: () => tainted.billedItems,
          setTainted: (value: Option<boolean>) => {
            tainted.billedItems = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: BilledItem) => {
          data.billedItems.push(item);
        },
        remove: (index: number) => {
          data.billedItems.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.billedItems[a], data.billedItems[b]] = [
            data.billedItems[b],
            data.billedItems[a],
          ];
        },
      },
      memo: {
        path: ["memo"] as const,
        name: "memo",
        constraints: { required: true },

        get: () => data.memo,
        set: (value: string) => {
          data.memo = value;
        },
        getError: () => errors.memo,
        setError: (value: Option<Array<string>>) => {
          errors.memo = value;
        },
        getTainted: () => tainted.memo,
        setTainted: (value: Option<boolean>) => {
          tainted.memo = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "memo")
              .map((e) => e.message);
          }
          return [];
        },
      },
      discount: {
        path: ["discount"] as const,
        name: "discount",
        constraints: { required: true },

        get: () => data.discount,
        set: (value: number) => {
          data.discount = value;
        },
        getError: () => errors.discount,
        setError: (value: Option<Array<string>>) => {
          errors.discount = value;
        },
        getTainted: () => tainted.discount,
        setTainted: (value: Option<boolean>) => {
          tainted.discount = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "discount")
              .map((e) => e.message);
          }
          return [];
        },
      },
      tip: {
        path: ["tip"] as const,
        name: "tip",
        constraints: { required: true },

        get: () => data.tip,
        set: (value: number) => {
          data.tip = value;
        },
        getError: () => errors.tip,
        setError: (value: Option<Array<string>>) => {
          errors.tip = value;
        },
        getTainted: () => tainted.tip,
        setTainted: (value: Option<boolean>) => {
          tainted.tip = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "tip")
              .map((e) => e.message);
          }
          return [];
        },
      },
      commissions: {
        path: ["commissions"] as const,
        name: "commissions",
        constraints: { required: true },

        get: () => data.commissions,
        set: (value: number[]) => {
          data.commissions = value;
        },
        getError: () => errors.commissions,
        setError: (value: Option<Array<string>>) => {
          errors.commissions = value;
        },
        getTainted: () => tainted.commissions,
        setTainted: (value: Option<boolean>) => {
          tainted.commissions = value;
        },
        validate: (): Array<string> => {
          const result = Order.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "commissions")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["commissions", index] as const,
          name: `commissions.${index}`,
          constraints: { required: true },
          get: () => data.commissions[index],
          set: (value: number) => {
            data.commissions[index] = value;
          },
          getError: () => errors.commissions,
          setError: (value: Option<Array<string>>) => {
            errors.commissions = value;
          },
          getTainted: () => tainted.commissions,
          setTainted: (value: Option<boolean>) => {
            tainted.commissions = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: number) => {
          data.commissions.push(item);
        },
        remove: (index: number) => {
          data.commissions.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.commissions[a], data.commissions[b]] = [
            data.commissions[b],
            data.commissions[a],
          ];
        },
      },
    };
    function validate(): Result<
      Order,
      Array<{ field: string; message: string }>
    > {
      return Order.fromObject(data);
    }
    function reset(newOverrides?: Partial<Order>): void {
      data = { ...Order.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        account: Option.none(),
        stage: Option.none(),
        number: Option.none(),
        payments: Option.none(),
        opportunity: Option.none(),
        reference: Option.none(),
        leadSource: Option.none(),
        salesRep: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        isPosted: Option.none(),
        needsReview: Option.none(),
        actionItem: Option.none(),
        upsale: Option.none(),
        dateCreated: Option.none(),
        appointment: Option.none(),
        lastTechs: Option.none(),
        package: Option.none(),
        promotion: Option.none(),
        balance: Option.none(),
        due: Option.none(),
        total: Option.none(),
        site: Option.none(),
        billedItems: Option.none(),
        memo: Option.none(),
        discount: Option.none(),
        tip: Option.none(),
        commissions: Option.none(),
      };
      tainted = {
        id: Option.none(),
        account: Option.none(),
        stage: Option.none(),
        number: Option.none(),
        payments: Option.none(),
        opportunity: Option.none(),
        reference: Option.none(),
        leadSource: Option.none(),
        salesRep: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        isPosted: Option.none(),
        needsReview: Option.none(),
        actionItem: Option.none(),
        upsale: Option.none(),
        dateCreated: Option.none(),
        appointment: Option.none(),
        lastTechs: Option.none(),
        package: Option.none(),
        promotion: Option.none(),
        balance: Option.none(),
        due: Option.none(),
        total: Option.none(),
        site: Option.none(),
        billedItems: Option.none(),
        memo: Option.none(),
        discount: Option.none(),
        tip: Option.none(),
        commissions: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Order, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.account = formData.get("account") ?? "";
    {
      // Collect nested object fields with prefix "stage."
      const stageObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("stage.")) {
          const fieldName = key.slice("stage.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = stageObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.stage = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.stage = v;
          });
        } else {
          instance.stage = __result;
        }
      } else {
        instance.stage = __raw_stage;
      }
    }
    {
      const __raw_number = obj["number"];
      instance.number = __raw_number;
    }
    {
      const __raw_payments = obj["payments"];
      instance.payments = __raw_payments;
    }
    {
      const __raw_opportunity = obj["opportunity"];
      instance.opportunity = __raw_opportunity;
    }
    {
      const __raw_reference = obj["reference"];
      instance.reference = __raw_reference;
    }
    {
      const __raw_leadSource = obj["leadSource"];
      instance.leadSource = __raw_leadSource;
    }
    {
      const __raw_salesRep = obj["salesRep"];
      instance.salesRep = __raw_salesRep;
    }
    {
      const __raw_group = obj["group"];
      instance.group = __raw_group;
    }
    {
      const __raw_subgroup = obj["subgroup"];
      instance.subgroup = __raw_subgroup;
    }
    {
      const __raw_isPosted = obj["isPosted"];
      instance.isPosted = __raw_isPosted;
    }
    {
      const __raw_needsReview = obj["needsReview"];
      instance.needsReview = __raw_needsReview;
    }
    {
      const __raw_actionItem = obj["actionItem"];
      instance.actionItem = __raw_actionItem;
    }
    {
      const __raw_upsale = obj["upsale"];
      instance.upsale = __raw_upsale;
    }
    {
      const __raw_dateCreated = obj["dateCreated"];
      instance.dateCreated = __raw_dateCreated;
    }
    {
      const __raw_appointment = obj["appointment"];
      instance.appointment = __raw_appointment;
    }
    {
      const __raw_lastTechs = obj["lastTechs"];
      instance.lastTechs = __raw_lastTechs;
    }
    {
      const __raw_package = obj["package"];
      instance.package = __raw_package;
    }
    {
      const __raw_promotion = obj["promotion"];
      instance.promotion = __raw_promotion;
    }
    {
      const __raw_balance = obj["balance"];
      instance.balance = __raw_balance;
    }
    {
      const __raw_due = obj["due"];
      instance.due = __raw_due;
    }
    {
      const __raw_total = obj["total"];
      instance.total = __raw_total;
    }
    {
      const __raw_site = obj["site"];
      instance.site = __raw_site;
    }
    {
      const __raw_billedItems = obj["billedItems"];
      instance.billedItems = __raw_billedItems;
    }
    {
      const __raw_memo = obj["memo"];
      instance.memo = __raw_memo;
    }
    {
      const __raw_discount = obj["discount"];
      instance.discount = __raw_discount;
    }
    {
      const __raw_tip = obj["tip"];
      instance.tip = __raw_tip;
    }
    {
      const __raw_commissions = obj["commissions"];
      instance.commissions = __raw_commissions;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Order;
  }
  export function validateField<K extends keyof Order>(
    field: K,
    value: Order[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "opportunity": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "opportunity", message: "must not be empty" });
        }
        break;
      }
      case "reference": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "reference", message: "must not be empty" });
        }
        break;
      }
      case "leadSource": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "leadSource", message: "must not be empty" });
        }
        break;
      }
      case "group": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "group", message: "must not be empty" });
        }
        break;
      }
      case "subgroup": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "subgroup", message: "must not be empty" });
        }
        break;
      }
      case "actionItem": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "actionItem", message: "must not be empty" });
        }
        break;
      }
      case "memo": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "memo", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Order>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("opportunity" in partial && partial.opportunity !== undefined) {
      const __val = partial.opportunity as string;
      if (__val.length === 0) {
        errors.push({ field: "opportunity", message: "must not be empty" });
      }
    }
    if ("reference" in partial && partial.reference !== undefined) {
      const __val = partial.reference as string;
      if (__val.length === 0) {
        errors.push({ field: "reference", message: "must not be empty" });
      }
    }
    if ("leadSource" in partial && partial.leadSource !== undefined) {
      const __val = partial.leadSource as string;
      if (__val.length === 0) {
        errors.push({ field: "leadSource", message: "must not be empty" });
      }
    }
    if ("group" in partial && partial.group !== undefined) {
      const __val = partial.group as string;
      if (__val.length === 0) {
        errors.push({ field: "group", message: "must not be empty" });
      }
    }
    if ("subgroup" in partial && partial.subgroup !== undefined) {
      const __val = partial.subgroup as string;
      if (__val.length === 0) {
        errors.push({ field: "subgroup", message: "must not be empty" });
      }
    }
    if ("actionItem" in partial && partial.actionItem !== undefined) {
      const __val = partial.actionItem as string;
      if (__val.length === 0) {
        errors.push({ field: "actionItem", message: "must not be empty" });
      }
    }
    if ("memo" in partial && partial.memo !== undefined) {
      const __val = partial.memo as string;
      if (__val.length === 0) {
        errors.push({ field: "memo", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace Order {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    account: Option<Array<string>>;
    stage: Option<Array<string>>;
    number: Option<Array<string>>;
    payments: Option<Array<string>>;
    opportunity: Option<Array<string>>;
    reference: Option<Array<string>>;
    leadSource: Option<Array<string>>;
    salesRep: Option<Array<string>>;
    group: Option<Array<string>>;
    subgroup: Option<Array<string>>;
    isPosted: Option<Array<string>>;
    needsReview: Option<Array<string>>;
    actionItem: Option<Array<string>>;
    upsale: Option<Array<string>>;
    dateCreated: Option<Array<string>>;
    appointment: Option<Array<string>>;
    lastTechs: Option<Array<string>>;
    package: Option<Array<string>>;
    promotion: Option<Array<string>>;
    balance: Option<Array<string>>;
    due: Option<Array<string>>;
    total: Option<Array<string>>;
    site: Option<Array<string>>;
    billedItems: Option<Array<string>>;
    memo: Option<Array<string>>;
    discount: Option<Array<string>>;
    tip: Option<Array<string>>;
    commissions: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      account: Option<boolean>;
      stage: Option<boolean>;
      number: Option<boolean>;
      payments: Option<boolean>;
      opportunity: Option<boolean>;
      reference: Option<boolean>;
      leadSource: Option<boolean>;
      salesRep: Option<boolean>;
      group: Option<boolean>;
      subgroup: Option<boolean>;
      isPosted: Option<boolean>;
      needsReview: Option<boolean>;
      actionItem: Option<boolean>;
      upsale: Option<boolean>;
      dateCreated: Option<boolean>;
      appointment: Option<boolean>;
      lastTechs: Option<boolean>;
      package: Option<boolean>;
      promotion: Option<boolean>;
      balance: Option<boolean>;
      due: Option<boolean>;
      total: Option<boolean>;
      site: Option<boolean>;
      billedItems: Option<boolean>;
      memo: Option<boolean>;
      discount: Option<boolean>;
      tip: Option<boolean>;
      commissions: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly account: FieldController<string | Account>;
    readonly stage: FieldController<OrderStage>;
    readonly number: FieldController<number>;
    readonly payments: ArrayFieldController<string | Payment>;
    readonly opportunity: FieldController<string>;
    readonly reference: FieldController<string>;
    readonly leadSource: FieldController<string>;
    readonly salesRep: FieldController<string | Employee>;
    readonly group: FieldController<string>;
    readonly subgroup: FieldController<string>;
    readonly isPosted: FieldController<boolean>;
    readonly needsReview: FieldController<boolean>;
    readonly actionItem: FieldController<string>;
    readonly upsale: FieldController<number>;
    readonly dateCreated: FieldController<string>;
    readonly appointment: FieldController<string | Appointment>;
    readonly lastTechs: ArrayFieldController<string | Employee>;
    readonly package: FieldController<(string | Package)[] | null>;
    readonly promotion: FieldController<(string | Promotion)[] | null>;
    readonly balance: FieldController<number>;
    readonly due: FieldController<string>;
    readonly total: FieldController<number>;
    readonly site: FieldController<string | Site>;
    readonly billedItems: ArrayFieldController<BilledItem>;
    readonly memo: FieldController<string>;
    readonly discount: FieldController<number>;
    readonly tip: FieldController<number>;
    readonly commissions: ArrayFieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Order;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Order, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Order>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Order>,
  ): Gigaform {
    let data = $state({ ...Order.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      account: Option.none(),
      stage: Option.none(),
      number: Option.none(),
      payments: Option.none(),
      opportunity: Option.none(),
      reference: Option.none(),
      leadSource: Option.none(),
      salesRep: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      isPosted: Option.none(),
      needsReview: Option.none(),
      actionItem: Option.none(),
      upsale: Option.none(),
      dateCreated: Option.none(),
      appointment: Option.none(),
      lastTechs: Option.none(),
      package: Option.none(),
      promotion: Option.none(),
      balance: Option.none(),
      due: Option.none(),
      total: Option.none(),
      site: Option.none(),
      billedItems: Option.none(),
      memo: Option.none(),
      discount: Option.none(),
      tip: Option.none(),
      commissions: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      account: Option.none(),
      stage: Option.none(),
      number: Option.none(),
      payments: Option.none(),
      opportunity: Option.none(),
      reference: Option.none(),
      leadSource: Option.none(),
      salesRep: Option.none(),
      group: Option.none(),
      subgroup: Option.none(),
      isPosted: Option.none(),
      needsReview: Option.none(),
      actionItem: Option.none(),
      upsale: Option.none(),
      dateCreated: Option.none(),
      appointment: Option.none(),
      lastTechs: Option.none(),
      package: Option.none(),
      promotion: Option.none(),
      balance: Option.none(),
      due: Option.none(),
      total: Option.none(),
      site: Option.none(),
      billedItems: Option.none(),
      memo: Option.none(),
      discount: Option.none(),
      tip: Option.none(),
      commissions: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
        },
      },
      account: {
        path: ["account"] as const,
        name: "account",
        constraints: { required: true },
        label: "Account",
        get: () => data.account,
        set: (value: string | Account) => {
          data.account = value;
        },
        getError: () => errors.account,
        setError: (value: Option<Array<string>>) => {
          errors.account = value;
        },
        getTainted: () => tainted.account,
        setTainted: (value: Option<boolean>) => {
          tainted.account = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("account", data.account);
          return fieldErrors.map((e) => e.message);
        },
      },
      stage: {
        path: ["stage"] as const,
        name: "stage",
        constraints: { required: true },
        label: "Stage",
        get: () => data.stage,
        set: (value: OrderStage) => {
          data.stage = value;
        },
        getError: () => errors.stage,
        setError: (value: Option<Array<string>>) => {
          errors.stage = value;
        },
        getTainted: () => tainted.stage,
        setTainted: (value: Option<boolean>) => {
          tainted.stage = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("stage", data.stage);
          return fieldErrors.map((e) => e.message);
        },
      },
      number: {
        path: ["number"] as const,
        name: "number",
        constraints: { required: true },

        get: () => data.number,
        set: (value: number) => {
          data.number = value;
        },
        getError: () => errors.number,
        setError: (value: Option<Array<string>>) => {
          errors.number = value;
        },
        getTainted: () => tainted.number,
        setTainted: (value: Option<boolean>) => {
          tainted.number = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("number", data.number);
          return fieldErrors.map((e) => e.message);
        },
      },
      payments: {
        path: ["payments"] as const,
        name: "payments",
        constraints: { required: true },

        get: () => data.payments,
        set: (value: (string | Payment)[]) => {
          data.payments = value;
        },
        getError: () => errors.payments,
        setError: (value: Option<Array<string>>) => {
          errors.payments = value;
        },
        getTainted: () => tainted.payments,
        setTainted: (value: Option<boolean>) => {
          tainted.payments = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("payments", data.payments);
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["payments", index] as const,
          name: `payments.${index}`,
          constraints: { required: true },
          get: () => data.payments[index],
          set: (value: string | Payment) => {
            data.payments[index] = value;
          },
          getError: () => errors.payments,
          setError: (value: Option<Array<string>>) => {
            errors.payments = value;
          },
          getTainted: () => tainted.payments,
          setTainted: (value: Option<boolean>) => {
            tainted.payments = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Payment) => {
          data.payments.push(item);
        },
        remove: (index: number) => {
          data.payments.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.payments[a], data.payments[b]] = [
            data.payments[b],
            data.payments[a],
          ];
        },
      },
      opportunity: {
        path: ["opportunity"] as const,
        name: "opportunity",
        constraints: { required: true },
        label: "Opportunity",
        get: () => data.opportunity,
        set: (value: string) => {
          data.opportunity = value;
        },
        getError: () => errors.opportunity,
        setError: (value: Option<Array<string>>) => {
          errors.opportunity = value;
        },
        getTainted: () => tainted.opportunity,
        setTainted: (value: Option<boolean>) => {
          tainted.opportunity = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "opportunity",
            data.opportunity,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      reference: {
        path: ["reference"] as const,
        name: "reference",
        constraints: { required: true },
        label: "Reference",
        get: () => data.reference,
        set: (value: string) => {
          data.reference = value;
        },
        getError: () => errors.reference,
        setError: (value: Option<Array<string>>) => {
          errors.reference = value;
        },
        getTainted: () => tainted.reference,
        setTainted: (value: Option<boolean>) => {
          tainted.reference = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("reference", data.reference);
          return fieldErrors.map((e) => e.message);
        },
      },
      leadSource: {
        path: ["leadSource"] as const,
        name: "leadSource",
        constraints: { required: true },
        label: "Lead Source",
        get: () => data.leadSource,
        set: (value: string) => {
          data.leadSource = value;
        },
        getError: () => errors.leadSource,
        setError: (value: Option<Array<string>>) => {
          errors.leadSource = value;
        },
        getTainted: () => tainted.leadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.leadSource = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "leadSource",
            data.leadSource,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },
        label: "Sales Rep",
        get: () => data.salesRep,
        set: (value: string | Employee) => {
          data.salesRep = value;
        },
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("salesRep", data.salesRep);
          return fieldErrors.map((e) => e.message);
        },
      },
      group: {
        path: ["group"] as const,
        name: "group",
        constraints: { required: true },
        label: "Group",
        get: () => data.group,
        set: (value: string) => {
          data.group = value;
        },
        getError: () => errors.group,
        setError: (value: Option<Array<string>>) => {
          errors.group = value;
        },
        getTainted: () => tainted.group,
        setTainted: (value: Option<boolean>) => {
          tainted.group = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("group", data.group);
          return fieldErrors.map((e) => e.message);
        },
      },
      subgroup: {
        path: ["subgroup"] as const,
        name: "subgroup",
        constraints: { required: true },
        label: "Subgroup",
        get: () => data.subgroup,
        set: (value: string) => {
          data.subgroup = value;
        },
        getError: () => errors.subgroup,
        setError: (value: Option<Array<string>>) => {
          errors.subgroup = value;
        },
        getTainted: () => tainted.subgroup,
        setTainted: (value: Option<boolean>) => {
          tainted.subgroup = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("subgroup", data.subgroup);
          return fieldErrors.map((e) => e.message);
        },
      },
      isPosted: {
        path: ["isPosted"] as const,
        name: "isPosted",
        constraints: { required: true },
        label: "Posted",
        get: () => data.isPosted,
        set: (value: boolean) => {
          data.isPosted = value;
        },
        getError: () => errors.isPosted,
        setError: (value: Option<Array<string>>) => {
          errors.isPosted = value;
        },
        getTainted: () => tainted.isPosted,
        setTainted: (value: Option<boolean>) => {
          tainted.isPosted = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("isPosted", data.isPosted);
          return fieldErrors.map((e) => e.message);
        },
      },
      needsReview: {
        path: ["needsReview"] as const,
        name: "needsReview",
        constraints: { required: true },
        label: "Needs Review",
        get: () => data.needsReview,
        set: (value: boolean) => {
          data.needsReview = value;
        },
        getError: () => errors.needsReview,
        setError: (value: Option<Array<string>>) => {
          errors.needsReview = value;
        },
        getTainted: () => tainted.needsReview,
        setTainted: (value: Option<boolean>) => {
          tainted.needsReview = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "needsReview",
            data.needsReview,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      actionItem: {
        path: ["actionItem"] as const,
        name: "actionItem",
        constraints: { required: true },
        label: "Action Item",
        get: () => data.actionItem,
        set: (value: string) => {
          data.actionItem = value;
        },
        getError: () => errors.actionItem,
        setError: (value: Option<Array<string>>) => {
          errors.actionItem = value;
        },
        getTainted: () => tainted.actionItem,
        setTainted: (value: Option<boolean>) => {
          tainted.actionItem = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "actionItem",
            data.actionItem,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      upsale: {
        path: ["upsale"] as const,
        name: "upsale",
        constraints: { required: true },

        get: () => data.upsale,
        set: (value: number) => {
          data.upsale = value;
        },
        getError: () => errors.upsale,
        setError: (value: Option<Array<string>>) => {
          errors.upsale = value;
        },
        getTainted: () => tainted.upsale,
        setTainted: (value: Option<boolean>) => {
          tainted.upsale = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("upsale", data.upsale);
          return fieldErrors.map((e) => e.message);
        },
      },
      dateCreated: {
        path: ["dateCreated"] as const,
        name: "dateCreated",
        constraints: { required: true },

        get: () => data.dateCreated,
        set: (value: string) => {
          data.dateCreated = value;
        },
        getError: () => errors.dateCreated,
        setError: (value: Option<Array<string>>) => {
          errors.dateCreated = value;
        },
        getTainted: () => tainted.dateCreated,
        setTainted: (value: Option<boolean>) => {
          tainted.dateCreated = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "dateCreated",
            data.dateCreated,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      appointment: {
        path: ["appointment"] as const,
        name: "appointment",
        constraints: { required: true },
        label: "Appointment",
        get: () => data.appointment,
        set: (value: string | Appointment) => {
          data.appointment = value;
        },
        getError: () => errors.appointment,
        setError: (value: Option<Array<string>>) => {
          errors.appointment = value;
        },
        getTainted: () => tainted.appointment,
        setTainted: (value: Option<boolean>) => {
          tainted.appointment = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "appointment",
            data.appointment,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      lastTechs: {
        path: ["lastTechs"] as const,
        name: "lastTechs",
        constraints: { required: true },
        label: "Technicians",
        get: () => data.lastTechs,
        set: (value: (string | Employee)[]) => {
          data.lastTechs = value;
        },
        getError: () => errors.lastTechs,
        setError: (value: Option<Array<string>>) => {
          errors.lastTechs = value;
        },
        getTainted: () => tainted.lastTechs,
        setTainted: (value: Option<boolean>) => {
          tainted.lastTechs = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("lastTechs", data.lastTechs);
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["lastTechs", index] as const,
          name: `lastTechs.${index}`,
          constraints: { required: true },
          get: () => data.lastTechs[index],
          set: (value: string | Employee) => {
            data.lastTechs[index] = value;
          },
          getError: () => errors.lastTechs,
          setError: (value: Option<Array<string>>) => {
            errors.lastTechs = value;
          },
          getTainted: () => tainted.lastTechs,
          setTainted: (value: Option<boolean>) => {
            tainted.lastTechs = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string | Employee) => {
          data.lastTechs.push(item);
        },
        remove: (index: number) => {
          data.lastTechs.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.lastTechs[a], data.lastTechs[b]] = [
            data.lastTechs[b],
            data.lastTechs[a],
          ];
        },
      },
      package: {
        path: ["package"] as const,
        name: "package",
        constraints: { required: true },

        get: () => data.package,
        set: (value: (string | Package)[] | null) => {
          data.package = value;
        },
        getError: () => errors.package,
        setError: (value: Option<Array<string>>) => {
          errors.package = value;
        },
        getTainted: () => tainted.package,
        setTainted: (value: Option<boolean>) => {
          tainted.package = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("package", data.package);
          return fieldErrors.map((e) => e.message);
        },
      },
      promotion: {
        path: ["promotion"] as const,
        name: "promotion",
        constraints: { required: true },

        get: () => data.promotion,
        set: (value: (string | Promotion)[] | null) => {
          data.promotion = value;
        },
        getError: () => errors.promotion,
        setError: (value: Option<Array<string>>) => {
          errors.promotion = value;
        },
        getTainted: () => tainted.promotion,
        setTainted: (value: Option<boolean>) => {
          tainted.promotion = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("promotion", data.promotion);
          return fieldErrors.map((e) => e.message);
        },
      },
      balance: {
        path: ["balance"] as const,
        name: "balance",
        constraints: { required: true },

        get: () => data.balance,
        set: (value: number) => {
          data.balance = value;
        },
        getError: () => errors.balance,
        setError: (value: Option<Array<string>>) => {
          errors.balance = value;
        },
        getTainted: () => tainted.balance,
        setTainted: (value: Option<boolean>) => {
          tainted.balance = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("balance", data.balance);
          return fieldErrors.map((e) => e.message);
        },
      },
      due: {
        path: ["due"] as const,
        name: "due",
        constraints: { required: true },
        label: "Due",
        get: () => data.due,
        set: (value: string) => {
          data.due = value;
        },
        getError: () => errors.due,
        setError: (value: Option<Array<string>>) => {
          errors.due = value;
        },
        getTainted: () => tainted.due,
        setTainted: (value: Option<boolean>) => {
          tainted.due = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("due", data.due);
          return fieldErrors.map((e) => e.message);
        },
      },
      total: {
        path: ["total"] as const,
        name: "total",
        constraints: { required: true },

        get: () => data.total,
        set: (value: number) => {
          data.total = value;
        },
        getError: () => errors.total,
        setError: (value: Option<Array<string>>) => {
          errors.total = value;
        },
        getTainted: () => tainted.total,
        setTainted: (value: Option<boolean>) => {
          tainted.total = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("total", data.total);
          return fieldErrors.map((e) => e.message);
        },
      },
      site: {
        path: ["site"] as const,
        name: "site",
        constraints: { required: true },
        label: "Site",
        get: () => data.site,
        set: (value: string | Site) => {
          data.site = value;
        },
        getError: () => errors.site,
        setError: (value: Option<Array<string>>) => {
          errors.site = value;
        },
        getTainted: () => tainted.site,
        setTainted: (value: Option<boolean>) => {
          tainted.site = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("site", data.site);
          return fieldErrors.map((e) => e.message);
        },
      },
      billedItems: {
        path: ["billedItems"] as const,
        name: "billedItems",
        constraints: { required: true },

        get: () => data.billedItems,
        set: (value: BilledItem[]) => {
          data.billedItems = value;
        },
        getError: () => errors.billedItems,
        setError: (value: Option<Array<string>>) => {
          errors.billedItems = value;
        },
        getTainted: () => tainted.billedItems,
        setTainted: (value: Option<boolean>) => {
          tainted.billedItems = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "billedItems",
            data.billedItems,
          );
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["billedItems", index] as const,
          name: `billedItems.${index}`,
          constraints: { required: true },
          get: () => data.billedItems[index],
          set: (value: BilledItem) => {
            data.billedItems[index] = value;
          },
          getError: () => errors.billedItems,
          setError: (value: Option<Array<string>>) => {
            errors.billedItems = value;
          },
          getTainted: () => tainted.billedItems,
          setTainted: (value: Option<boolean>) => {
            tainted.billedItems = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: BilledItem) => {
          data.billedItems.push(item);
        },
        remove: (index: number) => {
          data.billedItems.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.billedItems[a], data.billedItems[b]] = [
            data.billedItems[b],
            data.billedItems[a],
          ];
        },
      },
      memo: {
        path: ["memo"] as const,
        name: "memo",
        constraints: { required: true },
        label: "Memo",
        get: () => data.memo,
        set: (value: string) => {
          data.memo = value;
        },
        getError: () => errors.memo,
        setError: (value: Option<Array<string>>) => {
          errors.memo = value;
        },
        getTainted: () => tainted.memo,
        setTainted: (value: Option<boolean>) => {
          tainted.memo = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("memo", data.memo);
          return fieldErrors.map((e) => e.message);
        },
      },
      discount: {
        path: ["discount"] as const,
        name: "discount",
        constraints: { required: true },

        get: () => data.discount,
        set: (value: number) => {
          data.discount = value;
        },
        getError: () => errors.discount,
        setError: (value: Option<Array<string>>) => {
          errors.discount = value;
        },
        getTainted: () => tainted.discount,
        setTainted: (value: Option<boolean>) => {
          tainted.discount = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("discount", data.discount);
          return fieldErrors.map((e) => e.message);
        },
      },
      tip: {
        path: ["tip"] as const,
        name: "tip",
        constraints: { required: true },

        get: () => data.tip,
        set: (value: number) => {
          data.tip = value;
        },
        getError: () => errors.tip,
        setError: (value: Option<Array<string>>) => {
          errors.tip = value;
        },
        getTainted: () => tainted.tip,
        setTainted: (value: Option<boolean>) => {
          tainted.tip = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField("tip", data.tip);
          return fieldErrors.map((e) => e.message);
        },
      },
      commissions: {
        path: ["commissions"] as const,
        name: "commissions",
        constraints: { required: true },

        get: () => data.commissions,
        set: (value: number[]) => {
          data.commissions = value;
        },
        getError: () => errors.commissions,
        setError: (value: Option<Array<string>>) => {
          errors.commissions = value;
        },
        getTainted: () => tainted.commissions,
        setTainted: (value: Option<boolean>) => {
          tainted.commissions = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Order.validateField(
            "commissions",
            data.commissions,
          );
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["commissions", index] as const,
          name: `commissions.${index}`,
          constraints: { required: true },
          get: () => data.commissions[index],
          set: (value: number) => {
            data.commissions[index] = value;
          },
          getError: () => errors.commissions,
          setError: (value: Option<Array<string>>) => {
            errors.commissions = value;
          },
          getTainted: () => tainted.commissions,
          setTainted: (value: Option<boolean>) => {
            tainted.commissions = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: number) => {
          data.commissions.push(item);
        },
        remove: (index: number) => {
          data.commissions.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.commissions[a], data.commissions[b]] = [
            data.commissions[b],
            data.commissions[a],
          ];
        },
      },
    };
    function validate(): Result<
      Order,
      Array<{ field: string; message: string }>
    > {
      return Order.fromObject(data);
    }
    function reset(newOverrides?: Partial<Order>): void {
      data = { ...Order.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        account: Option.none(),
        stage: Option.none(),
        number: Option.none(),
        payments: Option.none(),
        opportunity: Option.none(),
        reference: Option.none(),
        leadSource: Option.none(),
        salesRep: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        isPosted: Option.none(),
        needsReview: Option.none(),
        actionItem: Option.none(),
        upsale: Option.none(),
        dateCreated: Option.none(),
        appointment: Option.none(),
        lastTechs: Option.none(),
        package: Option.none(),
        promotion: Option.none(),
        balance: Option.none(),
        due: Option.none(),
        total: Option.none(),
        site: Option.none(),
        billedItems: Option.none(),
        memo: Option.none(),
        discount: Option.none(),
        tip: Option.none(),
        commissions: Option.none(),
      };
      tainted = {
        id: Option.none(),
        account: Option.none(),
        stage: Option.none(),
        number: Option.none(),
        payments: Option.none(),
        opportunity: Option.none(),
        reference: Option.none(),
        leadSource: Option.none(),
        salesRep: Option.none(),
        group: Option.none(),
        subgroup: Option.none(),
        isPosted: Option.none(),
        needsReview: Option.none(),
        actionItem: Option.none(),
        upsale: Option.none(),
        dateCreated: Option.none(),
        appointment: Option.none(),
        lastTechs: Option.none(),
        package: Option.none(),
        promotion: Option.none(),
        balance: Option.none(),
        due: Option.none(),
        total: Option.none(),
        site: Option.none(),
        billedItems: Option.none(),
        memo: Option.none(),
        discount: Option.none(),
        tip: Option.none(),
        commissions: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Order, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.account = formData.get("account") ?? "";
    {
      // Collect nested object fields with prefix "stage."
      const stageObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("stage.")) {
          const fieldName = key.slice("stage.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = stageObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.stage = stageObj;
    }
    {
      const numberStr = formData.get("number");
      obj.number = numberStr ? parseFloat(numberStr as string) : 0;
      if (obj.number !== undefined && isNaN(obj.number as number))
        obj.number = 0;
    }
    {
      // Collect array items from indexed form fields
      const paymentsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("payments." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("payments." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("payments." + idx + ".")) {
              const fieldName = key.slice(
                "payments.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          paymentsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.payments = paymentsItems;
    }
    obj.opportunity = formData.get("opportunity") ?? "";
    obj.reference = formData.get("reference") ?? "";
    obj.leadSource = formData.get("leadSource") ?? "";
    obj.salesRep = formData.get("salesRep") ?? "";
    obj.group = formData.get("group") ?? "";
    obj.subgroup = formData.get("subgroup") ?? "";
    {
      const isPostedVal = formData.get("isPosted");
      obj.isPosted =
        isPostedVal === "true" || isPostedVal === "on" || isPostedVal === "1";
    }
    {
      const needsReviewVal = formData.get("needsReview");
      obj.needsReview =
        needsReviewVal === "true" ||
        needsReviewVal === "on" ||
        needsReviewVal === "1";
    }
    obj.actionItem = formData.get("actionItem") ?? "";
    {
      const upsaleStr = formData.get("upsale");
      obj.upsale = upsaleStr ? parseFloat(upsaleStr as string) : 0;
      if (obj.upsale !== undefined && isNaN(obj.upsale as number))
        obj.upsale = 0;
    }
    obj.dateCreated = formData.get("dateCreated") ?? "";
    obj.appointment = formData.get("appointment") ?? "";
    {
      // Collect array items from indexed form fields
      const lastTechsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("lastTechs." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("lastTechs." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("lastTechs." + idx + ".")) {
              const fieldName = key.slice(
                "lastTechs.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          lastTechsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.lastTechs = lastTechsItems;
    }
    obj.package = formData.get("package") ?? "";
    obj.promotion = formData.get("promotion") ?? "";
    {
      const balanceStr = formData.get("balance");
      obj.balance = balanceStr ? parseFloat(balanceStr as string) : 0;
      if (obj.balance !== undefined && isNaN(obj.balance as number))
        obj.balance = 0;
    }
    obj.due = formData.get("due") ?? "";
    {
      const totalStr = formData.get("total");
      obj.total = totalStr ? parseFloat(totalStr as string) : 0;
      if (obj.total !== undefined && isNaN(obj.total as number)) obj.total = 0;
    }
    obj.site = formData.get("site") ?? "";
    {
      // Collect array items from indexed form fields
      const billedItemsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("billedItems." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("billedItems." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("billedItems." + idx + ".")) {
              const fieldName = key.slice(
                "billedItems.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          billedItemsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.billedItems = billedItemsItems;
    }
    obj.memo = formData.get("memo") ?? "";
    {
      const discountStr = formData.get("discount");
      obj.discount = discountStr ? parseFloat(discountStr as string) : 0;
      if (obj.discount !== undefined && isNaN(obj.discount as number))
        obj.discount = 0;
    }
    {
      const tipStr = formData.get("tip");
      obj.tip = tipStr ? parseFloat(tipStr as string) : 0;
      if (obj.tip !== undefined && isNaN(obj.tip as number)) obj.tip = 0;
    }
    obj.commissions = formData
      .getAll("commissions")
      .map((v) => parseFloat(v as string))
      .filter((n) => !isNaN(n));
    return Order.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Commented {
  comment: string;
  replyTo: string | null;
}

export namespace Commented {
  export function defaultValue(): Commented {
    return { comment: "", replyTo: null } as Commented;
  }
}

export namespace Commented {
  export function toStringifiedJSON(self: Commented): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Commented): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Commented,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Commented", __id };
    result["comment"] = self.comment;
    if (self.replyTo !== null) {
      result["replyTo"] =
        typeof (self.replyTo as any)?.__serialize === "function"
          ? (self.replyTo as any).__serialize(ctx)
          : self.replyTo;
    } else {
      result["replyTo"] = null;
    }
    return result;
  }
}

export namespace Commented {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Commented, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Commented, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Commented.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Commented | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Commented.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("comment" in obj)) {
      errors.push({ field: "comment", message: "missing required field" });
    }
    if (!("replyTo" in obj)) {
      errors.push({ field: "replyTo", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_comment = obj["comment"];
      instance.comment = __raw_comment;
    }
    {
      const __raw_replyTo = obj["replyTo"];
      instance.replyTo = __raw_replyTo;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Commented;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Commented>(
    field: K,
    value: Commented[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "comment": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "comment", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Commented>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("comment" in partial && partial.comment !== undefined) {
      const __val = partial.comment as string;
      if (__val.length === 0) {
        errors.push({ field: "comment", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Commented {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    comment: Option<Array<string>>;
    replyTo: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { comment: Option<boolean>; replyTo: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly comment: FieldController<string>;
    readonly replyTo: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Commented;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Commented, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Commented>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Commented>,
  ): Gigaform {
    let data = $state({ ...Commented.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      comment: Option.none(),
      replyTo: Option.none(),
    });
    let tainted = $state<Tainted>({
      comment: Option.none(),
      replyTo: Option.none(),
    });
    const fields: FieldControllers = {
      comment: {
        path: ["comment"] as const,
        name: "comment",
        constraints: { required: true },

        get: () => data.comment,
        set: (value: string) => {
          data.comment = value;
        },
        getError: () => errors.comment,
        setError: (value: Option<Array<string>>) => {
          errors.comment = value;
        },
        getTainted: () => tainted.comment,
        setTainted: (value: Option<boolean>) => {
          tainted.comment = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Commented.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "comment")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Commented.validateField("comment", data.comment);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      replyTo: {
        path: ["replyTo"] as const,
        name: "replyTo",
        constraints: { required: true },

        get: () => data.replyTo,
        set: (value: string | null) => {
          data.replyTo = value;
        },
        getError: () => errors.replyTo,
        setError: (value: Option<Array<string>>) => {
          errors.replyTo = value;
        },
        getTainted: () => tainted.replyTo,
        setTainted: (value: Option<boolean>) => {
          tainted.replyTo = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Commented.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "replyTo")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Commented.validateField("replyTo", data.replyTo);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Commented,
      Array<{ field: string; message: string }>
    > {
      return Commented.fromObject(data);
    }
    function reset(newOverrides?: Partial<Commented>): void {
      data = { ...Commented.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        comment: Option.none(),
        replyTo: Option.none(),
      };
      tainted = { comment: Option.none(), replyTo: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Commented, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.comment = formData.get("comment") ?? "";
    obj.replyTo = formData.get("replyTo") ?? "";
    return Commented.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Custom {
  mappings: DirectionHue[];
}

export namespace Custom {
  export function defaultValue(): Custom {
    return { mappings: [] } as Custom;
  }
}

export namespace Custom {
  export function toStringifiedJSON(self: Custom): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Custom): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Custom,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Custom", __id };
    result["mappings"] = self.mappings.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    return result;
  }
}

export namespace Custom {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Custom, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Custom, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Custom.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Custom | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Custom.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("mappings" in obj)) {
      errors.push({ field: "mappings", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_mappings = obj["mappings"];
      instance.mappings = __raw_mappings;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Custom;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Custom>(
    field: K,
    value: Custom[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Custom>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Custom {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    mappings: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { mappings: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly mappings: ArrayFieldController<DirectionHue>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Custom;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Custom, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Custom>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Custom>,
  ): Gigaform {
    let data = $state({ ...Custom.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      mappings: Option.none(),
    });
    let tainted = $state<Tainted>({ mappings: Option.none() });
    const fields: FieldControllers = {
      mappings: {
        path: ["mappings"] as const,
        name: "mappings",
        constraints: { required: true },

        get: () => data.mappings,
        set: (value: DirectionHue[]) => {
          data.mappings = value;
        },
        getError: () => errors.mappings,
        setError: (value: Option<Array<string>>) => {
          errors.mappings = value;
        },
        getTainted: () => tainted.mappings,
        setTainted: (value: Option<boolean>) => {
          tainted.mappings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Custom.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "mappings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Custom.validateField("mappings", data.mappings);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["mappings", index] as const,
          name: `mappings.${index}`,
          constraints: { required: true },
          get: () => data.mappings[index],
          set: (value: DirectionHue) => {
            data.mappings[index] = value;
          },
          getError: () => errors.mappings,
          setError: (value: Option<Array<string>>) => {
            errors.mappings = value;
          },
          getTainted: () => tainted.mappings,
          setTainted: (value: Option<boolean>) => {
            tainted.mappings = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: DirectionHue) => {
          data.mappings.push(item);
        },
        remove: (index: number) => {
          data.mappings.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.mappings[a], data.mappings[b]] = [
            data.mappings[b],
            data.mappings[a],
          ];
        },
      },
    };
    function validate(): Result<
      Custom,
      Array<{ field: string; message: string }>
    > {
      return Custom.fromObject(data);
    }
    function reset(newOverrides?: Partial<Custom>): void {
      data = { ...Custom.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), mappings: Option.none() };
      tainted = { mappings: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Custom, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect array items from indexed form fields
      const mappingsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("mappings." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("mappings." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("mappings." + idx + ".")) {
              const fieldName = key.slice(
                "mappings.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          mappingsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.mappings = mappingsItems;
    }
    return Custom.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Colors {
  main: string;

  hover: string;

  active: string;
}

export namespace Colors {
  export function defaultValue(): Colors {
    return { main: "", hover: "", active: "" } as Colors;
  }
}

export namespace Colors {
  export function toStringifiedJSON(self: Colors): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Colors): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Colors,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Colors", __id };
    result["main"] = self.main;
    result["hover"] = self.hover;
    result["active"] = self.active;
    return result;
  }
}

export namespace Colors {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Colors, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Colors, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Colors.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Colors | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Colors.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("main" in obj)) {
      errors.push({ field: "main", message: "missing required field" });
    }
    if (!("hover" in obj)) {
      errors.push({ field: "hover", message: "missing required field" });
    }
    if (!("active" in obj)) {
      errors.push({ field: "active", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_main = obj["main"];
      instance.main = __raw_main;
    }
    {
      const __raw_hover = obj["hover"];
      instance.hover = __raw_hover;
    }
    {
      const __raw_active = obj["active"];
      instance.active = __raw_active;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Colors;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Colors>(
    field: K,
    value: Colors[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "main": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "main", message: "must not be empty" });
        }
        break;
      }
      case "hover": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "hover", message: "must not be empty" });
        }
        break;
      }
      case "active": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "active", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Colors>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("main" in partial && partial.main !== undefined) {
      const __val = partial.main as string;
      if (__val.length === 0) {
        errors.push({ field: "main", message: "must not be empty" });
      }
    }
    if ("hover" in partial && partial.hover !== undefined) {
      const __val = partial.hover as string;
      if (__val.length === 0) {
        errors.push({ field: "hover", message: "must not be empty" });
      }
    }
    if ("active" in partial && partial.active !== undefined) {
      const __val = partial.active as string;
      if (__val.length === 0) {
        errors.push({ field: "active", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Colors {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    main: Option<Array<string>>;
    hover: Option<Array<string>>;
    active: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { main: Option<boolean>; hover: Option<boolean>; active: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly main: FieldController<string>;
    readonly hover: FieldController<string>;
    readonly active: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Colors;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Colors, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Colors>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Colors>,
  ): Gigaform {
    let data = $state({ ...Colors.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      main: Option.none(),
      hover: Option.none(),
      active: Option.none(),
    });
    let tainted = $state<Tainted>({
      main: Option.none(),
      hover: Option.none(),
      active: Option.none(),
    });
    const fields: FieldControllers = {
      main: {
        path: ["main"] as const,
        name: "main",
        constraints: { required: true },

        get: () => data.main,
        set: (value: string) => {
          data.main = value;
        },
        getError: () => errors.main,
        setError: (value: Option<Array<string>>) => {
          errors.main = value;
        },
        getTainted: () => tainted.main,
        setTainted: (value: Option<boolean>) => {
          tainted.main = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Colors.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "main")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Colors.validateField("main", data.main);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hover: {
        path: ["hover"] as const,
        name: "hover",
        constraints: { required: true },

        get: () => data.hover,
        set: (value: string) => {
          data.hover = value;
        },
        getError: () => errors.hover,
        setError: (value: Option<Array<string>>) => {
          errors.hover = value;
        },
        getTainted: () => tainted.hover,
        setTainted: (value: Option<boolean>) => {
          tainted.hover = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Colors.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hover")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Colors.validateField("hover", data.hover);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },

        get: () => data.active,
        set: (value: string) => {
          data.active = value;
        },
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Colors.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "active")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Colors.validateField("active", data.active);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Colors,
      Array<{ field: string; message: string }>
    > {
      return Colors.fromObject(data);
    }
    function reset(newOverrides?: Partial<Colors>): void {
      data = { ...Colors.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        main: Option.none(),
        hover: Option.none(),
        active: Option.none(),
      };
      tainted = {
        main: Option.none(),
        hover: Option.none(),
        active: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Colors, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.main = formData.get("main") ?? "";
    obj.hover = formData.get("hover") ?? "";
    obj.active = formData.get("active") ?? "";
    return Colors.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface ProductDefaults {
  price: number;

  description: string;
}

export namespace ProductDefaults {
  export function defaultValue(): ProductDefaults {
    return { price: 0, description: "" } as ProductDefaults;
  }
}

export namespace ProductDefaults {
  export function toStringifiedJSON(self: ProductDefaults): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: ProductDefaults): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: ProductDefaults,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "ProductDefaults", __id };
    result["price"] = self.price;
    result["description"] = self.description;
    return result;
  }
}

export namespace ProductDefaults {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<ProductDefaults, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<ProductDefaults, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "ProductDefaults.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): ProductDefaults | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "ProductDefaults.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("price" in obj)) {
      errors.push({ field: "price", message: "missing required field" });
    }
    if (!("description" in obj)) {
      errors.push({ field: "description", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_price = obj["price"];
      instance.price = __raw_price;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as ProductDefaults;
  }
<<<<<<< Updated upstream
}

export namespace ProductDefaults {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    price: Option<Array<string>>;
    description: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { price: Option<boolean>; description: Option<boolean> };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ProductDefaults;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ProductDefaults,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ProductDefaults>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ProductDefaults>,
  ): Gigaform {
    let data = $state({ ...ProductDefaults.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      price: Option.none(),
      description: Option.none(),
    });
    let tainted = $state<Tainted>({
      price: Option.none(),
      description: Option.none(),
    });
    const fields: FieldControllers = {
      price: {
        path: ["price"] as const,
        name: "price",
        constraints: { required: true },

=======
  export function validateField<K extends keyof ProductDefaults>(
    field: K,
    value: ProductDefaults[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "description": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "description", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<ProductDefaults>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("description" in partial && partial.description !== undefined) {
      const __val = partial.description as string;
      if (__val.length === 0) {
        errors.push({ field: "description", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace ProductDefaults {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    price: Option<Array<string>>;
    description: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { price: Option<boolean>; description: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly price: FieldController<number>;
    readonly description: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: ProductDefaults;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      ProductDefaults,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<ProductDefaults>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<ProductDefaults>,
  ): Gigaform {
    let data = $state({ ...ProductDefaults.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      price: Option.none(),
      description: Option.none(),
    });
    let tainted = $state<Tainted>({
      price: Option.none(),
      description: Option.none(),
    });
    const fields: FieldControllers = {
      price: {
        path: ["price"] as const,
        name: "price",
        constraints: { required: true },
        label: "Price",
>>>>>>> Stashed changes
        get: () => data.price,
        set: (value: number) => {
          data.price = value;
        },
        getError: () => errors.price,
        setError: (value: Option<Array<string>>) => {
          errors.price = value;
        },
        getTainted: () => tainted.price,
        setTainted: (value: Option<boolean>) => {
          tainted.price = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = ProductDefaults.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "price")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = ProductDefaults.validateField(
            "price",
            data.price,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Description",
>>>>>>> Stashed changes
        get: () => data.description,
        set: (value: string) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = ProductDefaults.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "description")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = ProductDefaults.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      ProductDefaults,
      Array<{ field: string; message: string }>
    > {
      return ProductDefaults.fromObject(data);
    }
    function reset(newOverrides?: Partial<ProductDefaults>): void {
      data = { ...ProductDefaults.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        price: Option.none(),
        description: Option.none(),
      };
      tainted = { price: Option.none(), description: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<ProductDefaults, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const priceStr = formData.get("price");
      obj.price = priceStr ? parseFloat(priceStr as string) : 0;
      if (obj.price !== undefined && isNaN(obj.price as number)) obj.price = 0;
    }
    obj.description = formData.get("description") ?? "";
    return ProductDefaults.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Viewed {
  durationSeconds: number | null;
  source: string | null;
}

export namespace Viewed {
  export function defaultValue(): Viewed {
    return { durationSeconds: null, source: null } as Viewed;
  }
}

export namespace Viewed {
  export function toStringifiedJSON(self: Viewed): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Viewed): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Viewed,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Viewed", __id };
    if (self.durationSeconds !== null) {
      result["durationSeconds"] =
        typeof (self.durationSeconds as any)?.__serialize === "function"
          ? (self.durationSeconds as any).__serialize(ctx)
          : self.durationSeconds;
    } else {
      result["durationSeconds"] = null;
    }
    if (self.source !== null) {
      result["source"] =
        typeof (self.source as any)?.__serialize === "function"
          ? (self.source as any).__serialize(ctx)
          : self.source;
    } else {
      result["source"] = null;
    }
    return result;
  }
}

export namespace Viewed {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Viewed, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Viewed, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Viewed.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Viewed | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Viewed.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("durationSeconds" in obj)) {
      errors.push({
        field: "durationSeconds",
        message: "missing required field",
      });
    }
    if (!("source" in obj)) {
      errors.push({ field: "source", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_durationSeconds = obj["durationSeconds"];
      instance.durationSeconds = __raw_durationSeconds;
    }
    {
      const __raw_source = obj["source"];
      instance.source = __raw_source;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Viewed;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Viewed>(
    field: K,
    value: Viewed[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Viewed>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Viewed {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    durationSeconds: Option<Array<string>>;
    source: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { durationSeconds: Option<boolean>; source: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly durationSeconds: FieldController<number | null>;
    readonly source: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Viewed;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Viewed, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Viewed>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Viewed>,
  ): Gigaform {
    let data = $state({ ...Viewed.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      durationSeconds: Option.none(),
      source: Option.none(),
    });
    let tainted = $state<Tainted>({
      durationSeconds: Option.none(),
      source: Option.none(),
    });
    const fields: FieldControllers = {
      durationSeconds: {
        path: ["durationSeconds"] as const,
        name: "durationSeconds",
        constraints: { required: true },

        get: () => data.durationSeconds,
        set: (value: number | null) => {
          data.durationSeconds = value;
        },
        getError: () => errors.durationSeconds,
        setError: (value: Option<Array<string>>) => {
          errors.durationSeconds = value;
        },
        getTainted: () => tainted.durationSeconds,
        setTainted: (value: Option<boolean>) => {
          tainted.durationSeconds = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Viewed.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "durationSeconds")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Viewed.validateField(
            "durationSeconds",
            data.durationSeconds,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      source: {
        path: ["source"] as const,
        name: "source",
        constraints: { required: true },

        get: () => data.source,
        set: (value: string | null) => {
          data.source = value;
        },
        getError: () => errors.source,
        setError: (value: Option<Array<string>>) => {
          errors.source = value;
        },
        getTainted: () => tainted.source,
        setTainted: (value: Option<boolean>) => {
          tainted.source = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Viewed.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "source")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Viewed.validateField("source", data.source);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Viewed,
      Array<{ field: string; message: string }>
    > {
      return Viewed.fromObject(data);
    }
    function reset(newOverrides?: Partial<Viewed>): void {
      data = { ...Viewed.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        durationSeconds: Option.none(),
        source: Option.none(),
      };
      tainted = { durationSeconds: Option.none(), source: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Viewed, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const durationSecondsStr = formData.get("durationSeconds");
      obj.durationSeconds = durationSecondsStr
        ? parseFloat(durationSecondsStr as string)
        : 0;
      if (
        obj.durationSeconds !== undefined &&
        isNaN(obj.durationSeconds as number)
      )
        obj.durationSeconds = 0;
    }
    obj.source = formData.get("source") ?? "";
    return Viewed.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface WeeklyRecurrenceRule {
  quantityOfWeeks: number;
  weekdays: Weekday[];
}

export namespace WeeklyRecurrenceRule {
  export function defaultValue(): WeeklyRecurrenceRule {
    return { quantityOfWeeks: 0, weekdays: [] } as WeeklyRecurrenceRule;
  }
}

export namespace WeeklyRecurrenceRule {
  export function toStringifiedJSON(self: WeeklyRecurrenceRule): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(
    self: WeeklyRecurrenceRule,
  ): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: WeeklyRecurrenceRule,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = {
      __type: "WeeklyRecurrenceRule",
      __id,
    };
    result["quantityOfWeeks"] = self.quantityOfWeeks;
    result["weekdays"] = self.weekdays.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    return result;
  }
}

export namespace WeeklyRecurrenceRule {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<WeeklyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<WeeklyRecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "WeeklyRecurrenceRule.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): WeeklyRecurrenceRule | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "WeeklyRecurrenceRule.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("quantityOfWeeks" in obj)) {
      errors.push({
        field: "quantityOfWeeks",
        message: "missing required field",
      });
    }
    if (!("weekdays" in obj)) {
      errors.push({ field: "weekdays", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_quantityOfWeeks = obj["quantityOfWeeks"];
      instance.quantityOfWeeks = __raw_quantityOfWeeks;
    }
    {
      const __raw_weekdays = obj["weekdays"];
      instance.weekdays = __raw_weekdays;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as WeeklyRecurrenceRule;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof WeeklyRecurrenceRule>(
    field: K,
    value: WeeklyRecurrenceRule[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<WeeklyRecurrenceRule>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace WeeklyRecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    quantityOfWeeks: Option<Array<string>>;
    weekdays: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { quantityOfWeeks: Option<boolean>; weekdays: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly quantityOfWeeks: FieldController<number>;
    readonly weekdays: ArrayFieldController<Weekday>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: WeeklyRecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      WeeklyRecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<WeeklyRecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<WeeklyRecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...WeeklyRecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      quantityOfWeeks: Option.none(),
      weekdays: Option.none(),
    });
    let tainted = $state<Tainted>({
      quantityOfWeeks: Option.none(),
      weekdays: Option.none(),
    });
    const fields: FieldControllers = {
      quantityOfWeeks: {
        path: ["quantityOfWeeks"] as const,
        name: "quantityOfWeeks",
        constraints: { required: true },

        get: () => data.quantityOfWeeks,
        set: (value: number) => {
          data.quantityOfWeeks = value;
        },
        getError: () => errors.quantityOfWeeks,
        setError: (value: Option<Array<string>>) => {
          errors.quantityOfWeeks = value;
        },
        getTainted: () => tainted.quantityOfWeeks,
        setTainted: (value: Option<boolean>) => {
          tainted.quantityOfWeeks = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = WeeklyRecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "quantityOfWeeks")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = WeeklyRecurrenceRule.validateField(
            "quantityOfWeeks",
            data.quantityOfWeeks,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      weekdays: {
        path: ["weekdays"] as const,
        name: "weekdays",
        constraints: { required: true },

        get: () => data.weekdays,
        set: (value: Weekday[]) => {
          data.weekdays = value;
        },
        getError: () => errors.weekdays,
        setError: (value: Option<Array<string>>) => {
          errors.weekdays = value;
        },
        getTainted: () => tainted.weekdays,
        setTainted: (value: Option<boolean>) => {
          tainted.weekdays = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = WeeklyRecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "weekdays")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = WeeklyRecurrenceRule.validateField(
            "weekdays",
            data.weekdays,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["weekdays", index] as const,
          name: `weekdays.${index}`,
          constraints: { required: true },
          get: () => data.weekdays[index],
          set: (value: Weekday) => {
            data.weekdays[index] = value;
          },
          getError: () => errors.weekdays,
          setError: (value: Option<Array<string>>) => {
            errors.weekdays = value;
          },
          getTainted: () => tainted.weekdays,
          setTainted: (value: Option<boolean>) => {
            tainted.weekdays = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Weekday) => {
          data.weekdays.push(item);
        },
        remove: (index: number) => {
          data.weekdays.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.weekdays[a], data.weekdays[b]] = [
            data.weekdays[b],
            data.weekdays[a],
          ];
        },
      },
    };
    function validate(): Result<
      WeeklyRecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return WeeklyRecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<WeeklyRecurrenceRule>): void {
      data = { ...WeeklyRecurrenceRule.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        quantityOfWeeks: Option.none(),
        weekdays: Option.none(),
      };
      tainted = { quantityOfWeeks: Option.none(), weekdays: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<WeeklyRecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const quantityOfWeeksStr = formData.get("quantityOfWeeks");
      obj.quantityOfWeeks = quantityOfWeeksStr
        ? parseFloat(quantityOfWeeksStr as string)
        : 0;
      if (
        obj.quantityOfWeeks !== undefined &&
        isNaN(obj.quantityOfWeeks as number)
      )
        obj.quantityOfWeeks = 0;
    }
    {
      // Collect array items from indexed form fields
      const weekdaysItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("weekdays." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("weekdays." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("weekdays." + idx + ".")) {
              const fieldName = key.slice(
                "weekdays.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          weekdaysItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.weekdays = weekdaysItems;
    }
    return WeeklyRecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Paid {
  amount: number | null;
  currency: string | null;
  paymentMethod: string | null;
}

export namespace Paid {
  export function defaultValue(): Paid {
    return { amount: null, currency: null, paymentMethod: null } as Paid;
  }
}

export namespace Paid {
  export function toStringifiedJSON(self: Paid): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Paid): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Paid,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Paid", __id };
    if (self.amount !== null) {
      result["amount"] =
        typeof (self.amount as any)?.__serialize === "function"
          ? (self.amount as any).__serialize(ctx)
          : self.amount;
    } else {
      result["amount"] = null;
    }
    if (self.currency !== null) {
      result["currency"] =
        typeof (self.currency as any)?.__serialize === "function"
          ? (self.currency as any).__serialize(ctx)
          : self.currency;
    } else {
      result["currency"] = null;
    }
    if (self.paymentMethod !== null) {
      result["paymentMethod"] =
        typeof (self.paymentMethod as any)?.__serialize === "function"
          ? (self.paymentMethod as any).__serialize(ctx)
          : self.paymentMethod;
    } else {
      result["paymentMethod"] = null;
    }
    return result;
  }
}

export namespace Paid {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Paid, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Paid, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Paid.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Paid | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Paid.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("amount" in obj)) {
      errors.push({ field: "amount", message: "missing required field" });
    }
    if (!("currency" in obj)) {
      errors.push({ field: "currency", message: "missing required field" });
    }
    if (!("paymentMethod" in obj)) {
      errors.push({
        field: "paymentMethod",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_amount = obj["amount"];
      instance.amount = __raw_amount;
    }
    {
      const __raw_currency = obj["currency"];
      instance.currency = __raw_currency;
    }
    {
      const __raw_paymentMethod = obj["paymentMethod"];
      instance.paymentMethod = __raw_paymentMethod;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Paid;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Paid>(
    field: K,
    value: Paid[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Paid>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Paid {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    amount: Option<Array<string>>;
    currency: Option<Array<string>>;
    paymentMethod: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      amount: Option<boolean>;
      currency: Option<boolean>;
      paymentMethod: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly amount: FieldController<number | null>;
    readonly currency: FieldController<string | null>;
    readonly paymentMethod: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Paid;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Paid, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Paid>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Paid>,
  ): Gigaform {
    let data = $state({ ...Paid.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      amount: Option.none(),
      currency: Option.none(),
      paymentMethod: Option.none(),
    });
    let tainted = $state<Tainted>({
      amount: Option.none(),
      currency: Option.none(),
      paymentMethod: Option.none(),
    });
    const fields: FieldControllers = {
      amount: {
        path: ["amount"] as const,
        name: "amount",
        constraints: { required: true },

        get: () => data.amount,
        set: (value: number | null) => {
          data.amount = value;
        },
        getError: () => errors.amount,
        setError: (value: Option<Array<string>>) => {
          errors.amount = value;
        },
        getTainted: () => tainted.amount,
        setTainted: (value: Option<boolean>) => {
          tainted.amount = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Paid.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "amount")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Paid.validateField("amount", data.amount);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      currency: {
        path: ["currency"] as const,
        name: "currency",
        constraints: { required: true },

        get: () => data.currency,
        set: (value: string | null) => {
          data.currency = value;
        },
        getError: () => errors.currency,
        setError: (value: Option<Array<string>>) => {
          errors.currency = value;
        },
        getTainted: () => tainted.currency,
        setTainted: (value: Option<boolean>) => {
          tainted.currency = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Paid.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "currency")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Paid.validateField("currency", data.currency);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      paymentMethod: {
        path: ["paymentMethod"] as const,
        name: "paymentMethod",
        constraints: { required: true },

        get: () => data.paymentMethod,
        set: (value: string | null) => {
          data.paymentMethod = value;
        },
        getError: () => errors.paymentMethod,
        setError: (value: Option<Array<string>>) => {
          errors.paymentMethod = value;
        },
        getTainted: () => tainted.paymentMethod,
        setTainted: (value: Option<boolean>) => {
          tainted.paymentMethod = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Paid.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "paymentMethod")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Paid.validateField(
            "paymentMethod",
            data.paymentMethod,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Paid,
      Array<{ field: string; message: string }>
    > {
      return Paid.fromObject(data);
    }
    function reset(newOverrides?: Partial<Paid>): void {
      data = { ...Paid.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        amount: Option.none(),
        currency: Option.none(),
        paymentMethod: Option.none(),
      };
      tainted = {
        amount: Option.none(),
        currency: Option.none(),
        paymentMethod: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Paid, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const amountStr = formData.get("amount");
      obj.amount = amountStr ? parseFloat(amountStr as string) : 0;
      if (obj.amount !== undefined && isNaN(obj.amount as number))
        obj.amount = 0;
    }
    obj.currency = formData.get("currency") ?? "";
    obj.paymentMethod = formData.get("paymentMethod") ?? "";
    return Paid.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface TaxRate {
  id: string;

  name: string;

  taxAgency: string;
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
  zip: number;

  city: string;

  county: string;

  state: string;
<<<<<<< Updated upstream
=======

>>>>>>> Stashed changes
  isActive: boolean;

  description: string;

  taxComponents: { [key: string]: number };
}

export namespace TaxRate {
  export function defaultValue(): TaxRate {
    return {
      id: "",
      name: "",
      taxAgency: "",
      zip: 0,
      city: "",
      county: "",
      state: "",
      isActive: false,
      description: "",
      taxComponents: {},
    } as TaxRate;
  }
}

export namespace TaxRate {
  export function toStringifiedJSON(self: TaxRate): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: TaxRate): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: TaxRate,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "TaxRate", __id };
    result["id"] = self.id;
    result["name"] = self.name;
    result["taxAgency"] = self.taxAgency;
    result["zip"] = self.zip;
    result["city"] = self.city;
    result["county"] = self.county;
    result["state"] = self.state;
    result["isActive"] = self.isActive;
    result["description"] = self.description;
    result["taxComponents"] = self.taxComponents;
    return result;
  }
}

export namespace TaxRate {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<TaxRate, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<TaxRate, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "TaxRate.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): TaxRate | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "TaxRate.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (!("taxAgency" in obj)) {
      errors.push({ field: "taxAgency", message: "missing required field" });
    }
    if (!("zip" in obj)) {
      errors.push({ field: "zip", message: "missing required field" });
    }
    if (!("city" in obj)) {
      errors.push({ field: "city", message: "missing required field" });
    }
    if (!("county" in obj)) {
      errors.push({ field: "county", message: "missing required field" });
    }
    if (!("state" in obj)) {
      errors.push({ field: "state", message: "missing required field" });
    }
    if (!("isActive" in obj)) {
      errors.push({ field: "isActive", message: "missing required field" });
    }
    if (!("description" in obj)) {
      errors.push({ field: "description", message: "missing required field" });
    }
    if (!("taxComponents" in obj)) {
      errors.push({
        field: "taxComponents",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    {
      const __raw_taxAgency = obj["taxAgency"];
      instance.taxAgency = __raw_taxAgency;
    }
    {
      const __raw_zip = obj["zip"];
      instance.zip = __raw_zip;
    }
    {
      const __raw_city = obj["city"];
      instance.city = __raw_city;
    }
    {
      const __raw_county = obj["county"];
      instance.county = __raw_county;
    }
    {
      const __raw_state = obj["state"];
      instance.state = __raw_state;
    }
    {
      const __raw_isActive = obj["isActive"];
      instance.isActive = __raw_isActive;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    {
      const __raw_taxComponents = obj["taxComponents"];
      instance.taxComponents = __raw_taxComponents;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as TaxRate;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof TaxRate>(
    field: K,
    value: TaxRate[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
      case "taxAgency": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "taxAgency", message: "must not be empty" });
        }
        break;
      }
      case "city": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "city", message: "must not be empty" });
        }
        break;
      }
      case "county": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "county", message: "must not be empty" });
        }
        break;
      }
      case "state": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "state", message: "must not be empty" });
        }
        break;
      }
      case "description": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "description", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<TaxRate>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    if ("taxAgency" in partial && partial.taxAgency !== undefined) {
      const __val = partial.taxAgency as string;
      if (__val.length === 0) {
        errors.push({ field: "taxAgency", message: "must not be empty" });
      }
    }
    if ("city" in partial && partial.city !== undefined) {
      const __val = partial.city as string;
      if (__val.length === 0) {
        errors.push({ field: "city", message: "must not be empty" });
      }
    }
    if ("county" in partial && partial.county !== undefined) {
      const __val = partial.county as string;
      if (__val.length === 0) {
        errors.push({ field: "county", message: "must not be empty" });
      }
    }
    if ("state" in partial && partial.state !== undefined) {
      const __val = partial.state as string;
      if (__val.length === 0) {
        errors.push({ field: "state", message: "must not be empty" });
      }
    }
    if ("description" in partial && partial.description !== undefined) {
      const __val = partial.description as string;
      if (__val.length === 0) {
        errors.push({ field: "description", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace TaxRate {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    name: Option<Array<string>>;
    taxAgency: Option<Array<string>>;
    zip: Option<Array<string>>;
    city: Option<Array<string>>;
    county: Option<Array<string>>;
    state: Option<Array<string>>;
    isActive: Option<Array<string>>;
    description: Option<Array<string>>;
    taxComponents: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      name: Option<boolean>;
      taxAgency: Option<boolean>;
      zip: Option<boolean>;
      city: Option<boolean>;
      county: Option<boolean>;
      state: Option<boolean>;
      isActive: Option<boolean>;
      description: Option<boolean>;
      taxComponents: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly name: FieldController<string>;
    readonly taxAgency: FieldController<string>;
    readonly zip: FieldController<number>;
    readonly city: FieldController<string>;
    readonly county: FieldController<string>;
    readonly state: FieldController<string>;
    readonly isActive: FieldController<boolean>;
    readonly description: FieldController<string>;
    readonly taxComponents: FieldController<{ [key: string]: number }>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: TaxRate;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<TaxRate, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<TaxRate>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<TaxRate>,
  ): Gigaform {
    let data = $state({ ...TaxRate.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      name: Option.none(),
      taxAgency: Option.none(),
      zip: Option.none(),
      city: Option.none(),
      county: Option.none(),
      state: Option.none(),
      isActive: Option.none(),
      description: Option.none(),
      taxComponents: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      name: Option.none(),
      taxAgency: Option.none(),
      zip: Option.none(),
      city: Option.none(),
      county: Option.none(),
      state: Option.none(),
      isActive: Option.none(),
      description: Option.none(),
      taxComponents: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Name",
>>>>>>> Stashed changes
        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField("name", data.name);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      taxAgency: {
        path: ["taxAgency"] as const,
        name: "taxAgency",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Tax Agency",
>>>>>>> Stashed changes
        get: () => data.taxAgency,
        set: (value: string) => {
          data.taxAgency = value;
        },
        getError: () => errors.taxAgency,
        setError: (value: Option<Array<string>>) => {
          errors.taxAgency = value;
        },
        getTainted: () => tainted.taxAgency,
        setTainted: (value: Option<boolean>) => {
          tainted.taxAgency = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "taxAgency")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField(
            "taxAgency",
            data.taxAgency,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      zip: {
        path: ["zip"] as const,
        name: "zip",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Zip",
>>>>>>> Stashed changes
        get: () => data.zip,
        set: (value: number) => {
          data.zip = value;
        },
        getError: () => errors.zip,
        setError: (value: Option<Array<string>>) => {
          errors.zip = value;
        },
        getTainted: () => tainted.zip,
        setTainted: (value: Option<boolean>) => {
          tainted.zip = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "zip")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField("zip", data.zip);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      city: {
        path: ["city"] as const,
        name: "city",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "City",
>>>>>>> Stashed changes
        get: () => data.city,
        set: (value: string) => {
          data.city = value;
        },
        getError: () => errors.city,
        setError: (value: Option<Array<string>>) => {
          errors.city = value;
        },
        getTainted: () => tainted.city,
        setTainted: (value: Option<boolean>) => {
          tainted.city = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "city")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField("city", data.city);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      county: {
        path: ["county"] as const,
        name: "county",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "County",
>>>>>>> Stashed changes
        get: () => data.county,
        set: (value: string) => {
          data.county = value;
        },
        getError: () => errors.county,
        setError: (value: Option<Array<string>>) => {
          errors.county = value;
        },
        getTainted: () => tainted.county,
        setTainted: (value: Option<boolean>) => {
          tainted.county = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "county")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField("county", data.county);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      state: {
        path: ["state"] as const,
        name: "state",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "State",
>>>>>>> Stashed changes
        get: () => data.state,
        set: (value: string) => {
          data.state = value;
        },
        getError: () => errors.state,
        setError: (value: Option<Array<string>>) => {
          errors.state = value;
        },
        getTainted: () => tainted.state,
        setTainted: (value: Option<boolean>) => {
          tainted.state = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "state")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField("state", data.state);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      isActive: {
        path: ["isActive"] as const,
        name: "isActive",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Active",
>>>>>>> Stashed changes
        get: () => data.isActive,
        set: (value: boolean) => {
          data.isActive = value;
        },
        getError: () => errors.isActive,
        setError: (value: Option<Array<string>>) => {
          errors.isActive = value;
        },
        getTainted: () => tainted.isActive,
        setTainted: (value: Option<boolean>) => {
          tainted.isActive = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "isActive")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField("isActive", data.isActive);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Description",
>>>>>>> Stashed changes
        get: () => data.description,
        set: (value: string) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "description")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      taxComponents: {
        path: ["taxComponents"] as const,
        name: "taxComponents",
        constraints: { required: true },

        get: () => data.taxComponents,
        set: (value: { [key: string]: number }) => {
          data.taxComponents = value;
        },
        getError: () => errors.taxComponents,
        setError: (value: Option<Array<string>>) => {
          errors.taxComponents = value;
        },
        getTainted: () => tainted.taxComponents,
        setTainted: (value: Option<boolean>) => {
          tainted.taxComponents = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = TaxRate.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "taxComponents")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = TaxRate.validateField(
            "taxComponents",
            data.taxComponents,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      TaxRate,
      Array<{ field: string; message: string }>
    > {
      return TaxRate.fromObject(data);
    }
    function reset(newOverrides?: Partial<TaxRate>): void {
      data = { ...TaxRate.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        name: Option.none(),
        taxAgency: Option.none(),
        zip: Option.none(),
        city: Option.none(),
        county: Option.none(),
        state: Option.none(),
        isActive: Option.none(),
        description: Option.none(),
        taxComponents: Option.none(),
      };
      tainted = {
        id: Option.none(),
        name: Option.none(),
        taxAgency: Option.none(),
        zip: Option.none(),
        city: Option.none(),
        county: Option.none(),
        state: Option.none(),
        isActive: Option.none(),
        description: Option.none(),
        taxComponents: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<TaxRate, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.name = formData.get("name") ?? "";
    obj.taxAgency = formData.get("taxAgency") ?? "";
    {
      const zipStr = formData.get("zip");
      obj.zip = zipStr ? parseFloat(zipStr as string) : 0;
      if (obj.zip !== undefined && isNaN(obj.zip as number)) obj.zip = 0;
    }
    obj.city = formData.get("city") ?? "";
    obj.county = formData.get("county") ?? "";
    obj.state = formData.get("state") ?? "";
    {
      const isActiveVal = formData.get("isActive");
      obj.isActive =
        isActiveVal === "true" || isActiveVal === "on" || isActiveVal === "1";
    }
    obj.description = formData.get("description") ?? "";
    obj.taxComponents = formData.get("taxComponents") ?? "";
    return TaxRate.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Address {
  street: string;

  city: string;

  state: string;

  zipcode: string;
}

export namespace Address {
  export function defaultValue(): Address {
    return { street: "", city: "", state: "", zipcode: "" } as Address;
  }
}

export namespace Address {
  export function toStringifiedJSON(self: Address): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Address): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Address,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Address", __id };
    result["street"] = self.street;
    result["city"] = self.city;
    result["state"] = self.state;
    result["zipcode"] = self.zipcode;
    return result;
  }
}

export namespace Address {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Address, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Address, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Address.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Address | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Address.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("street" in obj)) {
      errors.push({ field: "street", message: "missing required field" });
    }
    if (!("city" in obj)) {
      errors.push({ field: "city", message: "missing required field" });
    }
    if (!("state" in obj)) {
      errors.push({ field: "state", message: "missing required field" });
    }
    if (!("zipcode" in obj)) {
      errors.push({ field: "zipcode", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_street = obj["street"];
      instance.street = __raw_street;
    }
    {
      const __raw_city = obj["city"];
      instance.city = __raw_city;
    }
    {
      const __raw_state = obj["state"];
      instance.state = __raw_state;
    }
    {
      const __raw_zipcode = obj["zipcode"];
      instance.zipcode = __raw_zipcode;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Address;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Address>(
    field: K,
    value: Address[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "street": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "street", message: "must not be empty" });
        }
        break;
      }
      case "city": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "city", message: "must not be empty" });
        }
        break;
      }
      case "state": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "state", message: "must not be empty" });
        }
        break;
      }
      case "zipcode": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "zipcode", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Address>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("street" in partial && partial.street !== undefined) {
      const __val = partial.street as string;
      if (__val.length === 0) {
        errors.push({ field: "street", message: "must not be empty" });
      }
    }
    if ("city" in partial && partial.city !== undefined) {
      const __val = partial.city as string;
      if (__val.length === 0) {
        errors.push({ field: "city", message: "must not be empty" });
      }
    }
    if ("state" in partial && partial.state !== undefined) {
      const __val = partial.state as string;
      if (__val.length === 0) {
        errors.push({ field: "state", message: "must not be empty" });
      }
    }
    if ("zipcode" in partial && partial.zipcode !== undefined) {
      const __val = partial.zipcode as string;
      if (__val.length === 0) {
        errors.push({ field: "zipcode", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Address {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    street: Option<Array<string>>;
    city: Option<Array<string>>;
    state: Option<Array<string>>;
    zipcode: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      street: Option<boolean>;
      city: Option<boolean>;
      state: Option<boolean>;
      zipcode: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly street: FieldController<string>;
    readonly city: FieldController<string>;
    readonly state: FieldController<string>;
    readonly zipcode: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Address;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Address, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Address>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Address>,
  ): Gigaform {
    let data = $state({ ...Address.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      street: Option.none(),
      city: Option.none(),
      state: Option.none(),
      zipcode: Option.none(),
    });
    let tainted = $state<Tainted>({
      street: Option.none(),
      city: Option.none(),
      state: Option.none(),
      zipcode: Option.none(),
    });
    const fields: FieldControllers = {
      street: {
        path: ["street"] as const,
        name: "street",
        constraints: { required: true },

        get: () => data.street,
        set: (value: string) => {
          data.street = value;
        },
        getError: () => errors.street,
        setError: (value: Option<Array<string>>) => {
          errors.street = value;
        },
        getTainted: () => tainted.street,
        setTainted: (value: Option<boolean>) => {
          tainted.street = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Address.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "street")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Address.validateField("street", data.street);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      city: {
        path: ["city"] as const,
        name: "city",
        constraints: { required: true },

        get: () => data.city,
        set: (value: string) => {
          data.city = value;
        },
        getError: () => errors.city,
        setError: (value: Option<Array<string>>) => {
          errors.city = value;
        },
        getTainted: () => tainted.city,
        setTainted: (value: Option<boolean>) => {
          tainted.city = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Address.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "city")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Address.validateField("city", data.city);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      state: {
        path: ["state"] as const,
        name: "state",
        constraints: { required: true },

        get: () => data.state,
        set: (value: string) => {
          data.state = value;
        },
        getError: () => errors.state,
        setError: (value: Option<Array<string>>) => {
          errors.state = value;
        },
        getTainted: () => tainted.state,
        setTainted: (value: Option<boolean>) => {
          tainted.state = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Address.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "state")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Address.validateField("state", data.state);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      zipcode: {
        path: ["zipcode"] as const,
        name: "zipcode",
        constraints: { required: true },

        get: () => data.zipcode,
        set: (value: string) => {
          data.zipcode = value;
        },
        getError: () => errors.zipcode,
        setError: (value: Option<Array<string>>) => {
          errors.zipcode = value;
        },
        getTainted: () => tainted.zipcode,
        setTainted: (value: Option<boolean>) => {
          tainted.zipcode = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Address.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "zipcode")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Address.validateField("zipcode", data.zipcode);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Address,
      Array<{ field: string; message: string }>
    > {
      return Address.fromObject(data);
    }
    function reset(newOverrides?: Partial<Address>): void {
      data = { ...Address.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        street: Option.none(),
        city: Option.none(),
        state: Option.none(),
        zipcode: Option.none(),
      };
      tainted = {
        street: Option.none(),
        city: Option.none(),
        state: Option.none(),
        zipcode: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Address, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.street = formData.get("street") ?? "";
    obj.city = formData.get("city") ?? "";
    obj.state = formData.get("state") ?? "";
    obj.zipcode = formData.get("zipcode") ?? "";
    return Address.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Lead {
  id: string;
<<<<<<< Updated upstream
  number: number | null;
  accepted: boolean;
  probability: number;

  priority: Priority;
  dueDate: string | null;
  closeDate: string | null;
=======

  number: number | null;

  accepted: boolean;

  probability: number;

  priority: Priority;

  dueDate: string | null;

  closeDate: string | null;

>>>>>>> Stashed changes
  value: number;

  stage: LeadStage;

  status: string;
<<<<<<< Updated upstream
  description: string | null;

  nextStep: NextStep;
  favorite: boolean;
  dateAdded: string | null;
  taxRate: (string | TaxRate) | null;

  sector: Sector;
  leadName: AccountName;
  phones: PhoneNumber[];
  email: Email;
=======

  description: string | null;

  nextStep: NextStep;

  favorite: boolean;

  dateAdded: string | null;

  taxRate: (string | TaxRate) | null;

  sector: Sector;

  leadName: AccountName;

  phones: PhoneNumber[];

  email: Email;

>>>>>>> Stashed changes
  leadSource: string | null;

  site: string | Site;

  memo: string;
<<<<<<< Updated upstream
  needsReview: boolean;
  hasAlert: boolean;
  salesRep: Represents[] | null;
=======

  needsReview: boolean;

  hasAlert: boolean;

  salesRep: Represents[] | null;

>>>>>>> Stashed changes
  color: string | null;

  accountType: string;

  subtype: string;
<<<<<<< Updated upstream
  isTaxExempt: boolean;

  paymentTerms: string;
  tags: string[];
=======

  isTaxExempt: boolean;

  paymentTerms: string;

  tags: string[];

>>>>>>> Stashed changes
  customFields: [string, string][];
}

export namespace Lead {
  export function defaultValue(): Lead {
    return {
      id: "",
      number: null,
      accepted: false,
      probability: 0,
      priority: "Medium",
      dueDate: null,
      closeDate: null,
      value: 0,
      stage: "Open",
      status: "",
      description: null,
      nextStep: "InitialContact",
      favorite: false,
      dateAdded: null,
      taxRate: null,
      sector: "Residential",
      leadName: AccountName.defaultValue(),
      phones: [],
      email: Email.defaultValue(),
      leadSource: null,
      site: "",
      memo: "",
      needsReview: false,
      hasAlert: false,
      salesRep: null,
      color: null,
      accountType: "",
      subtype: "",
      isTaxExempt: false,
      paymentTerms: "",
      tags: [],
      customFields: [],
    } as Lead;
  }
}

export namespace Lead {
  export function toStringifiedJSON(self: Lead): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Lead): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Lead,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Lead", __id };
    result["id"] = self.id;
    if (self.number !== null) {
      result["number"] =
        typeof (self.number as any)?.__serialize === "function"
          ? (self.number as any).__serialize(ctx)
          : self.number;
    } else {
      result["number"] = null;
    }
    result["accepted"] = self.accepted;
    result["probability"] = self.probability;
    result["priority"] =
      typeof (self.priority as any)?.__serialize === "function"
        ? (self.priority as any).__serialize(ctx)
        : self.priority;
    if (self.dueDate !== null) {
      result["dueDate"] =
        typeof (self.dueDate as any)?.__serialize === "function"
          ? (self.dueDate as any).__serialize(ctx)
          : self.dueDate;
    } else {
      result["dueDate"] = null;
    }
    if (self.closeDate !== null) {
      result["closeDate"] =
        typeof (self.closeDate as any)?.__serialize === "function"
          ? (self.closeDate as any).__serialize(ctx)
          : self.closeDate;
    } else {
      result["closeDate"] = null;
    }
    result["value"] = self.value;
    result["stage"] =
      typeof (self.stage as any)?.__serialize === "function"
        ? (self.stage as any).__serialize(ctx)
        : self.stage;
    result["status"] = self.status;
    if (self.description !== null) {
      result["description"] =
        typeof (self.description as any)?.__serialize === "function"
          ? (self.description as any).__serialize(ctx)
          : self.description;
    } else {
      result["description"] = null;
    }
    result["nextStep"] =
      typeof (self.nextStep as any)?.__serialize === "function"
        ? (self.nextStep as any).__serialize(ctx)
        : self.nextStep;
    result["favorite"] = self.favorite;
    if (self.dateAdded !== null) {
      result["dateAdded"] =
        typeof (self.dateAdded as any)?.__serialize === "function"
          ? (self.dateAdded as any).__serialize(ctx)
          : self.dateAdded;
    } else {
      result["dateAdded"] = null;
    }
    if (self.taxRate !== null) {
      result["taxRate"] =
        typeof (self.taxRate as any)?.__serialize === "function"
          ? (self.taxRate as any).__serialize(ctx)
          : self.taxRate;
    } else {
      result["taxRate"] = null;
    }
    result["sector"] =
      typeof (self.sector as any)?.__serialize === "function"
        ? (self.sector as any).__serialize(ctx)
        : self.sector;
    result["leadName"] =
      typeof (self.leadName as any)?.__serialize === "function"
        ? (self.leadName as any).__serialize(ctx)
        : self.leadName;
    result["phones"] = self.phones.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["email"] =
      typeof (self.email as any)?.__serialize === "function"
        ? (self.email as any).__serialize(ctx)
        : self.email;
    if (self.leadSource !== null) {
      result["leadSource"] =
        typeof (self.leadSource as any)?.__serialize === "function"
          ? (self.leadSource as any).__serialize(ctx)
          : self.leadSource;
    } else {
      result["leadSource"] = null;
    }
    result["site"] = self.site;
    result["memo"] = self.memo;
    result["needsReview"] = self.needsReview;
    result["hasAlert"] = self.hasAlert;
    if (self.salesRep !== null) {
      result["salesRep"] =
        typeof (self.salesRep as any)?.__serialize === "function"
          ? (self.salesRep as any).__serialize(ctx)
          : self.salesRep;
    } else {
      result["salesRep"] = null;
    }
    if (self.color !== null) {
      result["color"] =
        typeof (self.color as any)?.__serialize === "function"
          ? (self.color as any).__serialize(ctx)
          : self.color;
    } else {
      result["color"] = null;
    }
    result["accountType"] = self.accountType;
    result["subtype"] = self.subtype;
    result["isTaxExempt"] = self.isTaxExempt;
    result["paymentTerms"] = self.paymentTerms;
    result["tags"] = self.tags.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["customFields"] = self.customFields.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    return result;
  }
}

export namespace Lead {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Lead, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Lead, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Lead.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Lead | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Lead.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("number" in obj)) {
      errors.push({ field: "number", message: "missing required field" });
    }
    if (!("accepted" in obj)) {
      errors.push({ field: "accepted", message: "missing required field" });
    }
    if (!("probability" in obj)) {
      errors.push({ field: "probability", message: "missing required field" });
    }
    if (!("priority" in obj)) {
      errors.push({ field: "priority", message: "missing required field" });
    }
    if (!("dueDate" in obj)) {
      errors.push({ field: "dueDate", message: "missing required field" });
    }
    if (!("closeDate" in obj)) {
      errors.push({ field: "closeDate", message: "missing required field" });
    }
    if (!("value" in obj)) {
      errors.push({ field: "value", message: "missing required field" });
    }
    if (!("stage" in obj)) {
      errors.push({ field: "stage", message: "missing required field" });
    }
    if (!("status" in obj)) {
      errors.push({ field: "status", message: "missing required field" });
    }
    if (!("description" in obj)) {
      errors.push({ field: "description", message: "missing required field" });
    }
    if (!("nextStep" in obj)) {
      errors.push({ field: "nextStep", message: "missing required field" });
    }
    if (!("favorite" in obj)) {
      errors.push({ field: "favorite", message: "missing required field" });
    }
    if (!("dateAdded" in obj)) {
      errors.push({ field: "dateAdded", message: "missing required field" });
    }
    if (!("taxRate" in obj)) {
      errors.push({ field: "taxRate", message: "missing required field" });
    }
    if (!("sector" in obj)) {
      errors.push({ field: "sector", message: "missing required field" });
    }
    if (!("leadName" in obj)) {
      errors.push({ field: "leadName", message: "missing required field" });
    }
    if (!("phones" in obj)) {
      errors.push({ field: "phones", message: "missing required field" });
    }
    if (!("email" in obj)) {
      errors.push({ field: "email", message: "missing required field" });
    }
    if (!("leadSource" in obj)) {
      errors.push({ field: "leadSource", message: "missing required field" });
    }
    if (!("site" in obj)) {
      errors.push({ field: "site", message: "missing required field" });
    }
    if (!("memo" in obj)) {
      errors.push({ field: "memo", message: "missing required field" });
    }
    if (!("needsReview" in obj)) {
      errors.push({ field: "needsReview", message: "missing required field" });
    }
    if (!("hasAlert" in obj)) {
      errors.push({ field: "hasAlert", message: "missing required field" });
    }
    if (!("salesRep" in obj)) {
      errors.push({ field: "salesRep", message: "missing required field" });
    }
    if (!("color" in obj)) {
      errors.push({ field: "color", message: "missing required field" });
    }
    if (!("accountType" in obj)) {
      errors.push({ field: "accountType", message: "missing required field" });
    }
    if (!("subtype" in obj)) {
      errors.push({ field: "subtype", message: "missing required field" });
    }
    if (!("isTaxExempt" in obj)) {
      errors.push({ field: "isTaxExempt", message: "missing required field" });
    }
    if (!("paymentTerms" in obj)) {
      errors.push({ field: "paymentTerms", message: "missing required field" });
    }
    if (!("tags" in obj)) {
      errors.push({ field: "tags", message: "missing required field" });
    }
    if (!("customFields" in obj)) {
      errors.push({ field: "customFields", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_number = obj["number"];
      instance.number = __raw_number;
    }
    {
      const __raw_accepted = obj["accepted"];
      instance.accepted = __raw_accepted;
    }
    {
      const __raw_probability = obj["probability"];
      instance.probability = __raw_probability;
    }
    {
      const __raw_priority = obj["priority"];
      if (typeof (Priority as any)?.__deserialize === "function") {
        const __result = (Priority as any).__deserialize(__raw_priority, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "priority", __result);
=======
        if (PendingRef.is(__result)) {
          instance.priority = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.priority = v;
          });
        } else {
          instance.priority = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.priority = __raw_priority;
      }
    }
    {
      const __raw_dueDate = obj["dueDate"];
      instance.dueDate = __raw_dueDate;
    }
    {
      const __raw_closeDate = obj["closeDate"];
      instance.closeDate = __raw_closeDate;
    }
    {
      const __raw_value = obj["value"];
      instance.value = __raw_value;
    }
    {
      const __raw_stage = obj["stage"];
      if (typeof (LeadStage as any)?.__deserialize === "function") {
        const __result = (LeadStage as any).__deserialize(__raw_stage, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "stage", __result);
=======
        if (PendingRef.is(__result)) {
          instance.stage = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.stage = v;
          });
        } else {
          instance.stage = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.stage = __raw_stage;
      }
    }
    {
      const __raw_status = obj["status"];
      instance.status = __raw_status;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    {
      const __raw_nextStep = obj["nextStep"];
      if (typeof (NextStep as any)?.__deserialize === "function") {
        const __result = (NextStep as any).__deserialize(__raw_nextStep, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "nextStep", __result);
=======
        if (PendingRef.is(__result)) {
          instance.nextStep = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.nextStep = v;
          });
        } else {
          instance.nextStep = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.nextStep = __raw_nextStep;
      }
    }
    {
      const __raw_favorite = obj["favorite"];
      instance.favorite = __raw_favorite;
    }
    {
      const __raw_dateAdded = obj["dateAdded"];
      instance.dateAdded = __raw_dateAdded;
    }
    {
      const __raw_taxRate = obj["taxRate"];
      instance.taxRate = __raw_taxRate;
    }
    {
      const __raw_sector = obj["sector"];
      if (typeof (Sector as any)?.__deserialize === "function") {
        const __result = (Sector as any).__deserialize(__raw_sector, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "sector", __result);
=======
        if (PendingRef.is(__result)) {
          instance.sector = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.sector = v;
          });
        } else {
          instance.sector = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.sector = __raw_sector;
      }
    }
    {
      const __raw_leadName = obj["leadName"];
      if (typeof (AccountName as any)?.__deserialize === "function") {
        const __result = (AccountName as any).__deserialize(
          __raw_leadName,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "leadName", __result);
=======
        if (PendingRef.is(__result)) {
          instance.leadName = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.leadName = v;
          });
        } else {
          instance.leadName = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.leadName = __raw_leadName;
      }
    }
    {
      const __raw_phones = obj["phones"];
      instance.phones = __raw_phones;
    }
    {
      const __raw_email = obj["email"];
      if (typeof (Email as any)?.__deserialize === "function") {
        const __result = (Email as any).__deserialize(__raw_email, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "email", __result);
=======
        if (PendingRef.is(__result)) {
          instance.email = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.email = v;
          });
        } else {
          instance.email = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.email = __raw_email;
      }
    }
    {
      const __raw_leadSource = obj["leadSource"];
      instance.leadSource = __raw_leadSource;
    }
    {
      const __raw_site = obj["site"];
      instance.site = __raw_site;
    }
    {
      const __raw_memo = obj["memo"];
      instance.memo = __raw_memo;
    }
    {
      const __raw_needsReview = obj["needsReview"];
      instance.needsReview = __raw_needsReview;
    }
    {
      const __raw_hasAlert = obj["hasAlert"];
      instance.hasAlert = __raw_hasAlert;
    }
    {
      const __raw_salesRep = obj["salesRep"];
      instance.salesRep = __raw_salesRep;
    }
    {
      const __raw_color = obj["color"];
      instance.color = __raw_color;
    }
    {
      const __raw_accountType = obj["accountType"];
      instance.accountType = __raw_accountType;
    }
    {
      const __raw_subtype = obj["subtype"];
      instance.subtype = __raw_subtype;
    }
    {
      const __raw_isTaxExempt = obj["isTaxExempt"];
      instance.isTaxExempt = __raw_isTaxExempt;
    }
    {
      const __raw_paymentTerms = obj["paymentTerms"];
      instance.paymentTerms = __raw_paymentTerms;
    }
    {
      const __raw_tags = obj["tags"];
      instance.tags = __raw_tags;
    }
    {
      const __raw_customFields = obj["customFields"];
      instance.customFields = __raw_customFields;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Lead;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Lead>(
    field: K,
    value: Lead[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "status": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "status", message: "must not be empty" });
        }
        break;
      }
      case "memo": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "memo", message: "must not be empty" });
        }
        break;
      }
      case "accountType": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "accountType", message: "must not be empty" });
        }
        break;
      }
      case "subtype": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "subtype", message: "must not be empty" });
        }
        break;
      }
      case "paymentTerms": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "paymentTerms", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Lead>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("status" in partial && partial.status !== undefined) {
      const __val = partial.status as string;
      if (__val.length === 0) {
        errors.push({ field: "status", message: "must not be empty" });
      }
    }
    if ("memo" in partial && partial.memo !== undefined) {
      const __val = partial.memo as string;
      if (__val.length === 0) {
        errors.push({ field: "memo", message: "must not be empty" });
      }
    }
    if ("accountType" in partial && partial.accountType !== undefined) {
      const __val = partial.accountType as string;
      if (__val.length === 0) {
        errors.push({ field: "accountType", message: "must not be empty" });
      }
    }
    if ("subtype" in partial && partial.subtype !== undefined) {
      const __val = partial.subtype as string;
      if (__val.length === 0) {
        errors.push({ field: "subtype", message: "must not be empty" });
      }
    }
    if ("paymentTerms" in partial && partial.paymentTerms !== undefined) {
      const __val = partial.paymentTerms as string;
      if (__val.length === 0) {
        errors.push({ field: "paymentTerms", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Lead {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    number: Option<Array<string>>;
    accepted: Option<Array<string>>;
    probability: Option<Array<string>>;
    priority: Option<Array<string>>;
    dueDate: Option<Array<string>>;
    closeDate: Option<Array<string>>;
    value: Option<Array<string>>;
    stage: Option<Array<string>>;
    status: Option<Array<string>>;
    description: Option<Array<string>>;
    nextStep: Option<Array<string>>;
    favorite: Option<Array<string>>;
    dateAdded: Option<Array<string>>;
    taxRate: Option<Array<string>>;
    sector: Option<Array<string>>;
    leadName: Option<Array<string>>;
    phones: Option<Array<string>>;
    email: Option<Array<string>>;
    leadSource: Option<Array<string>>;
    site: Option<Array<string>>;
    memo: Option<Array<string>>;
    needsReview: Option<Array<string>>;
    hasAlert: Option<Array<string>>;
    salesRep: Option<Array<string>>;
    color: Option<Array<string>>;
    accountType: Option<Array<string>>;
    subtype: Option<Array<string>>;
    isTaxExempt: Option<Array<string>>;
    paymentTerms: Option<Array<string>>;
    tags: Option<Array<string>>;
    customFields: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      number: Option<boolean>;
      accepted: Option<boolean>;
      probability: Option<boolean>;
      priority: Option<boolean>;
      dueDate: Option<boolean>;
      closeDate: Option<boolean>;
      value: Option<boolean>;
      stage: Option<boolean>;
      status: Option<boolean>;
      description: Option<boolean>;
      nextStep: Option<boolean>;
      favorite: Option<boolean>;
      dateAdded: Option<boolean>;
      taxRate: Option<boolean>;
      sector: Option<boolean>;
      leadName: Option<boolean>;
      phones: Option<boolean>;
      email: Option<boolean>;
      leadSource: Option<boolean>;
      site: Option<boolean>;
      memo: Option<boolean>;
      needsReview: Option<boolean>;
      hasAlert: Option<boolean>;
      salesRep: Option<boolean>;
      color: Option<boolean>;
      accountType: Option<boolean>;
      subtype: Option<boolean>;
      isTaxExempt: Option<boolean>;
      paymentTerms: Option<boolean>;
      tags: Option<boolean>;
      customFields: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly number: FieldController<number | null>;
    readonly accepted: FieldController<boolean>;
    readonly probability: FieldController<number>;
    readonly priority: FieldController<Priority>;
    readonly dueDate: FieldController<string | null>;
    readonly closeDate: FieldController<string | null>;
    readonly value: FieldController<number>;
    readonly stage: FieldController<LeadStage>;
    readonly status: FieldController<string>;
    readonly description: FieldController<string | null>;
    readonly nextStep: FieldController<NextStep>;
    readonly favorite: FieldController<boolean>;
    readonly dateAdded: FieldController<string | null>;
    readonly taxRate: FieldController<(string | TaxRate) | null>;
    readonly sector: FieldController<Sector>;
    readonly leadName: FieldController<AccountName>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly email: FieldController<Email>;
    readonly leadSource: FieldController<string | null>;
    readonly site: FieldController<string | Site>;
    readonly memo: FieldController<string>;
    readonly needsReview: FieldController<boolean>;
    readonly hasAlert: FieldController<boolean>;
    readonly salesRep: FieldController<Represents[] | null>;
    readonly color: FieldController<string | null>;
    readonly accountType: FieldController<string>;
    readonly subtype: FieldController<string>;
    readonly isTaxExempt: FieldController<boolean>;
    readonly paymentTerms: FieldController<string>;
    readonly tags: ArrayFieldController<string>;
    readonly customFields: ArrayFieldController<[string, string]>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Lead;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Lead, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Lead>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Lead>,
  ): Gigaform {
    let data = $state({ ...Lead.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      number: Option.none(),
      accepted: Option.none(),
      probability: Option.none(),
      priority: Option.none(),
      dueDate: Option.none(),
      closeDate: Option.none(),
      value: Option.none(),
      stage: Option.none(),
      status: Option.none(),
      description: Option.none(),
      nextStep: Option.none(),
      favorite: Option.none(),
      dateAdded: Option.none(),
      taxRate: Option.none(),
      sector: Option.none(),
      leadName: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      site: Option.none(),
      memo: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      salesRep: Option.none(),
      color: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      customFields: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      number: Option.none(),
      accepted: Option.none(),
      probability: Option.none(),
      priority: Option.none(),
      dueDate: Option.none(),
      closeDate: Option.none(),
      value: Option.none(),
      stage: Option.none(),
      status: Option.none(),
      description: Option.none(),
      nextStep: Option.none(),
      favorite: Option.none(),
      dateAdded: Option.none(),
      taxRate: Option.none(),
      sector: Option.none(),
      leadName: Option.none(),
      phones: Option.none(),
      email: Option.none(),
      leadSource: Option.none(),
      site: Option.none(),
      memo: Option.none(),
      needsReview: Option.none(),
      hasAlert: Option.none(),
      salesRep: Option.none(),
      color: Option.none(),
      accountType: Option.none(),
      subtype: Option.none(),
      isTaxExempt: Option.none(),
      paymentTerms: Option.none(),
      tags: Option.none(),
      customFields: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      number: {
        path: ["number"] as const,
        name: "number",
        constraints: { required: true },

        get: () => data.number,
        set: (value: number | null) => {
          data.number = value;
        },
        getError: () => errors.number,
        setError: (value: Option<Array<string>>) => {
          errors.number = value;
        },
        getTainted: () => tainted.number,
        setTainted: (value: Option<boolean>) => {
          tainted.number = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "number")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("number", data.number);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      accepted: {
        path: ["accepted"] as const,
        name: "accepted",
        constraints: { required: true },

        get: () => data.accepted,
        set: (value: boolean) => {
          data.accepted = value;
        },
        getError: () => errors.accepted,
        setError: (value: Option<Array<string>>) => {
          errors.accepted = value;
        },
        getTainted: () => tainted.accepted,
        setTainted: (value: Option<boolean>) => {
          tainted.accepted = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "accepted")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("accepted", data.accepted);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      probability: {
        path: ["probability"] as const,
        name: "probability",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Probability",
>>>>>>> Stashed changes
        get: () => data.probability,
        set: (value: number) => {
          data.probability = value;
        },
        getError: () => errors.probability,
        setError: (value: Option<Array<string>>) => {
          errors.probability = value;
        },
        getTainted: () => tainted.probability,
        setTainted: (value: Option<boolean>) => {
          tainted.probability = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "probability")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField(
            "probability",
            data.probability,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      priority: {
        path: ["priority"] as const,
        name: "priority",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Priority",
>>>>>>> Stashed changes
        get: () => data.priority,
        set: (value: Priority) => {
          data.priority = value;
        },
        getError: () => errors.priority,
        setError: (value: Option<Array<string>>) => {
          errors.priority = value;
        },
        getTainted: () => tainted.priority,
        setTainted: (value: Option<boolean>) => {
          tainted.priority = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "priority")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("priority", data.priority);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      dueDate: {
        path: ["dueDate"] as const,
        name: "dueDate",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Due Date",
>>>>>>> Stashed changes
        get: () => data.dueDate,
        set: (value: string | null) => {
          data.dueDate = value;
        },
        getError: () => errors.dueDate,
        setError: (value: Option<Array<string>>) => {
          errors.dueDate = value;
        },
        getTainted: () => tainted.dueDate,
        setTainted: (value: Option<boolean>) => {
          tainted.dueDate = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "dueDate")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("dueDate", data.dueDate);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      closeDate: {
        path: ["closeDate"] as const,
        name: "closeDate",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Close Date",
>>>>>>> Stashed changes
        get: () => data.closeDate,
        set: (value: string | null) => {
          data.closeDate = value;
        },
        getError: () => errors.closeDate,
        setError: (value: Option<Array<string>>) => {
          errors.closeDate = value;
        },
        getTainted: () => tainted.closeDate,
        setTainted: (value: Option<boolean>) => {
          tainted.closeDate = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "closeDate")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("closeDate", data.closeDate);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      value: {
        path: ["value"] as const,
        name: "value",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Value",
>>>>>>> Stashed changes
        get: () => data.value,
        set: (value: number) => {
          data.value = value;
        },
        getError: () => errors.value,
        setError: (value: Option<Array<string>>) => {
          errors.value = value;
        },
        getTainted: () => tainted.value,
        setTainted: (value: Option<boolean>) => {
          tainted.value = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "value")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("value", data.value);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      stage: {
        path: ["stage"] as const,
        name: "stage",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Stage",
>>>>>>> Stashed changes
        get: () => data.stage,
        set: (value: LeadStage) => {
          data.stage = value;
        },
        getError: () => errors.stage,
        setError: (value: Option<Array<string>>) => {
          errors.stage = value;
        },
        getTainted: () => tainted.stage,
        setTainted: (value: Option<boolean>) => {
          tainted.stage = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "stage")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("stage", data.stage);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      status: {
        path: ["status"] as const,
        name: "status",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Status",
>>>>>>> Stashed changes
        get: () => data.status,
        set: (value: string) => {
          data.status = value;
        },
        getError: () => errors.status,
        setError: (value: Option<Array<string>>) => {
          errors.status = value;
        },
        getTainted: () => tainted.status,
        setTainted: (value: Option<boolean>) => {
          tainted.status = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "status")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("status", data.status);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Description",
>>>>>>> Stashed changes
        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "description")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      nextStep: {
        path: ["nextStep"] as const,
        name: "nextStep",
        constraints: { required: true },

        get: () => data.nextStep,
        set: (value: NextStep) => {
          data.nextStep = value;
        },
        getError: () => errors.nextStep,
        setError: (value: Option<Array<string>>) => {
          errors.nextStep = value;
        },
        getTainted: () => tainted.nextStep,
        setTainted: (value: Option<boolean>) => {
          tainted.nextStep = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "nextStep")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("nextStep", data.nextStep);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      favorite: {
        path: ["favorite"] as const,
        name: "favorite",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Favorite",
>>>>>>> Stashed changes
        get: () => data.favorite,
        set: (value: boolean) => {
          data.favorite = value;
        },
        getError: () => errors.favorite,
        setError: (value: Option<Array<string>>) => {
          errors.favorite = value;
        },
        getTainted: () => tainted.favorite,
        setTainted: (value: Option<boolean>) => {
          tainted.favorite = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "favorite")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("favorite", data.favorite);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      dateAdded: {
        path: ["dateAdded"] as const,
        name: "dateAdded",
        constraints: { required: true },

        get: () => data.dateAdded,
        set: (value: string | null) => {
          data.dateAdded = value;
        },
        getError: () => errors.dateAdded,
        setError: (value: Option<Array<string>>) => {
          errors.dateAdded = value;
        },
        getTainted: () => tainted.dateAdded,
        setTainted: (value: Option<boolean>) => {
          tainted.dateAdded = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "dateAdded")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("dateAdded", data.dateAdded);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      taxRate: {
        path: ["taxRate"] as const,
        name: "taxRate",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Tax Rate",
>>>>>>> Stashed changes
        get: () => data.taxRate,
        set: (value: (string | TaxRate) | null) => {
          data.taxRate = value;
        },
        getError: () => errors.taxRate,
        setError: (value: Option<Array<string>>) => {
          errors.taxRate = value;
        },
        getTainted: () => tainted.taxRate,
        setTainted: (value: Option<boolean>) => {
          tainted.taxRate = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "taxRate")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("taxRate", data.taxRate);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      sector: {
        path: ["sector"] as const,
        name: "sector",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Sector",
>>>>>>> Stashed changes
        get: () => data.sector,
        set: (value: Sector) => {
          data.sector = value;
        },
        getError: () => errors.sector,
        setError: (value: Option<Array<string>>) => {
          errors.sector = value;
        },
        getTainted: () => tainted.sector,
        setTainted: (value: Option<boolean>) => {
          tainted.sector = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "sector")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("sector", data.sector);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      leadName: {
        path: ["leadName"] as const,
        name: "leadName",
        constraints: { required: true },

        get: () => data.leadName,
        set: (value: AccountName) => {
          data.leadName = value;
        },
        getError: () => errors.leadName,
        setError: (value: Option<Array<string>>) => {
          errors.leadName = value;
        },
        getTainted: () => tainted.leadName,
        setTainted: (value: Option<boolean>) => {
          tainted.leadName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "leadName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("leadName", data.leadName);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "phones")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("phones", data.phones);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index],
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.phones[a], data.phones[b]] = [data.phones[b], data.phones[a]];
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Email",
>>>>>>> Stashed changes
        get: () => data.email,
        set: (value: Email) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "email")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("email", data.email);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      leadSource: {
        path: ["leadSource"] as const,
        name: "leadSource",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Lead Source",
>>>>>>> Stashed changes
        get: () => data.leadSource,
        set: (value: string | null) => {
          data.leadSource = value;
        },
        getError: () => errors.leadSource,
        setError: (value: Option<Array<string>>) => {
          errors.leadSource = value;
        },
        getTainted: () => tainted.leadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.leadSource = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "leadSource")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("leadSource", data.leadSource);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      site: {
        path: ["site"] as const,
        name: "site",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Site",
>>>>>>> Stashed changes
        get: () => data.site,
        set: (value: string | Site) => {
          data.site = value;
        },
        getError: () => errors.site,
        setError: (value: Option<Array<string>>) => {
          errors.site = value;
        },
        getTainted: () => tainted.site,
        setTainted: (value: Option<boolean>) => {
          tainted.site = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "site")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("site", data.site);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      memo: {
        path: ["memo"] as const,
        name: "memo",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Memo",
>>>>>>> Stashed changes
        get: () => data.memo,
        set: (value: string) => {
          data.memo = value;
        },
        getError: () => errors.memo,
        setError: (value: Option<Array<string>>) => {
          errors.memo = value;
        },
        getTainted: () => tainted.memo,
        setTainted: (value: Option<boolean>) => {
          tainted.memo = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "memo")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("memo", data.memo);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      needsReview: {
        path: ["needsReview"] as const,
        name: "needsReview",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Needs Review",
>>>>>>> Stashed changes
        get: () => data.needsReview,
        set: (value: boolean) => {
          data.needsReview = value;
        },
        getError: () => errors.needsReview,
        setError: (value: Option<Array<string>>) => {
          errors.needsReview = value;
        },
        getTainted: () => tainted.needsReview,
        setTainted: (value: Option<boolean>) => {
          tainted.needsReview = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "needsReview")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField(
            "needsReview",
            data.needsReview,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasAlert: {
        path: ["hasAlert"] as const,
        name: "hasAlert",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Has Alert",
>>>>>>> Stashed changes
        get: () => data.hasAlert,
        set: (value: boolean) => {
          data.hasAlert = value;
        },
        getError: () => errors.hasAlert,
        setError: (value: Option<Array<string>>) => {
          errors.hasAlert = value;
        },
        getTainted: () => tainted.hasAlert,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAlert = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasAlert")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("hasAlert", data.hasAlert);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Sales Rep",
>>>>>>> Stashed changes
        get: () => data.salesRep,
        set: (value: Represents[] | null) => {
          data.salesRep = value;
        },
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "salesRep")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("salesRep", data.salesRep);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      color: {
        path: ["color"] as const,
        name: "color",
        constraints: { required: true },

        get: () => data.color,
        set: (value: string | null) => {
          data.color = value;
        },
        getError: () => errors.color,
        setError: (value: Option<Array<string>>) => {
          errors.color = value;
        },
        getTainted: () => tainted.color,
        setTainted: (value: Option<boolean>) => {
          tainted.color = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "color")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("color", data.color);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      accountType: {
        path: ["accountType"] as const,
        name: "accountType",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Account Type",
>>>>>>> Stashed changes
        get: () => data.accountType,
        set: (value: string) => {
          data.accountType = value;
        },
        getError: () => errors.accountType,
        setError: (value: Option<Array<string>>) => {
          errors.accountType = value;
        },
        getTainted: () => tainted.accountType,
        setTainted: (value: Option<boolean>) => {
          tainted.accountType = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "accountType")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField(
            "accountType",
            data.accountType,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      subtype: {
        path: ["subtype"] as const,
        name: "subtype",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Subtype",
>>>>>>> Stashed changes
        get: () => data.subtype,
        set: (value: string) => {
          data.subtype = value;
        },
        getError: () => errors.subtype,
        setError: (value: Option<Array<string>>) => {
          errors.subtype = value;
        },
        getTainted: () => tainted.subtype,
        setTainted: (value: Option<boolean>) => {
          tainted.subtype = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "subtype")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("subtype", data.subtype);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      isTaxExempt: {
        path: ["isTaxExempt"] as const,
        name: "isTaxExempt",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Tax Exempt",
>>>>>>> Stashed changes
        get: () => data.isTaxExempt,
        set: (value: boolean) => {
          data.isTaxExempt = value;
        },
        getError: () => errors.isTaxExempt,
        setError: (value: Option<Array<string>>) => {
          errors.isTaxExempt = value;
        },
        getTainted: () => tainted.isTaxExempt,
        setTainted: (value: Option<boolean>) => {
          tainted.isTaxExempt = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "isTaxExempt")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField(
            "isTaxExempt",
            data.isTaxExempt,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      paymentTerms: {
        path: ["paymentTerms"] as const,
        name: "paymentTerms",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Payment Terms",
>>>>>>> Stashed changes
        get: () => data.paymentTerms,
        set: (value: string) => {
          data.paymentTerms = value;
        },
        getError: () => errors.paymentTerms,
        setError: (value: Option<Array<string>>) => {
          errors.paymentTerms = value;
        },
        getTainted: () => tainted.paymentTerms,
        setTainted: (value: Option<boolean>) => {
          tainted.paymentTerms = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "paymentTerms")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField(
            "paymentTerms",
            data.paymentTerms,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      tags: {
        path: ["tags"] as const,
        name: "tags",
        constraints: { required: true },
<<<<<<< Updated upstream

=======
        label: "Tags",
>>>>>>> Stashed changes
        get: () => data.tags,
        set: (value: string[]) => {
          data.tags = value;
        },
        getError: () => errors.tags,
        setError: (value: Option<Array<string>>) => {
          errors.tags = value;
        },
        getTainted: () => tainted.tags,
        setTainted: (value: Option<boolean>) => {
          tainted.tags = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "tags")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField("tags", data.tags);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["tags", index] as const,
          name: `tags.${index}`,
          constraints: { required: true },
          get: () => data.tags[index],
          set: (value: string) => {
            data.tags[index] = value;
          },
          getError: () => errors.tags,
          setError: (value: Option<Array<string>>) => {
            errors.tags = value;
          },
          getTainted: () => tainted.tags,
          setTainted: (value: Option<boolean>) => {
            tainted.tags = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.tags.push(item);
        },
        remove: (index: number) => {
          data.tags.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.tags[a], data.tags[b]] = [data.tags[b], data.tags[a]];
        },
      },
      customFields: {
        path: ["customFields"] as const,
        name: "customFields",
        constraints: { required: true },

        get: () => data.customFields,
        set: (value: [string, string][]) => {
          data.customFields = value;
        },
        getError: () => errors.customFields,
        setError: (value: Option<Array<string>>) => {
          errors.customFields = value;
        },
        getTainted: () => tainted.customFields,
        setTainted: (value: Option<boolean>) => {
          tainted.customFields = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Lead.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "customFields")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Lead.validateField(
            "customFields",
            data.customFields,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["customFields", index] as const,
          name: `customFields.${index}`,
          constraints: { required: true },
          get: () => data.customFields[index],
          set: (value: [string, string]) => {
            data.customFields[index] = value;
          },
          getError: () => errors.customFields,
          setError: (value: Option<Array<string>>) => {
            errors.customFields = value;
          },
          getTainted: () => tainted.customFields,
          setTainted: (value: Option<boolean>) => {
            tainted.customFields = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: [string, string]) => {
          data.customFields.push(item);
        },
        remove: (index: number) => {
          data.customFields.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.customFields[a], data.customFields[b]] = [
            data.customFields[b],
            data.customFields[a],
          ];
        },
      },
    };
    function validate(): Result<
      Lead,
      Array<{ field: string; message: string }>
    > {
      return Lead.fromObject(data);
    }
    function reset(newOverrides?: Partial<Lead>): void {
      data = { ...Lead.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        number: Option.none(),
        accepted: Option.none(),
        probability: Option.none(),
        priority: Option.none(),
        dueDate: Option.none(),
        closeDate: Option.none(),
        value: Option.none(),
        stage: Option.none(),
        status: Option.none(),
        description: Option.none(),
        nextStep: Option.none(),
        favorite: Option.none(),
        dateAdded: Option.none(),
        taxRate: Option.none(),
        sector: Option.none(),
        leadName: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        site: Option.none(),
        memo: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        salesRep: Option.none(),
        color: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        customFields: Option.none(),
      };
      tainted = {
        id: Option.none(),
        number: Option.none(),
        accepted: Option.none(),
        probability: Option.none(),
        priority: Option.none(),
        dueDate: Option.none(),
        closeDate: Option.none(),
        value: Option.none(),
        stage: Option.none(),
        status: Option.none(),
        description: Option.none(),
        nextStep: Option.none(),
        favorite: Option.none(),
        dateAdded: Option.none(),
        taxRate: Option.none(),
        sector: Option.none(),
        leadName: Option.none(),
        phones: Option.none(),
        email: Option.none(),
        leadSource: Option.none(),
        site: Option.none(),
        memo: Option.none(),
        needsReview: Option.none(),
        hasAlert: Option.none(),
        salesRep: Option.none(),
        color: Option.none(),
        accountType: Option.none(),
        subtype: Option.none(),
        isTaxExempt: Option.none(),
        paymentTerms: Option.none(),
        tags: Option.none(),
        customFields: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Lead, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    {
      const numberStr = formData.get("number");
      obj.number = numberStr ? parseFloat(numberStr as string) : 0;
      if (obj.number !== undefined && isNaN(obj.number as number))
        obj.number = 0;
    }
    {
      const acceptedVal = formData.get("accepted");
      obj.accepted =
        acceptedVal === "true" || acceptedVal === "on" || acceptedVal === "1";
    }
    {
      const probabilityStr = formData.get("probability");
      obj.probability = probabilityStr
        ? parseFloat(probabilityStr as string)
        : 0;
      if (obj.probability !== undefined && isNaN(obj.probability as number))
        obj.probability = 0;
    }
    {
      // Collect nested object fields with prefix "priority."
      const priorityObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("priority.")) {
          const fieldName = key.slice("priority.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = priorityObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.priority = priorityObj;
    }
    obj.dueDate = formData.get("dueDate") ?? "";
    obj.closeDate = formData.get("closeDate") ?? "";
    {
      const valueStr = formData.get("value");
      obj.value = valueStr ? parseFloat(valueStr as string) : 0;
      if (obj.value !== undefined && isNaN(obj.value as number)) obj.value = 0;
    }
    {
      // Collect nested object fields with prefix "stage."
      const stageObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("stage.")) {
          const fieldName = key.slice("stage.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = stageObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.stage = stageObj;
    }
    obj.status = formData.get("status") ?? "";
    obj.description = formData.get("description") ?? "";
    {
      // Collect nested object fields with prefix "nextStep."
      const nextStepObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("nextStep.")) {
          const fieldName = key.slice("nextStep.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = nextStepObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.nextStep = nextStepObj;
    }
    {
      const favoriteVal = formData.get("favorite");
      obj.favorite =
        favoriteVal === "true" || favoriteVal === "on" || favoriteVal === "1";
    }
    obj.dateAdded = formData.get("dateAdded") ?? "";
    obj.taxRate = formData.get("taxRate") ?? "";
    {
      // Collect nested object fields with prefix "sector."
      const sectorObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("sector.")) {
          const fieldName = key.slice("sector.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = sectorObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.sector = sectorObj;
    }
    {
      // Collect nested object fields with prefix "leadName."
      const leadNameObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("leadName.")) {
          const fieldName = key.slice("leadName.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = leadNameObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.leadName = leadNameObj;
    }
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.email = emailObj;
    }
    obj.leadSource = formData.get("leadSource") ?? "";
    obj.site = formData.get("site") ?? "";
    obj.memo = formData.get("memo") ?? "";
    {
      const needsReviewVal = formData.get("needsReview");
      obj.needsReview =
        needsReviewVal === "true" ||
        needsReviewVal === "on" ||
        needsReviewVal === "1";
    }
    {
      const hasAlertVal = formData.get("hasAlert");
      obj.hasAlert =
        hasAlertVal === "true" || hasAlertVal === "on" || hasAlertVal === "1";
    }
    obj.salesRep = formData.get("salesRep") ?? "";
    obj.color = formData.get("color") ?? "";
    obj.accountType = formData.get("accountType") ?? "";
    obj.subtype = formData.get("subtype") ?? "";
    {
      const isTaxExemptVal = formData.get("isTaxExempt");
      obj.isTaxExempt =
        isTaxExemptVal === "true" ||
        isTaxExemptVal === "on" ||
        isTaxExemptVal === "1";
    }
    obj.paymentTerms = formData.get("paymentTerms") ?? "";
    obj.tags = formData.getAll("tags") as Array<string>;
    {
      // Collect array items from indexed form fields
      const customFieldsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("customFields." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("customFields." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("customFields." + idx + ".")) {
              const fieldName = key.slice(
                "customFields.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          customFieldsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.customFields = customFieldsItems;
    }
    return Lead.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface AppPermissions {
  applications: Applications[];
  pages: Page[];
  data: Table[];
}

export namespace AppPermissions {
  export function defaultValue(): AppPermissions {
    return { applications: [], pages: [], data: [] } as AppPermissions;
  }
}

export namespace AppPermissions {
  export function toStringifiedJSON(self: AppPermissions): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: AppPermissions): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: AppPermissions,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "AppPermissions", __id };
    result["applications"] = self.applications.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["pages"] = self.pages.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["data"] = self.data.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    return result;
  }
}

export namespace AppPermissions {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<AppPermissions, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<AppPermissions, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "AppPermissions.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): AppPermissions | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "AppPermissions.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("applications" in obj)) {
      errors.push({ field: "applications", message: "missing required field" });
    }
    if (!("pages" in obj)) {
      errors.push({ field: "pages", message: "missing required field" });
    }
    if (!("data" in obj)) {
      errors.push({ field: "data", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_applications = obj["applications"];
      instance.applications = __raw_applications;
    }
    {
      const __raw_pages = obj["pages"];
      instance.pages = __raw_pages;
    }
    {
      const __raw_data = obj["data"];
      instance.data = __raw_data;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as AppPermissions;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof AppPermissions>(
    field: K,
    value: AppPermissions[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<AppPermissions>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace AppPermissions {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    applications: Option<Array<string>>;
    pages: Option<Array<string>>;
    data: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      applications: Option<boolean>;
      pages: Option<boolean>;
      data: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly applications: ArrayFieldController<Applications>;
    readonly pages: ArrayFieldController<Page>;
    readonly data: ArrayFieldController<Table>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: AppPermissions;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      AppPermissions,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<AppPermissions>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<AppPermissions>,
  ): Gigaform {
    let data = $state({ ...AppPermissions.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      applications: Option.none(),
      pages: Option.none(),
      data: Option.none(),
    });
    let tainted = $state<Tainted>({
      applications: Option.none(),
      pages: Option.none(),
      data: Option.none(),
    });
    const fields: FieldControllers = {
      applications: {
        path: ["applications"] as const,
        name: "applications",
        constraints: { required: true },

        get: () => data.applications,
        set: (value: Applications[]) => {
          data.applications = value;
        },
        getError: () => errors.applications,
        setError: (value: Option<Array<string>>) => {
          errors.applications = value;
        },
        getTainted: () => tainted.applications,
        setTainted: (value: Option<boolean>) => {
          tainted.applications = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = AppPermissions.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "applications")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = AppPermissions.validateField(
            "applications",
            data.applications,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["applications", index] as const,
          name: `applications.${index}`,
          constraints: { required: true },
          get: () => data.applications[index],
          set: (value: Applications) => {
            data.applications[index] = value;
          },
          getError: () => errors.applications,
          setError: (value: Option<Array<string>>) => {
            errors.applications = value;
          },
          getTainted: () => tainted.applications,
          setTainted: (value: Option<boolean>) => {
            tainted.applications = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Applications) => {
          data.applications.push(item);
        },
        remove: (index: number) => {
          data.applications.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.applications[a], data.applications[b]] = [
            data.applications[b],
            data.applications[a],
          ];
        },
      },
      pages: {
        path: ["pages"] as const,
        name: "pages",
        constraints: { required: true },

        get: () => data.pages,
        set: (value: Page[]) => {
          data.pages = value;
        },
        getError: () => errors.pages,
        setError: (value: Option<Array<string>>) => {
          errors.pages = value;
        },
        getTainted: () => tainted.pages,
        setTainted: (value: Option<boolean>) => {
          tainted.pages = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = AppPermissions.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "pages")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = AppPermissions.validateField("pages", data.pages);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["pages", index] as const,
          name: `pages.${index}`,
          constraints: { required: true },
          get: () => data.pages[index],
          set: (value: Page) => {
            data.pages[index] = value;
          },
          getError: () => errors.pages,
          setError: (value: Option<Array<string>>) => {
            errors.pages = value;
          },
          getTainted: () => tainted.pages,
          setTainted: (value: Option<boolean>) => {
            tainted.pages = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Page) => {
          data.pages.push(item);
        },
        remove: (index: number) => {
          data.pages.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.pages[a], data.pages[b]] = [data.pages[b], data.pages[a]];
        },
      },
      data: {
        path: ["data"] as const,
        name: "data",
        constraints: { required: true },

        get: () => data.data,
        set: (value: Table[]) => {
          data.data = value;
        },
        getError: () => errors.data,
        setError: (value: Option<Array<string>>) => {
          errors.data = value;
        },
        getTainted: () => tainted.data,
        setTainted: (value: Option<boolean>) => {
          tainted.data = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = AppPermissions.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "data")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = AppPermissions.validateField("data", data.data);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["data", index] as const,
          name: `data.${index}`,
          constraints: { required: true },
          get: () => data.data[index],
          set: (value: Table) => {
            data.data[index] = value;
          },
          getError: () => errors.data,
          setError: (value: Option<Array<string>>) => {
            errors.data = value;
          },
          getTainted: () => tainted.data,
          setTainted: (value: Option<boolean>) => {
            tainted.data = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: Table) => {
          data.data.push(item);
        },
        remove: (index: number) => {
          data.data.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.data[a], data.data[b]] = [data.data[b], data.data[a]];
        },
      },
    };
    function validate(): Result<
      AppPermissions,
      Array<{ field: string; message: string }>
    > {
      return AppPermissions.fromObject(data);
    }
    function reset(newOverrides?: Partial<AppPermissions>): void {
      data = { ...AppPermissions.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        applications: Option.none(),
        pages: Option.none(),
        data: Option.none(),
      };
      tainted = {
        applications: Option.none(),
        pages: Option.none(),
        data: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<AppPermissions, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect array items from indexed form fields
      const applicationsItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("applications." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("applications." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("applications." + idx + ".")) {
              const fieldName = key.slice(
                "applications.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          applicationsItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.applications = applicationsItems;
    }
    {
      // Collect array items from indexed form fields
      const pagesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("pages." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("pages." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("pages." + idx + ".")) {
              const fieldName = key.slice(
                "pages.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          pagesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.pages = pagesItems;
    }
    {
      // Collect array items from indexed form fields
      const dataItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("data." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("data." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("data." + idx + ".")) {
              const fieldName = key.slice(
                "data.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          dataItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.data = dataItems;
    }
    return AppPermissions.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Company {
  id: string;

  legalName: string;

  headquarters: string | Site;
  phones: PhoneNumber[];

  fax: string;

  email: string;

  website: string;

  taxId: string;
  referenceNumber: number;

  postalCodeLookup: string;
  timeZone: string;

  defaultTax: string | TaxRate;

  defaultTaxLocation: string;
  defaultAreaCode: number;

  defaultAccountType: string;

  lookupFormatting: string;

  accountNameFormat: string;
  merchantServiceProvider: string | null;

  dateDisplayStyle: string;
  hasAutoCommission: boolean;
  hasAutoDaylightSavings: boolean;
  hasAutoFmsTracking: boolean;
  hasNotifications: boolean;
  hasRequiredLeadSource: boolean;
  hasRequiredEmail: boolean;
  hasSortServiceItemsAlphabetically: boolean;
  hasAttachOrderToAppointmentEmails: boolean;
  scheduleInterval: number;
  colorsConfig: ColorsConfig;
}

export namespace Company {
  export function defaultValue(): Company {
    return {
      id: "",
      legalName: "",
      headquarters: "",
      phones: [],
      fax: "",
      email: "",
      website: "",
      taxId: "",
      referenceNumber: 0,
      postalCodeLookup: "",
      timeZone: "",
      defaultTax: "",
      defaultTaxLocation: "",
      defaultAreaCode: 0,
      defaultAccountType: "",
      lookupFormatting: "",
      accountNameFormat: "",
      merchantServiceProvider: null,
      dateDisplayStyle: "",
      hasAutoCommission: false,
      hasAutoDaylightSavings: false,
      hasAutoFmsTracking: false,
      hasNotifications: false,
      hasRequiredLeadSource: false,
      hasRequiredEmail: false,
      hasSortServiceItemsAlphabetically: false,
      hasAttachOrderToAppointmentEmails: false,
      scheduleInterval: 0,
      colorsConfig: ColorsConfig.defaultValue(),
    } as Company;
  }
}

export namespace Company {
  export function toStringifiedJSON(self: Company): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Company): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Company,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Company", __id };
    result["id"] = self.id;
    result["legalName"] = self.legalName;
    result["headquarters"] = self.headquarters;
    result["phones"] = self.phones.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["fax"] = self.fax;
    result["email"] = self.email;
    result["website"] = self.website;
    result["taxId"] = self.taxId;
    result["referenceNumber"] = self.referenceNumber;
    result["postalCodeLookup"] = self.postalCodeLookup;
    result["timeZone"] = self.timeZone;
    result["defaultTax"] = self.defaultTax;
    result["defaultTaxLocation"] = self.defaultTaxLocation;
    result["defaultAreaCode"] = self.defaultAreaCode;
    result["defaultAccountType"] = self.defaultAccountType;
    result["lookupFormatting"] = self.lookupFormatting;
    result["accountNameFormat"] = self.accountNameFormat;
    if (self.merchantServiceProvider !== null) {
      result["merchantServiceProvider"] =
        typeof (self.merchantServiceProvider as any)?.__serialize === "function"
          ? (self.merchantServiceProvider as any).__serialize(ctx)
          : self.merchantServiceProvider;
    } else {
      result["merchantServiceProvider"] = null;
    }
    result["dateDisplayStyle"] = self.dateDisplayStyle;
    result["hasAutoCommission"] = self.hasAutoCommission;
    result["hasAutoDaylightSavings"] = self.hasAutoDaylightSavings;
    result["hasAutoFmsTracking"] = self.hasAutoFmsTracking;
    result["hasNotifications"] = self.hasNotifications;
    result["hasRequiredLeadSource"] = self.hasRequiredLeadSource;
    result["hasRequiredEmail"] = self.hasRequiredEmail;
    result["hasSortServiceItemsAlphabetically"] =
      self.hasSortServiceItemsAlphabetically;
    result["hasAttachOrderToAppointmentEmails"] =
      self.hasAttachOrderToAppointmentEmails;
    result["scheduleInterval"] = self.scheduleInterval;
    result["colorsConfig"] =
      typeof (self.colorsConfig as any)?.__serialize === "function"
        ? (self.colorsConfig as any).__serialize(ctx)
        : self.colorsConfig;
    return result;
  }
}

export namespace Company {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Company, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Company, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Company.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Company | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Company.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("legalName" in obj)) {
      errors.push({ field: "legalName", message: "missing required field" });
    }
    if (!("headquarters" in obj)) {
      errors.push({ field: "headquarters", message: "missing required field" });
    }
    if (!("phones" in obj)) {
      errors.push({ field: "phones", message: "missing required field" });
    }
    if (!("fax" in obj)) {
      errors.push({ field: "fax", message: "missing required field" });
    }
    if (!("email" in obj)) {
      errors.push({ field: "email", message: "missing required field" });
    }
    if (!("website" in obj)) {
      errors.push({ field: "website", message: "missing required field" });
    }
    if (!("taxId" in obj)) {
      errors.push({ field: "taxId", message: "missing required field" });
    }
    if (!("referenceNumber" in obj)) {
      errors.push({
        field: "referenceNumber",
        message: "missing required field",
      });
    }
    if (!("postalCodeLookup" in obj)) {
      errors.push({
        field: "postalCodeLookup",
        message: "missing required field",
      });
    }
    if (!("timeZone" in obj)) {
      errors.push({ field: "timeZone", message: "missing required field" });
    }
    if (!("defaultTax" in obj)) {
      errors.push({ field: "defaultTax", message: "missing required field" });
    }
    if (!("defaultTaxLocation" in obj)) {
      errors.push({
        field: "defaultTaxLocation",
        message: "missing required field",
      });
    }
    if (!("defaultAreaCode" in obj)) {
      errors.push({
        field: "defaultAreaCode",
        message: "missing required field",
      });
    }
    if (!("defaultAccountType" in obj)) {
      errors.push({
        field: "defaultAccountType",
        message: "missing required field",
      });
    }
    if (!("lookupFormatting" in obj)) {
      errors.push({
        field: "lookupFormatting",
        message: "missing required field",
      });
    }
    if (!("accountNameFormat" in obj)) {
      errors.push({
        field: "accountNameFormat",
        message: "missing required field",
      });
    }
    if (!("merchantServiceProvider" in obj)) {
      errors.push({
        field: "merchantServiceProvider",
        message: "missing required field",
      });
    }
    if (!("dateDisplayStyle" in obj)) {
      errors.push({
        field: "dateDisplayStyle",
        message: "missing required field",
      });
    }
    if (!("hasAutoCommission" in obj)) {
      errors.push({
        field: "hasAutoCommission",
        message: "missing required field",
      });
    }
    if (!("hasAutoDaylightSavings" in obj)) {
      errors.push({
        field: "hasAutoDaylightSavings",
        message: "missing required field",
      });
    }
    if (!("hasAutoFmsTracking" in obj)) {
      errors.push({
        field: "hasAutoFmsTracking",
        message: "missing required field",
      });
    }
    if (!("hasNotifications" in obj)) {
      errors.push({
        field: "hasNotifications",
        message: "missing required field",
      });
    }
    if (!("hasRequiredLeadSource" in obj)) {
      errors.push({
        field: "hasRequiredLeadSource",
        message: "missing required field",
      });
    }
    if (!("hasRequiredEmail" in obj)) {
      errors.push({
        field: "hasRequiredEmail",
        message: "missing required field",
      });
    }
    if (!("hasSortServiceItemsAlphabetically" in obj)) {
      errors.push({
        field: "hasSortServiceItemsAlphabetically",
        message: "missing required field",
      });
    }
    if (!("hasAttachOrderToAppointmentEmails" in obj)) {
      errors.push({
        field: "hasAttachOrderToAppointmentEmails",
        message: "missing required field",
      });
    }
    if (!("scheduleInterval" in obj)) {
      errors.push({
        field: "scheduleInterval",
        message: "missing required field",
      });
    }
    if (!("colorsConfig" in obj)) {
      errors.push({ field: "colorsConfig", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_legalName = obj["legalName"];
      instance.legalName = __raw_legalName;
    }
    {
      const __raw_headquarters = obj["headquarters"];
      instance.headquarters = __raw_headquarters;
    }
    {
      const __raw_phones = obj["phones"];
      instance.phones = __raw_phones;
    }
    {
      const __raw_fax = obj["fax"];
      instance.fax = __raw_fax;
    }
    {
      const __raw_email = obj["email"];
      instance.email = __raw_email;
    }
    {
      const __raw_website = obj["website"];
      instance.website = __raw_website;
    }
    {
      const __raw_taxId = obj["taxId"];
      instance.taxId = __raw_taxId;
    }
    {
      const __raw_referenceNumber = obj["referenceNumber"];
      instance.referenceNumber = __raw_referenceNumber;
    }
    {
      const __raw_postalCodeLookup = obj["postalCodeLookup"];
      instance.postalCodeLookup = __raw_postalCodeLookup;
    }
    {
      const __raw_timeZone = obj["timeZone"];
      instance.timeZone = __raw_timeZone;
    }
    {
      const __raw_defaultTax = obj["defaultTax"];
      instance.defaultTax = __raw_defaultTax;
    }
    {
      const __raw_defaultTaxLocation = obj["defaultTaxLocation"];
      instance.defaultTaxLocation = __raw_defaultTaxLocation;
    }
    {
      const __raw_defaultAreaCode = obj["defaultAreaCode"];
      instance.defaultAreaCode = __raw_defaultAreaCode;
    }
    {
      const __raw_defaultAccountType = obj["defaultAccountType"];
      instance.defaultAccountType = __raw_defaultAccountType;
    }
    {
      const __raw_lookupFormatting = obj["lookupFormatting"];
      instance.lookupFormatting = __raw_lookupFormatting;
    }
    {
      const __raw_accountNameFormat = obj["accountNameFormat"];
      instance.accountNameFormat = __raw_accountNameFormat;
    }
    {
      const __raw_merchantServiceProvider = obj["merchantServiceProvider"];
      instance.merchantServiceProvider = __raw_merchantServiceProvider;
    }
    {
      const __raw_dateDisplayStyle = obj["dateDisplayStyle"];
      instance.dateDisplayStyle = __raw_dateDisplayStyle;
    }
    {
      const __raw_hasAutoCommission = obj["hasAutoCommission"];
      instance.hasAutoCommission = __raw_hasAutoCommission;
    }
    {
      const __raw_hasAutoDaylightSavings = obj["hasAutoDaylightSavings"];
      instance.hasAutoDaylightSavings = __raw_hasAutoDaylightSavings;
    }
    {
      const __raw_hasAutoFmsTracking = obj["hasAutoFmsTracking"];
      instance.hasAutoFmsTracking = __raw_hasAutoFmsTracking;
    }
    {
      const __raw_hasNotifications = obj["hasNotifications"];
      instance.hasNotifications = __raw_hasNotifications;
    }
    {
      const __raw_hasRequiredLeadSource = obj["hasRequiredLeadSource"];
      instance.hasRequiredLeadSource = __raw_hasRequiredLeadSource;
    }
    {
      const __raw_hasRequiredEmail = obj["hasRequiredEmail"];
      instance.hasRequiredEmail = __raw_hasRequiredEmail;
    }
    {
      const __raw_hasSortServiceItemsAlphabetically =
        obj["hasSortServiceItemsAlphabetically"];
      instance.hasSortServiceItemsAlphabetically =
        __raw_hasSortServiceItemsAlphabetically;
    }
    {
      const __raw_hasAttachOrderToAppointmentEmails =
        obj["hasAttachOrderToAppointmentEmails"];
      instance.hasAttachOrderToAppointmentEmails =
        __raw_hasAttachOrderToAppointmentEmails;
    }
    {
      const __raw_scheduleInterval = obj["scheduleInterval"];
      instance.scheduleInterval = __raw_scheduleInterval;
    }
    {
      const __raw_colorsConfig = obj["colorsConfig"];
      if (typeof (ColorsConfig as any)?.__deserialize === "function") {
        const __result = (ColorsConfig as any).__deserialize(
          __raw_colorsConfig,
          ctx,
        );
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "colorsConfig", __result);
=======
        if (PendingRef.is(__result)) {
          instance.colorsConfig = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.colorsConfig = v;
          });
        } else {
          instance.colorsConfig = __result;
        }
>>>>>>> Stashed changes
      } else {
        instance.colorsConfig = __raw_colorsConfig;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Company;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Company>(
    field: K,
    value: Company[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "legalName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "legalName", message: "must not be empty" });
        }
        break;
      }
      case "fax": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "fax", message: "must not be empty" });
        }
        break;
      }
      case "email": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "email", message: "must not be empty" });
        }
        break;
      }
      case "website": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "website", message: "must not be empty" });
        }
        break;
      }
      case "taxId": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "taxId", message: "must not be empty" });
        }
        break;
      }
      case "postalCodeLookup": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "postalCodeLookup",
            message: "must not be empty",
          });
        }
        break;
      }
      case "defaultTaxLocation": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "defaultTaxLocation",
            message: "must not be empty",
          });
        }
        break;
      }
      case "defaultAccountType": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "defaultAccountType",
            message: "must not be empty",
          });
        }
        break;
      }
      case "lookupFormatting": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "lookupFormatting",
            message: "must not be empty",
          });
        }
        break;
      }
      case "accountNameFormat": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "accountNameFormat",
            message: "must not be empty",
          });
        }
        break;
      }
      case "dateDisplayStyle": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "dateDisplayStyle",
            message: "must not be empty",
          });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Company>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("legalName" in partial && partial.legalName !== undefined) {
      const __val = partial.legalName as string;
      if (__val.length === 0) {
        errors.push({ field: "legalName", message: "must not be empty" });
      }
    }
    if ("fax" in partial && partial.fax !== undefined) {
      const __val = partial.fax as string;
      if (__val.length === 0) {
        errors.push({ field: "fax", message: "must not be empty" });
      }
    }
    if ("email" in partial && partial.email !== undefined) {
      const __val = partial.email as string;
      if (__val.length === 0) {
        errors.push({ field: "email", message: "must not be empty" });
      }
    }
    if ("website" in partial && partial.website !== undefined) {
      const __val = partial.website as string;
      if (__val.length === 0) {
        errors.push({ field: "website", message: "must not be empty" });
      }
    }
    if ("taxId" in partial && partial.taxId !== undefined) {
      const __val = partial.taxId as string;
      if (__val.length === 0) {
        errors.push({ field: "taxId", message: "must not be empty" });
      }
    }
    if (
      "postalCodeLookup" in partial &&
      partial.postalCodeLookup !== undefined
    ) {
      const __val = partial.postalCodeLookup as string;
      if (__val.length === 0) {
        errors.push({
          field: "postalCodeLookup",
          message: "must not be empty",
        });
      }
    }
    if (
      "defaultTaxLocation" in partial &&
      partial.defaultTaxLocation !== undefined
    ) {
      const __val = partial.defaultTaxLocation as string;
      if (__val.length === 0) {
        errors.push({
          field: "defaultTaxLocation",
          message: "must not be empty",
        });
      }
    }
    if (
      "defaultAccountType" in partial &&
      partial.defaultAccountType !== undefined
    ) {
      const __val = partial.defaultAccountType as string;
      if (__val.length === 0) {
        errors.push({
          field: "defaultAccountType",
          message: "must not be empty",
        });
      }
    }
    if (
      "lookupFormatting" in partial &&
      partial.lookupFormatting !== undefined
    ) {
      const __val = partial.lookupFormatting as string;
      if (__val.length === 0) {
        errors.push({
          field: "lookupFormatting",
          message: "must not be empty",
        });
      }
    }
    if (
      "accountNameFormat" in partial &&
      partial.accountNameFormat !== undefined
    ) {
      const __val = partial.accountNameFormat as string;
      if (__val.length === 0) {
        errors.push({
          field: "accountNameFormat",
          message: "must not be empty",
        });
      }
    }
    if (
      "dateDisplayStyle" in partial &&
      partial.dateDisplayStyle !== undefined
    ) {
      const __val = partial.dateDisplayStyle as string;
      if (__val.length === 0) {
        errors.push({
          field: "dateDisplayStyle",
          message: "must not be empty",
        });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Company {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    legalName: Option<Array<string>>;
    headquarters: Option<Array<string>>;
    phones: Option<Array<string>>;
    fax: Option<Array<string>>;
    email: Option<Array<string>>;
    website: Option<Array<string>>;
    taxId: Option<Array<string>>;
    referenceNumber: Option<Array<string>>;
    postalCodeLookup: Option<Array<string>>;
    timeZone: Option<Array<string>>;
    defaultTax: Option<Array<string>>;
    defaultTaxLocation: Option<Array<string>>;
    defaultAreaCode: Option<Array<string>>;
    defaultAccountType: Option<Array<string>>;
    lookupFormatting: Option<Array<string>>;
    accountNameFormat: Option<Array<string>>;
    merchantServiceProvider: Option<Array<string>>;
    dateDisplayStyle: Option<Array<string>>;
    hasAutoCommission: Option<Array<string>>;
    hasAutoDaylightSavings: Option<Array<string>>;
    hasAutoFmsTracking: Option<Array<string>>;
    hasNotifications: Option<Array<string>>;
    hasRequiredLeadSource: Option<Array<string>>;
    hasRequiredEmail: Option<Array<string>>;
    hasSortServiceItemsAlphabetically: Option<Array<string>>;
    hasAttachOrderToAppointmentEmails: Option<Array<string>>;
    scheduleInterval: Option<Array<string>>;
    colorsConfig: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      legalName: Option<boolean>;
      headquarters: Option<boolean>;
      phones: Option<boolean>;
      fax: Option<boolean>;
      email: Option<boolean>;
      website: Option<boolean>;
      taxId: Option<boolean>;
      referenceNumber: Option<boolean>;
      postalCodeLookup: Option<boolean>;
      timeZone: Option<boolean>;
      defaultTax: Option<boolean>;
      defaultTaxLocation: Option<boolean>;
      defaultAreaCode: Option<boolean>;
      defaultAccountType: Option<boolean>;
      lookupFormatting: Option<boolean>;
      accountNameFormat: Option<boolean>;
      merchantServiceProvider: Option<boolean>;
      dateDisplayStyle: Option<boolean>;
      hasAutoCommission: Option<boolean>;
      hasAutoDaylightSavings: Option<boolean>;
      hasAutoFmsTracking: Option<boolean>;
      hasNotifications: Option<boolean>;
      hasRequiredLeadSource: Option<boolean>;
      hasRequiredEmail: Option<boolean>;
      hasSortServiceItemsAlphabetically: Option<boolean>;
      hasAttachOrderToAppointmentEmails: Option<boolean>;
      scheduleInterval: Option<boolean>;
      colorsConfig: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly legalName: FieldController<string>;
    readonly headquarters: FieldController<string | Site>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly fax: FieldController<string>;
    readonly email: FieldController<string>;
    readonly website: FieldController<string>;
    readonly taxId: FieldController<string>;
    readonly referenceNumber: FieldController<number>;
    readonly postalCodeLookup: FieldController<string>;
    readonly timeZone: FieldController<string>;
    readonly defaultTax: FieldController<string | TaxRate>;
    readonly defaultTaxLocation: FieldController<string>;
    readonly defaultAreaCode: FieldController<number>;
    readonly defaultAccountType: FieldController<string>;
    readonly lookupFormatting: FieldController<string>;
    readonly accountNameFormat: FieldController<string>;
    readonly merchantServiceProvider: FieldController<string | null>;
    readonly dateDisplayStyle: FieldController<string>;
    readonly hasAutoCommission: FieldController<boolean>;
    readonly hasAutoDaylightSavings: FieldController<boolean>;
    readonly hasAutoFmsTracking: FieldController<boolean>;
    readonly hasNotifications: FieldController<boolean>;
    readonly hasRequiredLeadSource: FieldController<boolean>;
    readonly hasRequiredEmail: FieldController<boolean>;
    readonly hasSortServiceItemsAlphabetically: FieldController<boolean>;
    readonly hasAttachOrderToAppointmentEmails: FieldController<boolean>;
    readonly scheduleInterval: FieldController<number>;
    readonly colorsConfig: FieldController<ColorsConfig>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Company;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Company, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Company>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Company>,
  ): Gigaform {
    let data = $state({ ...Company.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      legalName: Option.none(),
      headquarters: Option.none(),
      phones: Option.none(),
      fax: Option.none(),
      email: Option.none(),
      website: Option.none(),
      taxId: Option.none(),
      referenceNumber: Option.none(),
      postalCodeLookup: Option.none(),
      timeZone: Option.none(),
      defaultTax: Option.none(),
      defaultTaxLocation: Option.none(),
      defaultAreaCode: Option.none(),
      defaultAccountType: Option.none(),
      lookupFormatting: Option.none(),
      accountNameFormat: Option.none(),
      merchantServiceProvider: Option.none(),
      dateDisplayStyle: Option.none(),
      hasAutoCommission: Option.none(),
      hasAutoDaylightSavings: Option.none(),
      hasAutoFmsTracking: Option.none(),
      hasNotifications: Option.none(),
      hasRequiredLeadSource: Option.none(),
      hasRequiredEmail: Option.none(),
      hasSortServiceItemsAlphabetically: Option.none(),
      hasAttachOrderToAppointmentEmails: Option.none(),
      scheduleInterval: Option.none(),
      colorsConfig: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      legalName: Option.none(),
      headquarters: Option.none(),
      phones: Option.none(),
      fax: Option.none(),
      email: Option.none(),
      website: Option.none(),
      taxId: Option.none(),
      referenceNumber: Option.none(),
      postalCodeLookup: Option.none(),
      timeZone: Option.none(),
      defaultTax: Option.none(),
      defaultTaxLocation: Option.none(),
      defaultAreaCode: Option.none(),
      defaultAccountType: Option.none(),
      lookupFormatting: Option.none(),
      accountNameFormat: Option.none(),
      merchantServiceProvider: Option.none(),
      dateDisplayStyle: Option.none(),
      hasAutoCommission: Option.none(),
      hasAutoDaylightSavings: Option.none(),
      hasAutoFmsTracking: Option.none(),
      hasNotifications: Option.none(),
      hasRequiredLeadSource: Option.none(),
      hasRequiredEmail: Option.none(),
      hasSortServiceItemsAlphabetically: Option.none(),
      hasAttachOrderToAppointmentEmails: Option.none(),
      scheduleInterval: Option.none(),
      colorsConfig: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      legalName: {
        path: ["legalName"] as const,
        name: "legalName",
        constraints: { required: true },

        get: () => data.legalName,
        set: (value: string) => {
          data.legalName = value;
        },
        getError: () => errors.legalName,
        setError: (value: Option<Array<string>>) => {
          errors.legalName = value;
        },
        getTainted: () => tainted.legalName,
        setTainted: (value: Option<boolean>) => {
          tainted.legalName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "legalName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "legalName",
            data.legalName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      headquarters: {
        path: ["headquarters"] as const,
        name: "headquarters",
        constraints: { required: true },

        get: () => data.headquarters,
        set: (value: string | Site) => {
          data.headquarters = value;
        },
        getError: () => errors.headquarters,
        setError: (value: Option<Array<string>>) => {
          errors.headquarters = value;
        },
        getTainted: () => tainted.headquarters,
        setTainted: (value: Option<boolean>) => {
          tainted.headquarters = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "headquarters")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "headquarters",
            data.headquarters,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "phones")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField("phones", data.phones);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index],
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.phones[a], data.phones[b]] = [data.phones[b], data.phones[a]];
        },
      },
      fax: {
        path: ["fax"] as const,
        name: "fax",
        constraints: { required: true },

        get: () => data.fax,
        set: (value: string) => {
          data.fax = value;
        },
        getError: () => errors.fax,
        setError: (value: Option<Array<string>>) => {
          errors.fax = value;
        },
        getTainted: () => tainted.fax,
        setTainted: (value: Option<boolean>) => {
          tainted.fax = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "fax")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField("fax", data.fax);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: string) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "email")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField("email", data.email);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      website: {
        path: ["website"] as const,
        name: "website",
        constraints: { required: true },

        get: () => data.website,
        set: (value: string) => {
          data.website = value;
        },
        getError: () => errors.website,
        setError: (value: Option<Array<string>>) => {
          errors.website = value;
        },
        getTainted: () => tainted.website,
        setTainted: (value: Option<boolean>) => {
          tainted.website = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "website")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField("website", data.website);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      taxId: {
        path: ["taxId"] as const,
        name: "taxId",
        constraints: { required: true },

        get: () => data.taxId,
        set: (value: string) => {
          data.taxId = value;
        },
        getError: () => errors.taxId,
        setError: (value: Option<Array<string>>) => {
          errors.taxId = value;
        },
        getTainted: () => tainted.taxId,
        setTainted: (value: Option<boolean>) => {
          tainted.taxId = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "taxId")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField("taxId", data.taxId);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      referenceNumber: {
        path: ["referenceNumber"] as const,
        name: "referenceNumber",
        constraints: { required: true },

        get: () => data.referenceNumber,
        set: (value: number) => {
          data.referenceNumber = value;
        },
        getError: () => errors.referenceNumber,
        setError: (value: Option<Array<string>>) => {
          errors.referenceNumber = value;
        },
        getTainted: () => tainted.referenceNumber,
        setTainted: (value: Option<boolean>) => {
          tainted.referenceNumber = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "referenceNumber")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "referenceNumber",
            data.referenceNumber,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      postalCodeLookup: {
        path: ["postalCodeLookup"] as const,
        name: "postalCodeLookup",
        constraints: { required: true },

        get: () => data.postalCodeLookup,
        set: (value: string) => {
          data.postalCodeLookup = value;
        },
        getError: () => errors.postalCodeLookup,
        setError: (value: Option<Array<string>>) => {
          errors.postalCodeLookup = value;
        },
        getTainted: () => tainted.postalCodeLookup,
        setTainted: (value: Option<boolean>) => {
          tainted.postalCodeLookup = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "postalCodeLookup")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "postalCodeLookup",
            data.postalCodeLookup,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      timeZone: {
        path: ["timeZone"] as const,
        name: "timeZone",
        constraints: { required: true },

        get: () => data.timeZone,
        set: (value: string) => {
          data.timeZone = value;
        },
        getError: () => errors.timeZone,
        setError: (value: Option<Array<string>>) => {
          errors.timeZone = value;
        },
        getTainted: () => tainted.timeZone,
        setTainted: (value: Option<boolean>) => {
          tainted.timeZone = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "timeZone")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField("timeZone", data.timeZone);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      defaultTax: {
        path: ["defaultTax"] as const,
        name: "defaultTax",
        constraints: { required: true },

        get: () => data.defaultTax,
        set: (value: string | TaxRate) => {
          data.defaultTax = value;
        },
        getError: () => errors.defaultTax,
        setError: (value: Option<Array<string>>) => {
          errors.defaultTax = value;
        },
        getTainted: () => tainted.defaultTax,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultTax = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "defaultTax")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "defaultTax",
            data.defaultTax,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      defaultTaxLocation: {
        path: ["defaultTaxLocation"] as const,
        name: "defaultTaxLocation",
        constraints: { required: true },

        get: () => data.defaultTaxLocation,
        set: (value: string) => {
          data.defaultTaxLocation = value;
        },
        getError: () => errors.defaultTaxLocation,
        setError: (value: Option<Array<string>>) => {
          errors.defaultTaxLocation = value;
        },
        getTainted: () => tainted.defaultTaxLocation,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultTaxLocation = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "defaultTaxLocation")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "defaultTaxLocation",
            data.defaultTaxLocation,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      defaultAreaCode: {
        path: ["defaultAreaCode"] as const,
        name: "defaultAreaCode",
        constraints: { required: true },

        get: () => data.defaultAreaCode,
        set: (value: number) => {
          data.defaultAreaCode = value;
        },
        getError: () => errors.defaultAreaCode,
        setError: (value: Option<Array<string>>) => {
          errors.defaultAreaCode = value;
        },
        getTainted: () => tainted.defaultAreaCode,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultAreaCode = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "defaultAreaCode")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "defaultAreaCode",
            data.defaultAreaCode,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      defaultAccountType: {
        path: ["defaultAccountType"] as const,
        name: "defaultAccountType",
        constraints: { required: true },

        get: () => data.defaultAccountType,
        set: (value: string) => {
          data.defaultAccountType = value;
        },
        getError: () => errors.defaultAccountType,
        setError: (value: Option<Array<string>>) => {
          errors.defaultAccountType = value;
        },
        getTainted: () => tainted.defaultAccountType,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultAccountType = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "defaultAccountType")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "defaultAccountType",
            data.defaultAccountType,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      lookupFormatting: {
        path: ["lookupFormatting"] as const,
        name: "lookupFormatting",
        constraints: { required: true },

        get: () => data.lookupFormatting,
        set: (value: string) => {
          data.lookupFormatting = value;
        },
        getError: () => errors.lookupFormatting,
        setError: (value: Option<Array<string>>) => {
          errors.lookupFormatting = value;
        },
        getTainted: () => tainted.lookupFormatting,
        setTainted: (value: Option<boolean>) => {
          tainted.lookupFormatting = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lookupFormatting")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "lookupFormatting",
            data.lookupFormatting,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      accountNameFormat: {
        path: ["accountNameFormat"] as const,
        name: "accountNameFormat",
        constraints: { required: true },

        get: () => data.accountNameFormat,
        set: (value: string) => {
          data.accountNameFormat = value;
        },
        getError: () => errors.accountNameFormat,
        setError: (value: Option<Array<string>>) => {
          errors.accountNameFormat = value;
        },
        getTainted: () => tainted.accountNameFormat,
        setTainted: (value: Option<boolean>) => {
          tainted.accountNameFormat = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "accountNameFormat")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "accountNameFormat",
            data.accountNameFormat,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      merchantServiceProvider: {
        path: ["merchantServiceProvider"] as const,
        name: "merchantServiceProvider",
        constraints: { required: true },

        get: () => data.merchantServiceProvider,
        set: (value: string | null) => {
          data.merchantServiceProvider = value;
        },
        getError: () => errors.merchantServiceProvider,
        setError: (value: Option<Array<string>>) => {
          errors.merchantServiceProvider = value;
        },
        getTainted: () => tainted.merchantServiceProvider,
        setTainted: (value: Option<boolean>) => {
          tainted.merchantServiceProvider = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "merchantServiceProvider")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "merchantServiceProvider",
            data.merchantServiceProvider,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      dateDisplayStyle: {
        path: ["dateDisplayStyle"] as const,
        name: "dateDisplayStyle",
        constraints: { required: true },

        get: () => data.dateDisplayStyle,
        set: (value: string) => {
          data.dateDisplayStyle = value;
        },
        getError: () => errors.dateDisplayStyle,
        setError: (value: Option<Array<string>>) => {
          errors.dateDisplayStyle = value;
        },
        getTainted: () => tainted.dateDisplayStyle,
        setTainted: (value: Option<boolean>) => {
          tainted.dateDisplayStyle = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "dateDisplayStyle")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "dateDisplayStyle",
            data.dateDisplayStyle,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasAutoCommission: {
        path: ["hasAutoCommission"] as const,
        name: "hasAutoCommission",
        constraints: { required: true },

        get: () => data.hasAutoCommission,
        set: (value: boolean) => {
          data.hasAutoCommission = value;
        },
        getError: () => errors.hasAutoCommission,
        setError: (value: Option<Array<string>>) => {
          errors.hasAutoCommission = value;
        },
        getTainted: () => tainted.hasAutoCommission,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAutoCommission = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasAutoCommission")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasAutoCommission",
            data.hasAutoCommission,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasAutoDaylightSavings: {
        path: ["hasAutoDaylightSavings"] as const,
        name: "hasAutoDaylightSavings",
        constraints: { required: true },

        get: () => data.hasAutoDaylightSavings,
        set: (value: boolean) => {
          data.hasAutoDaylightSavings = value;
        },
        getError: () => errors.hasAutoDaylightSavings,
        setError: (value: Option<Array<string>>) => {
          errors.hasAutoDaylightSavings = value;
        },
        getTainted: () => tainted.hasAutoDaylightSavings,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAutoDaylightSavings = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasAutoDaylightSavings")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasAutoDaylightSavings",
            data.hasAutoDaylightSavings,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasAutoFmsTracking: {
        path: ["hasAutoFmsTracking"] as const,
        name: "hasAutoFmsTracking",
        constraints: { required: true },

        get: () => data.hasAutoFmsTracking,
        set: (value: boolean) => {
          data.hasAutoFmsTracking = value;
        },
        getError: () => errors.hasAutoFmsTracking,
        setError: (value: Option<Array<string>>) => {
          errors.hasAutoFmsTracking = value;
        },
        getTainted: () => tainted.hasAutoFmsTracking,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAutoFmsTracking = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasAutoFmsTracking")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasAutoFmsTracking",
            data.hasAutoFmsTracking,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasNotifications: {
        path: ["hasNotifications"] as const,
        name: "hasNotifications",
        constraints: { required: true },

        get: () => data.hasNotifications,
        set: (value: boolean) => {
          data.hasNotifications = value;
        },
        getError: () => errors.hasNotifications,
        setError: (value: Option<Array<string>>) => {
          errors.hasNotifications = value;
        },
        getTainted: () => tainted.hasNotifications,
        setTainted: (value: Option<boolean>) => {
          tainted.hasNotifications = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasNotifications")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasNotifications",
            data.hasNotifications,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasRequiredLeadSource: {
        path: ["hasRequiredLeadSource"] as const,
        name: "hasRequiredLeadSource",
        constraints: { required: true },

        get: () => data.hasRequiredLeadSource,
        set: (value: boolean) => {
          data.hasRequiredLeadSource = value;
        },
        getError: () => errors.hasRequiredLeadSource,
        setError: (value: Option<Array<string>>) => {
          errors.hasRequiredLeadSource = value;
        },
        getTainted: () => tainted.hasRequiredLeadSource,
        setTainted: (value: Option<boolean>) => {
          tainted.hasRequiredLeadSource = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasRequiredLeadSource")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasRequiredLeadSource",
            data.hasRequiredLeadSource,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasRequiredEmail: {
        path: ["hasRequiredEmail"] as const,
        name: "hasRequiredEmail",
        constraints: { required: true },

        get: () => data.hasRequiredEmail,
        set: (value: boolean) => {
          data.hasRequiredEmail = value;
        },
        getError: () => errors.hasRequiredEmail,
        setError: (value: Option<Array<string>>) => {
          errors.hasRequiredEmail = value;
        },
        getTainted: () => tainted.hasRequiredEmail,
        setTainted: (value: Option<boolean>) => {
          tainted.hasRequiredEmail = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasRequiredEmail")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasRequiredEmail",
            data.hasRequiredEmail,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasSortServiceItemsAlphabetically: {
        path: ["hasSortServiceItemsAlphabetically"] as const,
        name: "hasSortServiceItemsAlphabetically",
        constraints: { required: true },

        get: () => data.hasSortServiceItemsAlphabetically,
        set: (value: boolean) => {
          data.hasSortServiceItemsAlphabetically = value;
        },
        getError: () => errors.hasSortServiceItemsAlphabetically,
        setError: (value: Option<Array<string>>) => {
          errors.hasSortServiceItemsAlphabetically = value;
        },
        getTainted: () => tainted.hasSortServiceItemsAlphabetically,
        setTainted: (value: Option<boolean>) => {
          tainted.hasSortServiceItemsAlphabetically = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasSortServiceItemsAlphabetically")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasSortServiceItemsAlphabetically",
            data.hasSortServiceItemsAlphabetically,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      hasAttachOrderToAppointmentEmails: {
        path: ["hasAttachOrderToAppointmentEmails"] as const,
        name: "hasAttachOrderToAppointmentEmails",
        constraints: { required: true },

        get: () => data.hasAttachOrderToAppointmentEmails,
        set: (value: boolean) => {
          data.hasAttachOrderToAppointmentEmails = value;
        },
        getError: () => errors.hasAttachOrderToAppointmentEmails,
        setError: (value: Option<Array<string>>) => {
          errors.hasAttachOrderToAppointmentEmails = value;
        },
        getTainted: () => tainted.hasAttachOrderToAppointmentEmails,
        setTainted: (value: Option<boolean>) => {
          tainted.hasAttachOrderToAppointmentEmails = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "hasAttachOrderToAppointmentEmails")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "hasAttachOrderToAppointmentEmails",
            data.hasAttachOrderToAppointmentEmails,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      scheduleInterval: {
        path: ["scheduleInterval"] as const,
        name: "scheduleInterval",
        constraints: { required: true },

        get: () => data.scheduleInterval,
        set: (value: number) => {
          data.scheduleInterval = value;
        },
        getError: () => errors.scheduleInterval,
        setError: (value: Option<Array<string>>) => {
          errors.scheduleInterval = value;
        },
        getTainted: () => tainted.scheduleInterval,
        setTainted: (value: Option<boolean>) => {
          tainted.scheduleInterval = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "scheduleInterval")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "scheduleInterval",
            data.scheduleInterval,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      colorsConfig: {
        path: ["colorsConfig"] as const,
        name: "colorsConfig",
        constraints: { required: true },

        get: () => data.colorsConfig,
        set: (value: ColorsConfig) => {
          data.colorsConfig = value;
        },
        getError: () => errors.colorsConfig,
        setError: (value: Option<Array<string>>) => {
          errors.colorsConfig = value;
        },
        getTainted: () => tainted.colorsConfig,
        setTainted: (value: Option<boolean>) => {
          tainted.colorsConfig = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Company.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "colorsConfig")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Company.validateField(
            "colorsConfig",
            data.colorsConfig,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Company,
      Array<{ field: string; message: string }>
    > {
      return Company.fromObject(data);
    }
    function reset(newOverrides?: Partial<Company>): void {
      data = { ...Company.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        legalName: Option.none(),
        headquarters: Option.none(),
        phones: Option.none(),
        fax: Option.none(),
        email: Option.none(),
        website: Option.none(),
        taxId: Option.none(),
        referenceNumber: Option.none(),
        postalCodeLookup: Option.none(),
        timeZone: Option.none(),
        defaultTax: Option.none(),
        defaultTaxLocation: Option.none(),
        defaultAreaCode: Option.none(),
        defaultAccountType: Option.none(),
        lookupFormatting: Option.none(),
        accountNameFormat: Option.none(),
        merchantServiceProvider: Option.none(),
        dateDisplayStyle: Option.none(),
        hasAutoCommission: Option.none(),
        hasAutoDaylightSavings: Option.none(),
        hasAutoFmsTracking: Option.none(),
        hasNotifications: Option.none(),
        hasRequiredLeadSource: Option.none(),
        hasRequiredEmail: Option.none(),
        hasSortServiceItemsAlphabetically: Option.none(),
        hasAttachOrderToAppointmentEmails: Option.none(),
        scheduleInterval: Option.none(),
        colorsConfig: Option.none(),
      };
      tainted = {
        id: Option.none(),
        legalName: Option.none(),
        headquarters: Option.none(),
        phones: Option.none(),
        fax: Option.none(),
        email: Option.none(),
        website: Option.none(),
        taxId: Option.none(),
        referenceNumber: Option.none(),
        postalCodeLookup: Option.none(),
        timeZone: Option.none(),
        defaultTax: Option.none(),
        defaultTaxLocation: Option.none(),
        defaultAreaCode: Option.none(),
        defaultAccountType: Option.none(),
        lookupFormatting: Option.none(),
        accountNameFormat: Option.none(),
        merchantServiceProvider: Option.none(),
        dateDisplayStyle: Option.none(),
        hasAutoCommission: Option.none(),
        hasAutoDaylightSavings: Option.none(),
        hasAutoFmsTracking: Option.none(),
        hasNotifications: Option.none(),
        hasRequiredLeadSource: Option.none(),
        hasRequiredEmail: Option.none(),
        hasSortServiceItemsAlphabetically: Option.none(),
        hasAttachOrderToAppointmentEmails: Option.none(),
        scheduleInterval: Option.none(),
        colorsConfig: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Company, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.legalName = formData.get("legalName") ?? "";
    obj.headquarters = formData.get("headquarters") ?? "";
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    obj.fax = formData.get("fax") ?? "";
    obj.email = formData.get("email") ?? "";
    obj.website = formData.get("website") ?? "";
    obj.taxId = formData.get("taxId") ?? "";
    {
      const referenceNumberStr = formData.get("referenceNumber");
      obj.referenceNumber = referenceNumberStr
        ? parseFloat(referenceNumberStr as string)
        : 0;
      if (
        obj.referenceNumber !== undefined &&
        isNaN(obj.referenceNumber as number)
      )
        obj.referenceNumber = 0;
    }
    obj.postalCodeLookup = formData.get("postalCodeLookup") ?? "";
    obj.timeZone = formData.get("timeZone") ?? "";
    obj.defaultTax = formData.get("defaultTax") ?? "";
    obj.defaultTaxLocation = formData.get("defaultTaxLocation") ?? "";
    {
      const defaultAreaCodeStr = formData.get("defaultAreaCode");
      obj.defaultAreaCode = defaultAreaCodeStr
        ? parseFloat(defaultAreaCodeStr as string)
        : 0;
      if (
        obj.defaultAreaCode !== undefined &&
        isNaN(obj.defaultAreaCode as number)
      )
        obj.defaultAreaCode = 0;
    }
    obj.defaultAccountType = formData.get("defaultAccountType") ?? "";
    obj.lookupFormatting = formData.get("lookupFormatting") ?? "";
    obj.accountNameFormat = formData.get("accountNameFormat") ?? "";
    obj.merchantServiceProvider = formData.get("merchantServiceProvider") ?? "";
    obj.dateDisplayStyle = formData.get("dateDisplayStyle") ?? "";
    {
      const hasAutoCommissionVal = formData.get("hasAutoCommission");
      obj.hasAutoCommission =
        hasAutoCommissionVal === "true" ||
        hasAutoCommissionVal === "on" ||
        hasAutoCommissionVal === "1";
    }
    {
      const hasAutoDaylightSavingsVal = formData.get("hasAutoDaylightSavings");
      obj.hasAutoDaylightSavings =
        hasAutoDaylightSavingsVal === "true" ||
        hasAutoDaylightSavingsVal === "on" ||
        hasAutoDaylightSavingsVal === "1";
    }
    {
      const hasAutoFmsTrackingVal = formData.get("hasAutoFmsTracking");
      obj.hasAutoFmsTracking =
        hasAutoFmsTrackingVal === "true" ||
        hasAutoFmsTrackingVal === "on" ||
        hasAutoFmsTrackingVal === "1";
    }
    {
      const hasNotificationsVal = formData.get("hasNotifications");
      obj.hasNotifications =
        hasNotificationsVal === "true" ||
        hasNotificationsVal === "on" ||
        hasNotificationsVal === "1";
    }
    {
      const hasRequiredLeadSourceVal = formData.get("hasRequiredLeadSource");
      obj.hasRequiredLeadSource =
        hasRequiredLeadSourceVal === "true" ||
        hasRequiredLeadSourceVal === "on" ||
        hasRequiredLeadSourceVal === "1";
    }
    {
      const hasRequiredEmailVal = formData.get("hasRequiredEmail");
      obj.hasRequiredEmail =
        hasRequiredEmailVal === "true" ||
        hasRequiredEmailVal === "on" ||
        hasRequiredEmailVal === "1";
    }
    {
      const hasSortServiceItemsAlphabeticallyVal = formData.get(
        "hasSortServiceItemsAlphabetically",
      );
      obj.hasSortServiceItemsAlphabetically =
        hasSortServiceItemsAlphabeticallyVal === "true" ||
        hasSortServiceItemsAlphabeticallyVal === "on" ||
        hasSortServiceItemsAlphabeticallyVal === "1";
    }
    {
      const hasAttachOrderToAppointmentEmailsVal = formData.get(
        "hasAttachOrderToAppointmentEmails",
      );
      obj.hasAttachOrderToAppointmentEmails =
        hasAttachOrderToAppointmentEmailsVal === "true" ||
        hasAttachOrderToAppointmentEmailsVal === "on" ||
        hasAttachOrderToAppointmentEmailsVal === "1";
    }
    {
      const scheduleIntervalStr = formData.get("scheduleInterval");
      obj.scheduleInterval = scheduleIntervalStr
        ? parseFloat(scheduleIntervalStr as string)
        : 0;
      if (
        obj.scheduleInterval !== undefined &&
        isNaN(obj.scheduleInterval as number)
      )
        obj.scheduleInterval = 0;
    }
    {
      // Collect nested object fields with prefix "colorsConfig."
      const colorsConfigObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("colorsConfig.")) {
          const fieldName = key.slice("colorsConfig.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = colorsConfigObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.colorsConfig = colorsConfigObj;
    }
    return Company.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Ordinal {
  north: number;
  northeast: number;
  east: number;
  southeast: number;
  south: number;
  southwest: number;
  west: number;
  northwest: number;
}

export namespace Ordinal {
  export function defaultValue(): Ordinal {
    return {
      north: 0,
      northeast: 0,
      east: 0,
      southeast: 0,
      south: 0,
      southwest: 0,
      west: 0,
      northwest: 0,
    } as Ordinal;
  }
}

export namespace Ordinal {
  export function toStringifiedJSON(self: Ordinal): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Ordinal): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Ordinal,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Ordinal", __id };
    result["north"] = self.north;
    result["northeast"] = self.northeast;
    result["east"] = self.east;
    result["southeast"] = self.southeast;
    result["south"] = self.south;
    result["southwest"] = self.southwest;
    result["west"] = self.west;
    result["northwest"] = self.northwest;
    return result;
  }
}

export namespace Ordinal {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Ordinal, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Ordinal, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Ordinal.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Ordinal | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Ordinal.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("north" in obj)) {
      errors.push({ field: "north", message: "missing required field" });
    }
    if (!("northeast" in obj)) {
      errors.push({ field: "northeast", message: "missing required field" });
    }
    if (!("east" in obj)) {
      errors.push({ field: "east", message: "missing required field" });
    }
    if (!("southeast" in obj)) {
      errors.push({ field: "southeast", message: "missing required field" });
    }
    if (!("south" in obj)) {
      errors.push({ field: "south", message: "missing required field" });
    }
    if (!("southwest" in obj)) {
      errors.push({ field: "southwest", message: "missing required field" });
    }
    if (!("west" in obj)) {
      errors.push({ field: "west", message: "missing required field" });
    }
    if (!("northwest" in obj)) {
      errors.push({ field: "northwest", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_north = obj["north"];
      instance.north = __raw_north;
    }
    {
      const __raw_northeast = obj["northeast"];
      instance.northeast = __raw_northeast;
    }
    {
      const __raw_east = obj["east"];
      instance.east = __raw_east;
    }
    {
      const __raw_southeast = obj["southeast"];
      instance.southeast = __raw_southeast;
    }
    {
      const __raw_south = obj["south"];
      instance.south = __raw_south;
    }
    {
      const __raw_southwest = obj["southwest"];
      instance.southwest = __raw_southwest;
    }
    {
      const __raw_west = obj["west"];
      instance.west = __raw_west;
    }
    {
      const __raw_northwest = obj["northwest"];
      instance.northwest = __raw_northwest;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Ordinal;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Ordinal>(
    field: K,
    value: Ordinal[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Ordinal>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Ordinal {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    north: Option<Array<string>>;
    northeast: Option<Array<string>>;
    east: Option<Array<string>>;
    southeast: Option<Array<string>>;
    south: Option<Array<string>>;
    southwest: Option<Array<string>>;
    west: Option<Array<string>>;
    northwest: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      north: Option<boolean>;
      northeast: Option<boolean>;
      east: Option<boolean>;
      southeast: Option<boolean>;
      south: Option<boolean>;
      southwest: Option<boolean>;
      west: Option<boolean>;
      northwest: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly north: FieldController<number>;
    readonly northeast: FieldController<number>;
    readonly east: FieldController<number>;
    readonly southeast: FieldController<number>;
    readonly south: FieldController<number>;
    readonly southwest: FieldController<number>;
    readonly west: FieldController<number>;
    readonly northwest: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Ordinal;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Ordinal, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Ordinal>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Ordinal>,
  ): Gigaform {
    let data = $state({ ...Ordinal.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      north: Option.none(),
      northeast: Option.none(),
      east: Option.none(),
      southeast: Option.none(),
      south: Option.none(),
      southwest: Option.none(),
      west: Option.none(),
      northwest: Option.none(),
    });
    let tainted = $state<Tainted>({
      north: Option.none(),
      northeast: Option.none(),
      east: Option.none(),
      southeast: Option.none(),
      south: Option.none(),
      southwest: Option.none(),
      west: Option.none(),
      northwest: Option.none(),
    });
    const fields: FieldControllers = {
      north: {
        path: ["north"] as const,
        name: "north",
        constraints: { required: true },

        get: () => data.north,
        set: (value: number) => {
          data.north = value;
        },
        getError: () => errors.north,
        setError: (value: Option<Array<string>>) => {
          errors.north = value;
        },
        getTainted: () => tainted.north,
        setTainted: (value: Option<boolean>) => {
          tainted.north = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "north")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField("north", data.north);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      northeast: {
        path: ["northeast"] as const,
        name: "northeast",
        constraints: { required: true },

        get: () => data.northeast,
        set: (value: number) => {
          data.northeast = value;
        },
        getError: () => errors.northeast,
        setError: (value: Option<Array<string>>) => {
          errors.northeast = value;
        },
        getTainted: () => tainted.northeast,
        setTainted: (value: Option<boolean>) => {
          tainted.northeast = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "northeast")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField(
            "northeast",
            data.northeast,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      east: {
        path: ["east"] as const,
        name: "east",
        constraints: { required: true },

        get: () => data.east,
        set: (value: number) => {
          data.east = value;
        },
        getError: () => errors.east,
        setError: (value: Option<Array<string>>) => {
          errors.east = value;
        },
        getTainted: () => tainted.east,
        setTainted: (value: Option<boolean>) => {
          tainted.east = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "east")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField("east", data.east);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      southeast: {
        path: ["southeast"] as const,
        name: "southeast",
        constraints: { required: true },

        get: () => data.southeast,
        set: (value: number) => {
          data.southeast = value;
        },
        getError: () => errors.southeast,
        setError: (value: Option<Array<string>>) => {
          errors.southeast = value;
        },
        getTainted: () => tainted.southeast,
        setTainted: (value: Option<boolean>) => {
          tainted.southeast = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "southeast")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField(
            "southeast",
            data.southeast,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      south: {
        path: ["south"] as const,
        name: "south",
        constraints: { required: true },

        get: () => data.south,
        set: (value: number) => {
          data.south = value;
        },
        getError: () => errors.south,
        setError: (value: Option<Array<string>>) => {
          errors.south = value;
        },
        getTainted: () => tainted.south,
        setTainted: (value: Option<boolean>) => {
          tainted.south = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "south")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField("south", data.south);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      southwest: {
        path: ["southwest"] as const,
        name: "southwest",
        constraints: { required: true },

        get: () => data.southwest,
        set: (value: number) => {
          data.southwest = value;
        },
        getError: () => errors.southwest,
        setError: (value: Option<Array<string>>) => {
          errors.southwest = value;
        },
        getTainted: () => tainted.southwest,
        setTainted: (value: Option<boolean>) => {
          tainted.southwest = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "southwest")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField(
            "southwest",
            data.southwest,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      west: {
        path: ["west"] as const,
        name: "west",
        constraints: { required: true },

        get: () => data.west,
        set: (value: number) => {
          data.west = value;
        },
        getError: () => errors.west,
        setError: (value: Option<Array<string>>) => {
          errors.west = value;
        },
        getTainted: () => tainted.west,
        setTainted: (value: Option<boolean>) => {
          tainted.west = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "west")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField("west", data.west);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      northwest: {
        path: ["northwest"] as const,
        name: "northwest",
        constraints: { required: true },

        get: () => data.northwest,
        set: (value: number) => {
          data.northwest = value;
        },
        getError: () => errors.northwest,
        setError: (value: Option<Array<string>>) => {
          errors.northwest = value;
        },
        getTainted: () => tainted.northwest,
        setTainted: (value: Option<boolean>) => {
          tainted.northwest = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "northwest")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordinal.validateField(
            "northwest",
            data.northwest,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Ordinal,
      Array<{ field: string; message: string }>
    > {
      return Ordinal.fromObject(data);
    }
    function reset(newOverrides?: Partial<Ordinal>): void {
      data = { ...Ordinal.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        north: Option.none(),
        northeast: Option.none(),
        east: Option.none(),
        southeast: Option.none(),
        south: Option.none(),
        southwest: Option.none(),
        west: Option.none(),
        northwest: Option.none(),
      };
      tainted = {
        north: Option.none(),
        northeast: Option.none(),
        east: Option.none(),
        southeast: Option.none(),
        south: Option.none(),
        southwest: Option.none(),
        west: Option.none(),
        northwest: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Ordinal, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const northStr = formData.get("north");
      obj.north = northStr ? parseFloat(northStr as string) : 0;
      if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = 0;
    }
    {
      const northeastStr = formData.get("northeast");
      obj.northeast = northeastStr ? parseFloat(northeastStr as string) : 0;
      if (obj.northeast !== undefined && isNaN(obj.northeast as number))
        obj.northeast = 0;
    }
    {
      const eastStr = formData.get("east");
      obj.east = eastStr ? parseFloat(eastStr as string) : 0;
      if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = 0;
    }
    {
      const southeastStr = formData.get("southeast");
      obj.southeast = southeastStr ? parseFloat(southeastStr as string) : 0;
      if (obj.southeast !== undefined && isNaN(obj.southeast as number))
        obj.southeast = 0;
    }
    {
      const southStr = formData.get("south");
      obj.south = southStr ? parseFloat(southStr as string) : 0;
      if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = 0;
    }
    {
      const southwestStr = formData.get("southwest");
      obj.southwest = southwestStr ? parseFloat(southwestStr as string) : 0;
      if (obj.southwest !== undefined && isNaN(obj.southwest as number))
        obj.southwest = 0;
    }
    {
      const westStr = formData.get("west");
      obj.west = westStr ? parseFloat(westStr as string) : 0;
      if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = 0;
    }
    {
      const northwestStr = formData.get("northwest");
      obj.northwest = northwestStr ? parseFloat(northwestStr as string) : 0;
      if (obj.northwest !== undefined && isNaN(obj.northwest as number))
        obj.northwest = 0;
    }
    return Ordinal.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Password {
  password: string;
}

export namespace Password {
  export function defaultValue(): Password {
    return { password: "" } as Password;
  }
}

export namespace Password {
  export function toStringifiedJSON(self: Password): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Password): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Password,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Password", __id };
    result["password"] = self.password;
    return result;
  }
}

export namespace Password {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Password, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Password, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Password.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Password | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Password.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("password" in obj)) {
      errors.push({ field: "password", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_password = obj["password"];
      instance.password = __raw_password;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Password;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Password>(
    field: K,
    value: Password[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "password": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "password", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Password>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("password" in partial && partial.password !== undefined) {
      const __val = partial.password as string;
      if (__val.length === 0) {
        errors.push({ field: "password", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Password {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    password: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { password: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly password: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Password;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Password, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Password>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Password>,
  ): Gigaform {
    let data = $state({ ...Password.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      password: Option.none(),
    });
    let tainted = $state<Tainted>({ password: Option.none() });
    const fields: FieldControllers = {
      password: {
        path: ["password"] as const,
        name: "password",
        constraints: { required: true },

        get: () => data.password,
        set: (value: string) => {
          data.password = value;
        },
        getError: () => errors.password,
        setError: (value: Option<Array<string>>) => {
          errors.password = value;
        },
        getTainted: () => tainted.password,
        setTainted: (value: Option<boolean>) => {
          tainted.password = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Password.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "password")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Password.validateField("password", data.password);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Password,
      Array<{ field: string; message: string }>
    > {
      return Password.fromObject(data);
    }
    function reset(newOverrides?: Partial<Password>): void {
      data = { ...Password.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), password: Option.none() };
      tainted = { password: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Password, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.password = formData.get("password") ?? "";
    return Password.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Created {
  initialData: string | null;
}

export namespace Created {
  export function defaultValue(): Created {
    return { initialData: null } as Created;
  }
}

export namespace Created {
  export function toStringifiedJSON(self: Created): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Created): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Created,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Created", __id };
    if (self.initialData !== null) {
      result["initialData"] =
        typeof (self.initialData as any)?.__serialize === "function"
          ? (self.initialData as any).__serialize(ctx)
          : self.initialData;
    } else {
      result["initialData"] = null;
    }
    return result;
  }
}

export namespace Created {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Created, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Created, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Created.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Created | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Created.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("initialData" in obj)) {
      errors.push({ field: "initialData", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_initialData = obj["initialData"];
      instance.initialData = __raw_initialData;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Created;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Created>(
    field: K,
    value: Created[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Created>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Created {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    initialData: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { initialData: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly initialData: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Created;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Created, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Created>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Created>,
  ): Gigaform {
    let data = $state({ ...Created.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      initialData: Option.none(),
    });
    let tainted = $state<Tainted>({ initialData: Option.none() });
    const fields: FieldControllers = {
      initialData: {
        path: ["initialData"] as const,
        name: "initialData",
        constraints: { required: true },

        get: () => data.initialData,
        set: (value: string | null) => {
          data.initialData = value;
        },
        getError: () => errors.initialData,
        setError: (value: Option<Array<string>>) => {
          errors.initialData = value;
        },
        getTainted: () => tainted.initialData,
        setTainted: (value: Option<boolean>) => {
          tainted.initialData = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Created.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "initialData")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Created.validateField(
            "initialData",
            data.initialData,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Created,
      Array<{ field: string; message: string }>
    > {
      return Created.fromObject(data);
    }
    function reset(newOverrides?: Partial<Created>): void {
      data = { ...Created.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), initialData: Option.none() };
      tainted = { initialData: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Created, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.initialData = formData.get("initialData") ?? "";
    return Created.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Employee {
  id: string;
  imageUrl: string | null;

  name: string;
  phones: PhoneNumber[];

  role: string;

  title: JobTitle;
  email: Email;

  address: string;

  username: string;

  route: string | Route;
  ratePerHour: number;
  active: boolean;
  isTechnician: boolean;
  isSalesRep: boolean;
  description: string | null;
  linkedinUrl: string | null;
  attendance: string[];
  settings: Settings;
}

export namespace Employee {
  export function defaultValue(): Employee {
    return {
      id: "",
      imageUrl: null,
      name: "",
      phones: [],
      role: "",
      title: "Technician",
      email: Email.defaultValue(),
      address: "",
      username: "",
      route: "",
      ratePerHour: 0,
      active: false,
      isTechnician: false,
      isSalesRep: false,
      description: null,
      linkedinUrl: null,
      attendance: [],
      settings: Settings.defaultValue(),
    } as Employee;
  }
}

export namespace Employee {
  export function toStringifiedJSON(self: Employee): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Employee): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Employee,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Employee", __id };
    result["id"] = self.id;
    if (self.imageUrl !== null) {
      result["imageUrl"] =
        typeof (self.imageUrl as any)?.__serialize === "function"
          ? (self.imageUrl as any).__serialize(ctx)
          : self.imageUrl;
    } else {
      result["imageUrl"] = null;
    }
    result["name"] = self.name;
    result["phones"] = self.phones.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["role"] = self.role;
    result["title"] =
      typeof (self.title as any)?.__serialize === "function"
        ? (self.title as any).__serialize(ctx)
        : self.title;
    result["email"] =
      typeof (self.email as any)?.__serialize === "function"
        ? (self.email as any).__serialize(ctx)
        : self.email;
    result["address"] = self.address;
    result["username"] = self.username;
    result["route"] = self.route;
    result["ratePerHour"] = self.ratePerHour;
    result["active"] = self.active;
    result["isTechnician"] = self.isTechnician;
    result["isSalesRep"] = self.isSalesRep;
    if (self.description !== null) {
      result["description"] =
        typeof (self.description as any)?.__serialize === "function"
          ? (self.description as any).__serialize(ctx)
          : self.description;
    } else {
      result["description"] = null;
    }
    if (self.linkedinUrl !== null) {
      result["linkedinUrl"] =
        typeof (self.linkedinUrl as any)?.__serialize === "function"
          ? (self.linkedinUrl as any).__serialize(ctx)
          : self.linkedinUrl;
    } else {
      result["linkedinUrl"] = null;
    }
    result["attendance"] = self.attendance.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    result["settings"] =
      typeof (self.settings as any)?.__serialize === "function"
        ? (self.settings as any).__serialize(ctx)
        : self.settings;
    return result;
  }
}

export namespace Employee {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Employee, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Employee, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Employee.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Employee | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Employee.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("imageUrl" in obj)) {
      errors.push({ field: "imageUrl", message: "missing required field" });
    }
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (!("phones" in obj)) {
      errors.push({ field: "phones", message: "missing required field" });
    }
    if (!("role" in obj)) {
      errors.push({ field: "role", message: "missing required field" });
    }
    if (!("title" in obj)) {
      errors.push({ field: "title", message: "missing required field" });
    }
    if (!("email" in obj)) {
      errors.push({ field: "email", message: "missing required field" });
    }
    if (!("address" in obj)) {
      errors.push({ field: "address", message: "missing required field" });
    }
    if (!("username" in obj)) {
      errors.push({ field: "username", message: "missing required field" });
    }
    if (!("route" in obj)) {
      errors.push({ field: "route", message: "missing required field" });
    }
    if (!("ratePerHour" in obj)) {
      errors.push({ field: "ratePerHour", message: "missing required field" });
    }
    if (!("active" in obj)) {
      errors.push({ field: "active", message: "missing required field" });
    }
    if (!("isTechnician" in obj)) {
      errors.push({ field: "isTechnician", message: "missing required field" });
    }
    if (!("isSalesRep" in obj)) {
      errors.push({ field: "isSalesRep", message: "missing required field" });
    }
    if (!("description" in obj)) {
      errors.push({ field: "description", message: "missing required field" });
    }
    if (!("linkedinUrl" in obj)) {
      errors.push({ field: "linkedinUrl", message: "missing required field" });
    }
    if (!("attendance" in obj)) {
      errors.push({ field: "attendance", message: "missing required field" });
    }
    if (!("settings" in obj)) {
      errors.push({ field: "settings", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_imageUrl = obj["imageUrl"];
      instance.imageUrl = __raw_imageUrl;
    }
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    {
      const __raw_phones = obj["phones"];
      instance.phones = __raw_phones;
    }
    {
      const __raw_role = obj["role"];
      instance.role = __raw_role;
    }
    {
      const __raw_title = obj["title"];
      if (typeof (JobTitle as any)?.__deserialize === "function") {
        const __result = (JobTitle as any).__deserialize(__raw_title, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "title", __result);
      } else {
        instance.title = __raw_title;
      }
    }
    {
      const __raw_email = obj["email"];
      if (typeof (Email as any)?.__deserialize === "function") {
        const __result = (Email as any).__deserialize(__raw_email, ctx);
        ctx.assignOrDefer(instance, "email", __result);
      } else {
        instance.email = __raw_email;
      }
    }
    {
      const __raw_address = obj["address"];
      instance.address = __raw_address;
    }
    {
      const __raw_username = obj["username"];
      instance.username = __raw_username;
    }
    {
      const __raw_route = obj["route"];
      instance.route = __raw_route;
    }
    {
      const __raw_ratePerHour = obj["ratePerHour"];
      instance.ratePerHour = __raw_ratePerHour;
    }
    {
      const __raw_active = obj["active"];
      instance.active = __raw_active;
    }
    {
      const __raw_isTechnician = obj["isTechnician"];
      instance.isTechnician = __raw_isTechnician;
    }
    {
      const __raw_isSalesRep = obj["isSalesRep"];
      instance.isSalesRep = __raw_isSalesRep;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    {
      const __raw_linkedinUrl = obj["linkedinUrl"];
      instance.linkedinUrl = __raw_linkedinUrl;
    }
    {
      const __raw_attendance = obj["attendance"];
      instance.attendance = __raw_attendance;
    }
    {
      const __raw_settings = obj["settings"];
      if (typeof (Settings as any)?.__deserialize === "function") {
        const __result = (Settings as any).__deserialize(__raw_settings, ctx);
        ctx.assignOrDefer(instance, "settings", __result);
      } else {
        instance.settings = __raw_settings;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Employee;
  }
}

export namespace Employee {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    imageUrl: Option<Array<string>>;
    name: Option<Array<string>>;
    phones: Option<Array<string>>;
    role: Option<Array<string>>;
    title: Option<Array<string>>;
    email: Option<Array<string>>;
    address: Option<Array<string>>;
    username: Option<Array<string>>;
    route: Option<Array<string>>;
    ratePerHour: Option<Array<string>>;
    active: Option<Array<string>>;
    isTechnician: Option<Array<string>>;
    isSalesRep: Option<Array<string>>;
    description: Option<Array<string>>;
    linkedinUrl: Option<Array<string>>;
    attendance: Option<Array<string>>;
    settings: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      imageUrl: Option<boolean>;
      name: Option<boolean>;
      phones: Option<boolean>;
      role: Option<boolean>;
      title: Option<boolean>;
      email: Option<boolean>;
      address: Option<boolean>;
      username: Option<boolean>;
      route: Option<boolean>;
      ratePerHour: Option<boolean>;
      active: Option<boolean>;
      isTechnician: Option<boolean>;
      isSalesRep: Option<boolean>;
      description: Option<boolean>;
      linkedinUrl: Option<boolean>;
      attendance: Option<boolean>;
      settings: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly imageUrl: FieldController<string | null>;
    readonly name: FieldController<string>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly role: FieldController<string>;
    readonly title: FieldController<JobTitle>;
    readonly email: FieldController<Email>;
    readonly address: FieldController<string>;
    readonly username: FieldController<string>;
    readonly route: FieldController<string | Route>;
    readonly ratePerHour: FieldController<number>;
    readonly active: FieldController<boolean>;
    readonly isTechnician: FieldController<boolean>;
    readonly isSalesRep: FieldController<boolean>;
    readonly description: FieldController<string | null>;
    readonly linkedinUrl: FieldController<string | null>;
    readonly attendance: ArrayFieldController<string>;
    readonly settings: FieldController<Settings>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Employee;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Employee, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Employee>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Employee>,
  ): Gigaform {
    let data = $state({ ...Employee.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      imageUrl: Option.none(),
      name: Option.none(),
      phones: Option.none(),
      role: Option.none(),
      title: Option.none(),
      email: Option.none(),
      address: Option.none(),
      username: Option.none(),
      route: Option.none(),
      ratePerHour: Option.none(),
      active: Option.none(),
      isTechnician: Option.none(),
      isSalesRep: Option.none(),
      description: Option.none(),
      linkedinUrl: Option.none(),
      attendance: Option.none(),
      settings: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      imageUrl: Option.none(),
      name: Option.none(),
      phones: Option.none(),
      role: Option.none(),
      title: Option.none(),
      email: Option.none(),
      address: Option.none(),
      username: Option.none(),
      route: Option.none(),
      ratePerHour: Option.none(),
      active: Option.none(),
      isTechnician: Option.none(),
      isSalesRep: Option.none(),
      description: Option.none(),
      linkedinUrl: Option.none(),
      attendance: Option.none(),
      settings: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
        },
      },
      imageUrl: {
        path: ["imageUrl"] as const,
        name: "imageUrl",
        constraints: { required: true },

        get: () => data.imageUrl,
        set: (value: string | null) => {
          data.imageUrl = value;
        },
        getError: () => errors.imageUrl,
        setError: (value: Option<Array<string>>) => {
          errors.imageUrl = value;
        },
        getTainted: () => tainted.imageUrl,
        setTainted: (value: Option<boolean>) => {
          tainted.imageUrl = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "imageUrl")
              .map((e) => e.message);
          }
          return [];
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "phones")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index],
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.phones[a], data.phones[b]] = [data.phones[b], data.phones[a]];
        },
      },
      role: {
        path: ["role"] as const,
        name: "role",
        constraints: { required: true },

        get: () => data.role,
        set: (value: string) => {
          data.role = value;
        },
        getError: () => errors.role,
        setError: (value: Option<Array<string>>) => {
          errors.role = value;
        },
        getTainted: () => tainted.role,
        setTainted: (value: Option<boolean>) => {
          tainted.role = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "role")
              .map((e) => e.message);
          }
          return [];
        },
      },
      title: {
        path: ["title"] as const,
        name: "title",
        constraints: { required: true },

        get: () => data.title,
        set: (value: JobTitle) => {
          data.title = value;
        },
        getError: () => errors.title,
        setError: (value: Option<Array<string>>) => {
          errors.title = value;
        },
        getTainted: () => tainted.title,
        setTainted: (value: Option<boolean>) => {
          tainted.title = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "title")
              .map((e) => e.message);
          }
          return [];
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: Email) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "email")
              .map((e) => e.message);
          }
          return [];
        },
      },
      address: {
        path: ["address"] as const,
        name: "address",
        constraints: { required: true },

        get: () => data.address,
        set: (value: string) => {
          data.address = value;
        },
        getError: () => errors.address,
        setError: (value: Option<Array<string>>) => {
          errors.address = value;
        },
        getTainted: () => tainted.address,
        setTainted: (value: Option<boolean>) => {
          tainted.address = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "address")
              .map((e) => e.message);
          }
          return [];
        },
      },
      username: {
        path: ["username"] as const,
        name: "username",
        constraints: { required: true },

        get: () => data.username,
        set: (value: string) => {
          data.username = value;
        },
        getError: () => errors.username,
        setError: (value: Option<Array<string>>) => {
          errors.username = value;
        },
        getTainted: () => tainted.username,
        setTainted: (value: Option<boolean>) => {
          tainted.username = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "username")
              .map((e) => e.message);
          }
          return [];
        },
      },
      route: {
        path: ["route"] as const,
        name: "route",
        constraints: { required: true },

        get: () => data.route,
        set: (value: string | Route) => {
          data.route = value;
        },
        getError: () => errors.route,
        setError: (value: Option<Array<string>>) => {
          errors.route = value;
        },
        getTainted: () => tainted.route,
        setTainted: (value: Option<boolean>) => {
          tainted.route = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "route")
              .map((e) => e.message);
          }
          return [];
        },
      },
      ratePerHour: {
        path: ["ratePerHour"] as const,
        name: "ratePerHour",
        constraints: { required: true },

        get: () => data.ratePerHour,
        set: (value: number) => {
          data.ratePerHour = value;
        },
        getError: () => errors.ratePerHour,
        setError: (value: Option<Array<string>>) => {
          errors.ratePerHour = value;
        },
        getTainted: () => tainted.ratePerHour,
        setTainted: (value: Option<boolean>) => {
          tainted.ratePerHour = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "ratePerHour")
              .map((e) => e.message);
          }
          return [];
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },

        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "active")
              .map((e) => e.message);
          }
          return [];
        },
      },
      isTechnician: {
        path: ["isTechnician"] as const,
        name: "isTechnician",
        constraints: { required: true },

        get: () => data.isTechnician,
        set: (value: boolean) => {
          data.isTechnician = value;
        },
        getError: () => errors.isTechnician,
        setError: (value: Option<Array<string>>) => {
          errors.isTechnician = value;
        },
        getTainted: () => tainted.isTechnician,
        setTainted: (value: Option<boolean>) => {
          tainted.isTechnician = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "isTechnician")
              .map((e) => e.message);
          }
          return [];
        },
      },
      isSalesRep: {
        path: ["isSalesRep"] as const,
        name: "isSalesRep",
        constraints: { required: true },

        get: () => data.isSalesRep,
        set: (value: boolean) => {
          data.isSalesRep = value;
        },
        getError: () => errors.isSalesRep,
        setError: (value: Option<Array<string>>) => {
          errors.isSalesRep = value;
        },
        getTainted: () => tainted.isSalesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.isSalesRep = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "isSalesRep")
              .map((e) => e.message);
          }
          return [];
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },

        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "description")
              .map((e) => e.message);
          }
          return [];
        },
      },
      linkedinUrl: {
        path: ["linkedinUrl"] as const,
        name: "linkedinUrl",
        constraints: { required: true },

        get: () => data.linkedinUrl,
        set: (value: string | null) => {
          data.linkedinUrl = value;
        },
        getError: () => errors.linkedinUrl,
        setError: (value: Option<Array<string>>) => {
          errors.linkedinUrl = value;
        },
        getTainted: () => tainted.linkedinUrl,
        setTainted: (value: Option<boolean>) => {
          tainted.linkedinUrl = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "linkedinUrl")
              .map((e) => e.message);
          }
          return [];
        },
      },
      attendance: {
        path: ["attendance"] as const,
        name: "attendance",
        constraints: { required: true },

        get: () => data.attendance,
        set: (value: string[]) => {
          data.attendance = value;
        },
        getError: () => errors.attendance,
        setError: (value: Option<Array<string>>) => {
          errors.attendance = value;
        },
        getTainted: () => tainted.attendance,
        setTainted: (value: Option<boolean>) => {
          tainted.attendance = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "attendance")
              .map((e) => e.message);
          }
          return [];
        },
        at: (index: number) => ({
          path: ["attendance", index] as const,
          name: `attendance.${index}`,
          constraints: { required: true },
          get: () => data.attendance[index],
          set: (value: string) => {
            data.attendance[index] = value;
          },
          getError: () => errors.attendance,
          setError: (value: Option<Array<string>>) => {
            errors.attendance = value;
          },
          getTainted: () => tainted.attendance,
          setTainted: (value: Option<boolean>) => {
            tainted.attendance = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.attendance.push(item);
        },
        remove: (index: number) => {
          data.attendance.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.attendance[a], data.attendance[b]] = [
            data.attendance[b],
            data.attendance[a],
          ];
        },
      },
      settings: {
        path: ["settings"] as const,
        name: "settings",
        constraints: { required: true },

        get: () => data.settings,
        set: (value: Settings) => {
          data.settings = value;
        },
        getError: () => errors.settings,
        setError: (value: Option<Array<string>>) => {
          errors.settings = value;
        },
        getTainted: () => tainted.settings,
        setTainted: (value: Option<boolean>) => {
          tainted.settings = value;
        },
        validate: (): Array<string> => {
          const result = Employee.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "settings")
              .map((e) => e.message);
          }
          return [];
        },
      },
    };
    function validate(): Result<
      Employee,
      Array<{ field: string; message: string }>
    > {
      return Employee.fromObject(data);
    }
    function reset(newOverrides?: Partial<Employee>): void {
      data = { ...Employee.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        imageUrl: Option.none(),
        name: Option.none(),
        phones: Option.none(),
        role: Option.none(),
        title: Option.none(),
        email: Option.none(),
        address: Option.none(),
        username: Option.none(),
        route: Option.none(),
        ratePerHour: Option.none(),
        active: Option.none(),
        isTechnician: Option.none(),
        isSalesRep: Option.none(),
        description: Option.none(),
        linkedinUrl: Option.none(),
        attendance: Option.none(),
        settings: Option.none(),
      };
      tainted = {
        id: Option.none(),
        imageUrl: Option.none(),
        name: Option.none(),
        phones: Option.none(),
        role: Option.none(),
        title: Option.none(),
        email: Option.none(),
        address: Option.none(),
        username: Option.none(),
        route: Option.none(),
        ratePerHour: Option.none(),
        active: Option.none(),
        isTechnician: Option.none(),
        isSalesRep: Option.none(),
        description: Option.none(),
        linkedinUrl: Option.none(),
        attendance: Option.none(),
        settings: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Employee, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.imageUrl = formData.get("imageUrl") ?? "";
    obj.name = formData.get("name") ?? "";
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    obj.role = formData.get("role") ?? "";
    {
      // Collect nested object fields with prefix "title."
      const titleObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("title.")) {
          const fieldName = key.slice("title.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = titleObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.title = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.title = v;
          });
        } else {
          instance.title = __result;
        }
      } else {
        instance.title = __raw_title;
      }
    }
    {
      const __raw_email = obj["email"];
      if (typeof (Email as any)?.__deserialize === "function") {
        const __result = (Email as any).__deserialize(__raw_email, ctx);
        if (PendingRef.is(__result)) {
          instance.email = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.email = v;
          });
        } else {
          instance.email = __result;
        }
      } else {
        instance.email = __raw_email;
      }
    }
    {
      const __raw_address = obj["address"];
      instance.address = __raw_address;
    }
    {
      const __raw_username = obj["username"];
      instance.username = __raw_username;
    }
    {
      const __raw_route = obj["route"];
      instance.route = __raw_route;
    }
    {
      const __raw_ratePerHour = obj["ratePerHour"];
      instance.ratePerHour = __raw_ratePerHour;
    }
    {
      const __raw_active = obj["active"];
      instance.active = __raw_active;
    }
    {
      const __raw_isTechnician = obj["isTechnician"];
      instance.isTechnician = __raw_isTechnician;
    }
    {
      const __raw_isSalesRep = obj["isSalesRep"];
      instance.isSalesRep = __raw_isSalesRep;
    }
    {
      const __raw_description = obj["description"];
      instance.description = __raw_description;
    }
    {
      const __raw_linkedinUrl = obj["linkedinUrl"];
      instance.linkedinUrl = __raw_linkedinUrl;
    }
    {
      const __raw_attendance = obj["attendance"];
      instance.attendance = __raw_attendance;
    }
    {
      const __raw_settings = obj["settings"];
      if (typeof (Settings as any)?.__deserialize === "function") {
        const __result = (Settings as any).__deserialize(__raw_settings, ctx);
        if (PendingRef.is(__result)) {
          instance.settings = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.settings = v;
          });
        } else {
          instance.settings = __result;
        }
      } else {
        instance.settings = __raw_settings;
      }
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Employee;
  }
  export function validateField<K extends keyof Employee>(
    field: K,
    value: Employee[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
      case "role": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "role", message: "must not be empty" });
        }
        break;
      }
      case "address": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "address", message: "must not be empty" });
        }
        break;
      }
      case "username": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "username", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Employee>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    if ("role" in partial && partial.role !== undefined) {
      const __val = partial.role as string;
      if (__val.length === 0) {
        errors.push({ field: "role", message: "must not be empty" });
      }
    }
    if ("address" in partial && partial.address !== undefined) {
      const __val = partial.address as string;
      if (__val.length === 0) {
        errors.push({ field: "address", message: "must not be empty" });
      }
    }
    if ("username" in partial && partial.username !== undefined) {
      const __val = partial.username as string;
      if (__val.length === 0) {
        errors.push({ field: "username", message: "must not be empty" });
      }
    }
    return errors;
  }
}

export namespace Employee {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    imageUrl: Option<Array<string>>;
    name: Option<Array<string>>;
    phones: Option<Array<string>>;
    role: Option<Array<string>>;
    title: Option<Array<string>>;
    email: Option<Array<string>>;
    address: Option<Array<string>>;
    username: Option<Array<string>>;
    route: Option<Array<string>>;
    ratePerHour: Option<Array<string>>;
    active: Option<Array<string>>;
    isTechnician: Option<Array<string>>;
    isSalesRep: Option<Array<string>>;
    description: Option<Array<string>>;
    linkedinUrl: Option<Array<string>>;
    attendance: Option<Array<string>>;
    settings: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      imageUrl: Option<boolean>;
      name: Option<boolean>;
      phones: Option<boolean>;
      role: Option<boolean>;
      title: Option<boolean>;
      email: Option<boolean>;
      address: Option<boolean>;
      username: Option<boolean>;
      route: Option<boolean>;
      ratePerHour: Option<boolean>;
      active: Option<boolean>;
      isTechnician: Option<boolean>;
      isSalesRep: Option<boolean>;
      description: Option<boolean>;
      linkedinUrl: Option<boolean>;
      attendance: Option<boolean>;
      settings: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly imageUrl: FieldController<string | null>;
    readonly name: FieldController<string>;
    readonly phones: ArrayFieldController<PhoneNumber>;
    readonly role: FieldController<string>;
    readonly title: FieldController<JobTitle>;
    readonly email: FieldController<Email>;
    readonly address: FieldController<string>;
    readonly username: FieldController<string>;
    readonly route: FieldController<string | Route>;
    readonly ratePerHour: FieldController<number>;
    readonly active: FieldController<boolean>;
    readonly isTechnician: FieldController<boolean>;
    readonly isSalesRep: FieldController<boolean>;
    readonly description: FieldController<string | null>;
    readonly linkedinUrl: FieldController<string | null>;
    readonly attendance: ArrayFieldController<string>;
    readonly settings: FieldController<Settings>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Employee;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Employee, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Employee>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Employee>,
  ): Gigaform {
    let data = $state({ ...Employee.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      imageUrl: Option.none(),
      name: Option.none(),
      phones: Option.none(),
      role: Option.none(),
      title: Option.none(),
      email: Option.none(),
      address: Option.none(),
      username: Option.none(),
      route: Option.none(),
      ratePerHour: Option.none(),
      active: Option.none(),
      isTechnician: Option.none(),
      isSalesRep: Option.none(),
      description: Option.none(),
      linkedinUrl: Option.none(),
      attendance: Option.none(),
      settings: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      imageUrl: Option.none(),
      name: Option.none(),
      phones: Option.none(),
      role: Option.none(),
      title: Option.none(),
      email: Option.none(),
      address: Option.none(),
      username: Option.none(),
      route: Option.none(),
      ratePerHour: Option.none(),
      active: Option.none(),
      isTechnician: Option.none(),
      isSalesRep: Option.none(),
      description: Option.none(),
      linkedinUrl: Option.none(),
      attendance: Option.none(),
      settings: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
        },
      },
      imageUrl: {
        path: ["imageUrl"] as const,
        name: "imageUrl",
        constraints: { required: true },

        get: () => data.imageUrl,
        set: (value: string | null) => {
          data.imageUrl = value;
        },
        getError: () => errors.imageUrl,
        setError: (value: Option<Array<string>>) => {
          errors.imageUrl = value;
        },
        getTainted: () => tainted.imageUrl,
        setTainted: (value: Option<boolean>) => {
          tainted.imageUrl = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("imageUrl", data.imageUrl);
          return fieldErrors.map((e) => e.message);
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("name", data.name);
          return fieldErrors.map((e) => e.message);
        },
      },
      phones: {
        path: ["phones"] as const,
        name: "phones",
        constraints: { required: true },

        get: () => data.phones,
        set: (value: PhoneNumber[]) => {
          data.phones = value;
        },
        getError: () => errors.phones,
        setError: (value: Option<Array<string>>) => {
          errors.phones = value;
        },
        getTainted: () => tainted.phones,
        setTainted: (value: Option<boolean>) => {
          tainted.phones = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("phones", data.phones);
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["phones", index] as const,
          name: `phones.${index}`,
          constraints: { required: true },
          get: () => data.phones[index],
          set: (value: PhoneNumber) => {
            data.phones[index] = value;
          },
          getError: () => errors.phones,
          setError: (value: Option<Array<string>>) => {
            errors.phones = value;
          },
          getTainted: () => tainted.phones,
          setTainted: (value: Option<boolean>) => {
            tainted.phones = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: PhoneNumber) => {
          data.phones.push(item);
        },
        remove: (index: number) => {
          data.phones.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.phones[a], data.phones[b]] = [data.phones[b], data.phones[a]];
        },
      },
      role: {
        path: ["role"] as const,
        name: "role",
        constraints: { required: true },

        get: () => data.role,
        set: (value: string) => {
          data.role = value;
        },
        getError: () => errors.role,
        setError: (value: Option<Array<string>>) => {
          errors.role = value;
        },
        getTainted: () => tainted.role,
        setTainted: (value: Option<boolean>) => {
          tainted.role = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("role", data.role);
          return fieldErrors.map((e) => e.message);
        },
      },
      title: {
        path: ["title"] as const,
        name: "title",
        constraints: { required: true },

        get: () => data.title,
        set: (value: JobTitle) => {
          data.title = value;
        },
        getError: () => errors.title,
        setError: (value: Option<Array<string>>) => {
          errors.title = value;
        },
        getTainted: () => tainted.title,
        setTainted: (value: Option<boolean>) => {
          tainted.title = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("title", data.title);
          return fieldErrors.map((e) => e.message);
        },
      },
      email: {
        path: ["email"] as const,
        name: "email",
        constraints: { required: true },

        get: () => data.email,
        set: (value: Email) => {
          data.email = value;
        },
        getError: () => errors.email,
        setError: (value: Option<Array<string>>) => {
          errors.email = value;
        },
        getTainted: () => tainted.email,
        setTainted: (value: Option<boolean>) => {
          tainted.email = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("email", data.email);
          return fieldErrors.map((e) => e.message);
        },
      },
      address: {
        path: ["address"] as const,
        name: "address",
        constraints: { required: true },

        get: () => data.address,
        set: (value: string) => {
          data.address = value;
        },
        getError: () => errors.address,
        setError: (value: Option<Array<string>>) => {
          errors.address = value;
        },
        getTainted: () => tainted.address,
        setTainted: (value: Option<boolean>) => {
          tainted.address = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("address", data.address);
          return fieldErrors.map((e) => e.message);
        },
      },
      username: {
        path: ["username"] as const,
        name: "username",
        constraints: { required: true },

        get: () => data.username,
        set: (value: string) => {
          data.username = value;
        },
        getError: () => errors.username,
        setError: (value: Option<Array<string>>) => {
          errors.username = value;
        },
        getTainted: () => tainted.username,
        setTainted: (value: Option<boolean>) => {
          tainted.username = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("username", data.username);
          return fieldErrors.map((e) => e.message);
        },
      },
      route: {
        path: ["route"] as const,
        name: "route",
        constraints: { required: true },

        get: () => data.route,
        set: (value: string | Route) => {
          data.route = value;
        },
        getError: () => errors.route,
        setError: (value: Option<Array<string>>) => {
          errors.route = value;
        },
        getTainted: () => tainted.route,
        setTainted: (value: Option<boolean>) => {
          tainted.route = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("route", data.route);
          return fieldErrors.map((e) => e.message);
        },
      },
      ratePerHour: {
        path: ["ratePerHour"] as const,
        name: "ratePerHour",
        constraints: { required: true },

        get: () => data.ratePerHour,
        set: (value: number) => {
          data.ratePerHour = value;
        },
        getError: () => errors.ratePerHour,
        setError: (value: Option<Array<string>>) => {
          errors.ratePerHour = value;
        },
        getTainted: () => tainted.ratePerHour,
        setTainted: (value: Option<boolean>) => {
          tainted.ratePerHour = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "ratePerHour",
            data.ratePerHour,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },

        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("active", data.active);
          return fieldErrors.map((e) => e.message);
        },
      },
      isTechnician: {
        path: ["isTechnician"] as const,
        name: "isTechnician",
        constraints: { required: true },

        get: () => data.isTechnician,
        set: (value: boolean) => {
          data.isTechnician = value;
        },
        getError: () => errors.isTechnician,
        setError: (value: Option<Array<string>>) => {
          errors.isTechnician = value;
        },
        getTainted: () => tainted.isTechnician,
        setTainted: (value: Option<boolean>) => {
          tainted.isTechnician = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "isTechnician",
            data.isTechnician,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      isSalesRep: {
        path: ["isSalesRep"] as const,
        name: "isSalesRep",
        constraints: { required: true },

        get: () => data.isSalesRep,
        set: (value: boolean) => {
          data.isSalesRep = value;
        },
        getError: () => errors.isSalesRep,
        setError: (value: Option<Array<string>>) => {
          errors.isSalesRep = value;
        },
        getTainted: () => tainted.isSalesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.isSalesRep = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "isSalesRep",
            data.isSalesRep,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      description: {
        path: ["description"] as const,
        name: "description",
        constraints: { required: true },

        get: () => data.description,
        set: (value: string | null) => {
          data.description = value;
        },
        getError: () => errors.description,
        setError: (value: Option<Array<string>>) => {
          errors.description = value;
        },
        getTainted: () => tainted.description,
        setTainted: (value: Option<boolean>) => {
          tainted.description = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "description",
            data.description,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      linkedinUrl: {
        path: ["linkedinUrl"] as const,
        name: "linkedinUrl",
        constraints: { required: true },

        get: () => data.linkedinUrl,
        set: (value: string | null) => {
          data.linkedinUrl = value;
        },
        getError: () => errors.linkedinUrl,
        setError: (value: Option<Array<string>>) => {
          errors.linkedinUrl = value;
        },
        getTainted: () => tainted.linkedinUrl,
        setTainted: (value: Option<boolean>) => {
          tainted.linkedinUrl = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "linkedinUrl",
            data.linkedinUrl,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      attendance: {
        path: ["attendance"] as const,
        name: "attendance",
        constraints: { required: true },

        get: () => data.attendance,
        set: (value: string[]) => {
          data.attendance = value;
        },
        getError: () => errors.attendance,
        setError: (value: Option<Array<string>>) => {
          errors.attendance = value;
        },
        getTainted: () => tainted.attendance,
        setTainted: (value: Option<boolean>) => {
          tainted.attendance = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField(
            "attendance",
            data.attendance,
          );
          return fieldErrors.map((e) => e.message);
        },
        at: (index: number) => ({
          path: ["attendance", index] as const,
          name: `attendance.${index}`,
          constraints: { required: true },
          get: () => data.attendance[index],
          set: (value: string) => {
            data.attendance[index] = value;
          },
          getError: () => errors.attendance,
          setError: (value: Option<Array<string>>) => {
            errors.attendance = value;
          },
          getTainted: () => tainted.attendance,
          setTainted: (value: Option<boolean>) => {
            tainted.attendance = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.attendance.push(item);
        },
        remove: (index: number) => {
          data.attendance.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.attendance[a], data.attendance[b]] = [
            data.attendance[b],
            data.attendance[a],
          ];
        },
      },
      settings: {
        path: ["settings"] as const,
        name: "settings",
        constraints: { required: true },

        get: () => data.settings,
        set: (value: Settings) => {
          data.settings = value;
        },
        getError: () => errors.settings,
        setError: (value: Option<Array<string>>) => {
          errors.settings = value;
        },
        getTainted: () => tainted.settings,
        setTainted: (value: Option<boolean>) => {
          tainted.settings = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Employee.validateField("settings", data.settings);
          return fieldErrors.map((e) => e.message);
        },
      },
    };
    function validate(): Result<
      Employee,
      Array<{ field: string; message: string }>
    > {
      return Employee.fromObject(data);
    }
    function reset(newOverrides?: Partial<Employee>): void {
      data = { ...Employee.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        imageUrl: Option.none(),
        name: Option.none(),
        phones: Option.none(),
        role: Option.none(),
        title: Option.none(),
        email: Option.none(),
        address: Option.none(),
        username: Option.none(),
        route: Option.none(),
        ratePerHour: Option.none(),
        active: Option.none(),
        isTechnician: Option.none(),
        isSalesRep: Option.none(),
        description: Option.none(),
        linkedinUrl: Option.none(),
        attendance: Option.none(),
        settings: Option.none(),
      };
      tainted = {
        id: Option.none(),
        imageUrl: Option.none(),
        name: Option.none(),
        phones: Option.none(),
        role: Option.none(),
        title: Option.none(),
        email: Option.none(),
        address: Option.none(),
        username: Option.none(),
        route: Option.none(),
        ratePerHour: Option.none(),
        active: Option.none(),
        isTechnician: Option.none(),
        isSalesRep: Option.none(),
        description: Option.none(),
        linkedinUrl: Option.none(),
        attendance: Option.none(),
        settings: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Employee, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.imageUrl = formData.get("imageUrl") ?? "";
    obj.name = formData.get("name") ?? "";
    {
      // Collect array items from indexed form fields
      const phonesItems: Array<Record<string, unknown>> = [];
      let idx = 0;
      while (formData.has("phones." + idx + ".") || idx === 0) {
        // Check if any field with this index exists
        const hasAny = Array.from(formData.keys()).some((k) =>
          k.startsWith("phones." + idx + "."),
        );
        if (!hasAny && idx > 0) break;
        if (hasAny) {
          const item: Record<string, unknown> = {};
          for (const [key, value] of formData.entries()) {
            if (key.startsWith("phones." + idx + ".")) {
              const fieldName = key.slice(
                "phones.".length + String(idx).length + 1,
              );
              item[fieldName] = value;
            }
          }
          phonesItems.push(item);
        }
        idx++;
        if (idx > 1000) break; // Safety limit
      }
      obj.phones = phonesItems;
    }
    obj.role = formData.get("role") ?? "";
    {
      // Collect nested object fields with prefix "title."
      const titleObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("title.")) {
          const fieldName = key.slice("title.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = titleObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.title = titleObj;
    }
    {
      // Collect nested object fields with prefix "email."
      const emailObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("email.")) {
          const fieldName = key.slice("email.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = emailObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.email = emailObj;
    }
    obj.address = formData.get("address") ?? "";
    obj.username = formData.get("username") ?? "";
    obj.route = formData.get("route") ?? "";
    {
      const ratePerHourStr = formData.get("ratePerHour");
      obj.ratePerHour = ratePerHourStr
        ? parseFloat(ratePerHourStr as string)
        : 0;
      if (obj.ratePerHour !== undefined && isNaN(obj.ratePerHour as number))
        obj.ratePerHour = 0;
    }
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    {
      const isTechnicianVal = formData.get("isTechnician");
      obj.isTechnician =
        isTechnicianVal === "true" ||
        isTechnicianVal === "on" ||
        isTechnicianVal === "1";
    }
    {
      const isSalesRepVal = formData.get("isSalesRep");
      obj.isSalesRep =
        isSalesRepVal === "true" ||
        isSalesRepVal === "on" ||
        isSalesRepVal === "1";
    }
    obj.description = formData.get("description") ?? "";
    obj.linkedinUrl = formData.get("linkedinUrl") ?? "";
    obj.attendance = formData.getAll("attendance") as Array<string>;
    {
      // Collect nested object fields with prefix "settings."
      const settingsObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("settings.")) {
          const fieldName = key.slice("settings.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = settingsObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
      }
      obj.settings = settingsObj;
    }
    return Employee.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Commissions {
  technician: string;

  salesRep: string;
}

export namespace Commissions {
  export function defaultValue(): Commissions {
    return { technician: "", salesRep: "" } as Commissions;
  }
}

export namespace Commissions {
  export function toStringifiedJSON(self: Commissions): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Commissions): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Commissions,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Commissions", __id };
    result["technician"] = self.technician;
    result["salesRep"] = self.salesRep;
    return result;
  }
}

export namespace Commissions {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Commissions, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Commissions, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "Commissions.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Commissions | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Commissions.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("technician" in obj)) {
      errors.push({ field: "technician", message: "missing required field" });
    }
    if (!("salesRep" in obj)) {
      errors.push({ field: "salesRep", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_technician = obj["technician"];
      instance.technician = __raw_technician;
    }
    {
      const __raw_salesRep = obj["salesRep"];
      instance.salesRep = __raw_salesRep;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Commissions;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Commissions>(
    field: K,
    value: Commissions[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "technician": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "technician", message: "must not be empty" });
        }
        break;
      }
      case "salesRep": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "salesRep", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Commissions>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("technician" in partial && partial.technician !== undefined) {
      const __val = partial.technician as string;
      if (__val.length === 0) {
        errors.push({ field: "technician", message: "must not be empty" });
      }
    }
    if ("salesRep" in partial && partial.salesRep !== undefined) {
      const __val = partial.salesRep as string;
      if (__val.length === 0) {
        errors.push({ field: "salesRep", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Commissions {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    technician: Option<Array<string>>;
    salesRep: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { technician: Option<boolean>; salesRep: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly technician: FieldController<string>;
    readonly salesRep: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Commissions;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Commissions, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Commissions>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Commissions>,
  ): Gigaform {
    let data = $state({ ...Commissions.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      technician: Option.none(),
      salesRep: Option.none(),
    });
    let tainted = $state<Tainted>({
      technician: Option.none(),
      salesRep: Option.none(),
    });
    const fields: FieldControllers = {
      technician: {
        path: ["technician"] as const,
        name: "technician",
        constraints: { required: true },

        get: () => data.technician,
        set: (value: string) => {
          data.technician = value;
        },
        getError: () => errors.technician,
        setError: (value: Option<Array<string>>) => {
          errors.technician = value;
        },
        getTainted: () => tainted.technician,
        setTainted: (value: Option<boolean>) => {
          tainted.technician = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Commissions.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "technician")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Commissions.validateField(
            "technician",
            data.technician,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      salesRep: {
        path: ["salesRep"] as const,
        name: "salesRep",
        constraints: { required: true },

        get: () => data.salesRep,
        set: (value: string) => {
          data.salesRep = value;
        },
        getError: () => errors.salesRep,
        setError: (value: Option<Array<string>>) => {
          errors.salesRep = value;
        },
        getTainted: () => tainted.salesRep,
        setTainted: (value: Option<boolean>) => {
          tainted.salesRep = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Commissions.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "salesRep")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Commissions.validateField(
            "salesRep",
            data.salesRep,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Commissions,
      Array<{ field: string; message: string }>
    > {
      return Commissions.fromObject(data);
    }
    function reset(newOverrides?: Partial<Commissions>): void {
      data = { ...Commissions.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        technician: Option.none(),
        salesRep: Option.none(),
      };
      tainted = { technician: Option.none(), salesRep: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Commissions, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.technician = formData.get("technician") ?? "";
    obj.salesRep = formData.get("salesRep") ?? "";
    return Commissions.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Number {
  countryCode: string;

  areaCode: string;

  localNumber: string;
}

export namespace Number {
  export function defaultValue(): Number {
    return { countryCode: "", areaCode: "", localNumber: "" } as Number;
  }
}

export namespace Number {
  export function toStringifiedJSON(self: Number): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Number): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Number,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Number", __id };
    result["countryCode"] = self.countryCode;
    result["areaCode"] = self.areaCode;
    result["localNumber"] = self.localNumber;
    return result;
  }
}

export namespace Number {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Number, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Number, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Number.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Number | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Number.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("countryCode" in obj)) {
      errors.push({ field: "countryCode", message: "missing required field" });
    }
    if (!("areaCode" in obj)) {
      errors.push({ field: "areaCode", message: "missing required field" });
    }
    if (!("localNumber" in obj)) {
      errors.push({ field: "localNumber", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_countryCode = obj["countryCode"];
      instance.countryCode = __raw_countryCode;
    }
    {
      const __raw_areaCode = obj["areaCode"];
      instance.areaCode = __raw_areaCode;
    }
    {
      const __raw_localNumber = obj["localNumber"];
      instance.localNumber = __raw_localNumber;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Number;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Number>(
    field: K,
    value: Number[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "countryCode": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "countryCode", message: "must not be empty" });
        }
        break;
      }
      case "areaCode": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "areaCode", message: "must not be empty" });
        }
        break;
      }
      case "localNumber": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "localNumber", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Number>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("countryCode" in partial && partial.countryCode !== undefined) {
      const __val = partial.countryCode as string;
      if (__val.length === 0) {
        errors.push({ field: "countryCode", message: "must not be empty" });
      }
    }
    if ("areaCode" in partial && partial.areaCode !== undefined) {
      const __val = partial.areaCode as string;
      if (__val.length === 0) {
        errors.push({ field: "areaCode", message: "must not be empty" });
      }
    }
    if ("localNumber" in partial && partial.localNumber !== undefined) {
      const __val = partial.localNumber as string;
      if (__val.length === 0) {
        errors.push({ field: "localNumber", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Number {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    countryCode: Option<Array<string>>;
    areaCode: Option<Array<string>>;
    localNumber: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      countryCode: Option<boolean>;
      areaCode: Option<boolean>;
      localNumber: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly countryCode: FieldController<string>;
    readonly areaCode: FieldController<string>;
    readonly localNumber: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Number;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Number, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Number>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Number>,
  ): Gigaform {
    let data = $state({ ...Number.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      countryCode: Option.none(),
      areaCode: Option.none(),
      localNumber: Option.none(),
    });
    let tainted = $state<Tainted>({
      countryCode: Option.none(),
      areaCode: Option.none(),
      localNumber: Option.none(),
    });
    const fields: FieldControllers = {
      countryCode: {
        path: ["countryCode"] as const,
        name: "countryCode",
        constraints: { required: true },

        get: () => data.countryCode,
        set: (value: string) => {
          data.countryCode = value;
        },
        getError: () => errors.countryCode,
        setError: (value: Option<Array<string>>) => {
          errors.countryCode = value;
        },
        getTainted: () => tainted.countryCode,
        setTainted: (value: Option<boolean>) => {
          tainted.countryCode = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Number.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "countryCode")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Number.validateField(
            "countryCode",
            data.countryCode,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      areaCode: {
        path: ["areaCode"] as const,
        name: "areaCode",
        constraints: { required: true },

        get: () => data.areaCode,
        set: (value: string) => {
          data.areaCode = value;
        },
        getError: () => errors.areaCode,
        setError: (value: Option<Array<string>>) => {
          errors.areaCode = value;
        },
        getTainted: () => tainted.areaCode,
        setTainted: (value: Option<boolean>) => {
          tainted.areaCode = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Number.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "areaCode")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Number.validateField("areaCode", data.areaCode);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      localNumber: {
        path: ["localNumber"] as const,
        name: "localNumber",
        constraints: { required: true },

        get: () => data.localNumber,
        set: (value: string) => {
          data.localNumber = value;
        },
        getError: () => errors.localNumber,
        setError: (value: Option<Array<string>>) => {
          errors.localNumber = value;
        },
        getTainted: () => tainted.localNumber,
        setTainted: (value: Option<boolean>) => {
          tainted.localNumber = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Number.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "localNumber")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Number.validateField(
            "localNumber",
            data.localNumber,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Number,
      Array<{ field: string; message: string }>
    > {
      return Number.fromObject(data);
    }
    function reset(newOverrides?: Partial<Number>): void {
      data = { ...Number.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        countryCode: Option.none(),
        areaCode: Option.none(),
        localNumber: Option.none(),
      };
      tainted = {
        countryCode: Option.none(),
        areaCode: Option.none(),
        localNumber: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Number, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.countryCode = formData.get("countryCode") ?? "";
    obj.areaCode = formData.get("areaCode") ?? "";
    obj.localNumber = formData.get("localNumber") ?? "";
    return Number.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface DataPath {
  path: string[];
  formatter: string | null;
}

export namespace DataPath {
  export function defaultValue(): DataPath {
    return { path: [], formatter: null } as DataPath;
  }
}

export namespace DataPath {
  export function toStringifiedJSON(self: DataPath): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: DataPath): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: DataPath,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "DataPath", __id };
    result["path"] = self.path.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    if (self.formatter !== null) {
      result["formatter"] =
        typeof (self.formatter as any)?.__serialize === "function"
          ? (self.formatter as any).__serialize(ctx)
          : self.formatter;
    } else {
      result["formatter"] = null;
    }
    return result;
  }
}

export namespace DataPath {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<DataPath, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<DataPath, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "DataPath.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): DataPath | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "DataPath.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("path" in obj)) {
      errors.push({ field: "path", message: "missing required field" });
    }
    if (!("formatter" in obj)) {
      errors.push({ field: "formatter", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_path = obj["path"];
      instance.path = __raw_path;
    }
    {
      const __raw_formatter = obj["formatter"];
      instance.formatter = __raw_formatter;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as DataPath;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof DataPath>(
    field: K,
    value: DataPath[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<DataPath>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace DataPath {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    path: Option<Array<string>>;
    formatter: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { path: Option<boolean>; formatter: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly path: ArrayFieldController<string>;
    readonly formatter: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: DataPath;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<DataPath, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<DataPath>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<DataPath>,
  ): Gigaform {
    let data = $state({ ...DataPath.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      path: Option.none(),
      formatter: Option.none(),
    });
    let tainted = $state<Tainted>({
      path: Option.none(),
      formatter: Option.none(),
    });
    const fields: FieldControllers = {
      path: {
        path: ["path"] as const,
        name: "path",
        constraints: { required: true },

        get: () => data.path,
        set: (value: string[]) => {
          data.path = value;
        },
        getError: () => errors.path,
        setError: (value: Option<Array<string>>) => {
          errors.path = value;
        },
        getTainted: () => tainted.path,
        setTainted: (value: Option<boolean>) => {
          tainted.path = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = DataPath.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "path")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = DataPath.validateField("path", data.path);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["path", index] as const,
          name: `path.${index}`,
          constraints: { required: true },
          get: () => data.path[index],
          set: (value: string) => {
            data.path[index] = value;
          },
          getError: () => errors.path,
          setError: (value: Option<Array<string>>) => {
            errors.path = value;
          },
          getTainted: () => tainted.path,
          setTainted: (value: Option<boolean>) => {
            tainted.path = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.path.push(item);
        },
        remove: (index: number) => {
          data.path.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.path[a], data.path[b]] = [data.path[b], data.path[a]];
        },
      },
      formatter: {
        path: ["formatter"] as const,
        name: "formatter",
        constraints: { required: true },

        get: () => data.formatter,
        set: (value: string | null) => {
          data.formatter = value;
        },
        getError: () => errors.formatter,
        setError: (value: Option<Array<string>>) => {
          errors.formatter = value;
        },
        getTainted: () => tainted.formatter,
        setTainted: (value: Option<boolean>) => {
          tainted.formatter = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = DataPath.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "formatter")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = DataPath.validateField(
            "formatter",
            data.formatter,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      DataPath,
      Array<{ field: string; message: string }>
    > {
      return DataPath.fromObject(data);
    }
    function reset(newOverrides?: Partial<DataPath>): void {
      data = { ...DataPath.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        path: Option.none(),
        formatter: Option.none(),
      };
      tainted = { path: Option.none(), formatter: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<DataPath, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.path = formData.getAll("path") as Array<string>;
    obj.formatter = formData.get("formatter") ?? "";
    return DataPath.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Route {
  id: string;
  techs: (string | Employee)[] | null;
  active: boolean;

  name: string;

  phone: string;

  position: string;
  serviceRoute: boolean;
  defaultDurationHours: number;
  tags: string[];
  icon: string | null;
  color: string | null;
}

export namespace Route {
  export function defaultValue(): Route {
    return {
      id: "",
      techs: null,
      active: false,
      name: "",
      phone: "",
      position: "",
      serviceRoute: false,
      defaultDurationHours: 0,
      tags: [],
      icon: null,
      color: null,
    } as Route;
  }
}

export namespace Route {
  export function toStringifiedJSON(self: Route): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Route): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Route,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Route", __id };
    result["id"] = self.id;
    if (self.techs !== null) {
      result["techs"] =
        typeof (self.techs as any)?.__serialize === "function"
          ? (self.techs as any).__serialize(ctx)
          : self.techs;
    } else {
      result["techs"] = null;
    }
    result["active"] = self.active;
    result["name"] = self.name;
    result["phone"] = self.phone;
    result["position"] = self.position;
    result["serviceRoute"] = self.serviceRoute;
    result["defaultDurationHours"] = self.defaultDurationHours;
    result["tags"] = self.tags.map((item: any) =>
      typeof item?.__serialize === "function" ? item.__serialize(ctx) : item,
    );
    if (self.icon !== null) {
      result["icon"] =
        typeof (self.icon as any)?.__serialize === "function"
          ? (self.icon as any).__serialize(ctx)
          : self.icon;
    } else {
      result["icon"] = null;
    }
    if (self.color !== null) {
      result["color"] =
        typeof (self.color as any)?.__serialize === "function"
          ? (self.color as any).__serialize(ctx)
          : self.color;
    } else {
      result["color"] = null;
    }
    return result;
  }
}

export namespace Route {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Route, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Route, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Route.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Route | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Route.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("techs" in obj)) {
      errors.push({ field: "techs", message: "missing required field" });
    }
    if (!("active" in obj)) {
      errors.push({ field: "active", message: "missing required field" });
    }
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (!("phone" in obj)) {
      errors.push({ field: "phone", message: "missing required field" });
    }
    if (!("position" in obj)) {
      errors.push({ field: "position", message: "missing required field" });
    }
    if (!("serviceRoute" in obj)) {
      errors.push({ field: "serviceRoute", message: "missing required field" });
    }
    if (!("defaultDurationHours" in obj)) {
      errors.push({
        field: "defaultDurationHours",
        message: "missing required field",
      });
    }
    if (!("tags" in obj)) {
      errors.push({ field: "tags", message: "missing required field" });
    }
    if (!("icon" in obj)) {
      errors.push({ field: "icon", message: "missing required field" });
    }
    if (!("color" in obj)) {
      errors.push({ field: "color", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_techs = obj["techs"];
      instance.techs = __raw_techs;
    }
    {
      const __raw_active = obj["active"];
      instance.active = __raw_active;
    }
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    {
      const __raw_phone = obj["phone"];
      instance.phone = __raw_phone;
    }
    {
      const __raw_position = obj["position"];
      instance.position = __raw_position;
    }
    {
      const __raw_serviceRoute = obj["serviceRoute"];
      instance.serviceRoute = __raw_serviceRoute;
    }
    {
      const __raw_defaultDurationHours = obj["defaultDurationHours"];
      instance.defaultDurationHours = __raw_defaultDurationHours;
    }
    {
      const __raw_tags = obj["tags"];
      instance.tags = __raw_tags;
    }
    {
      const __raw_icon = obj["icon"];
      instance.icon = __raw_icon;
    }
    {
      const __raw_color = obj["color"];
      instance.color = __raw_color;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Route;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Route>(
    field: K,
    value: Route[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
      case "phone": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "phone", message: "must not be empty" });
        }
        break;
      }
      case "position": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "position", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Route>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    if ("phone" in partial && partial.phone !== undefined) {
      const __val = partial.phone as string;
      if (__val.length === 0) {
        errors.push({ field: "phone", message: "must not be empty" });
      }
    }
    if ("position" in partial && partial.position !== undefined) {
      const __val = partial.position as string;
      if (__val.length === 0) {
        errors.push({ field: "position", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace Route {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    techs: Option<Array<string>>;
    active: Option<Array<string>>;
    name: Option<Array<string>>;
    phone: Option<Array<string>>;
    position: Option<Array<string>>;
    serviceRoute: Option<Array<string>>;
    defaultDurationHours: Option<Array<string>>;
    tags: Option<Array<string>>;
    icon: Option<Array<string>>;
    color: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      techs: Option<boolean>;
      active: Option<boolean>;
      name: Option<boolean>;
      phone: Option<boolean>;
      position: Option<boolean>;
      serviceRoute: Option<boolean>;
      defaultDurationHours: Option<boolean>;
      tags: Option<boolean>;
      icon: Option<boolean>;
      color: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly techs: FieldController<(string | Employee)[] | null>;
    readonly active: FieldController<boolean>;
    readonly name: FieldController<string>;
    readonly phone: FieldController<string>;
    readonly position: FieldController<string>;
    readonly serviceRoute: FieldController<boolean>;
    readonly defaultDurationHours: FieldController<number>;
    readonly tags: ArrayFieldController<string>;
    readonly icon: FieldController<string | null>;
    readonly color: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Route;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Route, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Route>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Route>,
  ): Gigaform {
    let data = $state({ ...Route.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      techs: Option.none(),
      active: Option.none(),
      name: Option.none(),
      phone: Option.none(),
      position: Option.none(),
      serviceRoute: Option.none(),
      defaultDurationHours: Option.none(),
      tags: Option.none(),
      icon: Option.none(),
      color: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      techs: Option.none(),
      active: Option.none(),
      name: Option.none(),
      phone: Option.none(),
      position: Option.none(),
      serviceRoute: Option.none(),
      defaultDurationHours: Option.none(),
      tags: Option.none(),
      icon: Option.none(),
      color: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      techs: {
        path: ["techs"] as const,
        name: "techs",
        constraints: { required: true },

        get: () => data.techs,
        set: (value: (string | Employee)[] | null) => {
          data.techs = value;
        },
        getError: () => errors.techs,
        setError: (value: Option<Array<string>>) => {
          errors.techs = value;
        },
        getTainted: () => tainted.techs,
        setTainted: (value: Option<boolean>) => {
          tainted.techs = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "techs")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("techs", data.techs);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      active: {
        path: ["active"] as const,
        name: "active",
        constraints: { required: true },

        get: () => data.active,
        set: (value: boolean) => {
          data.active = value;
        },
        getError: () => errors.active,
        setError: (value: Option<Array<string>>) => {
          errors.active = value;
        },
        getTainted: () => tainted.active,
        setTainted: (value: Option<boolean>) => {
          tainted.active = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "active")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("active", data.active);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("name", data.name);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      phone: {
        path: ["phone"] as const,
        name: "phone",
        constraints: { required: true },

        get: () => data.phone,
        set: (value: string) => {
          data.phone = value;
        },
        getError: () => errors.phone,
        setError: (value: Option<Array<string>>) => {
          errors.phone = value;
        },
        getTainted: () => tainted.phone,
        setTainted: (value: Option<boolean>) => {
          tainted.phone = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "phone")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("phone", data.phone);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      position: {
        path: ["position"] as const,
        name: "position",
        constraints: { required: true },

        get: () => data.position,
        set: (value: string) => {
          data.position = value;
        },
        getError: () => errors.position,
        setError: (value: Option<Array<string>>) => {
          errors.position = value;
        },
        getTainted: () => tainted.position,
        setTainted: (value: Option<boolean>) => {
          tainted.position = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "position")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("position", data.position);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      serviceRoute: {
        path: ["serviceRoute"] as const,
        name: "serviceRoute",
        constraints: { required: true },

        get: () => data.serviceRoute,
        set: (value: boolean) => {
          data.serviceRoute = value;
        },
        getError: () => errors.serviceRoute,
        setError: (value: Option<Array<string>>) => {
          errors.serviceRoute = value;
        },
        getTainted: () => tainted.serviceRoute,
        setTainted: (value: Option<boolean>) => {
          tainted.serviceRoute = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "serviceRoute")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField(
            "serviceRoute",
            data.serviceRoute,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      defaultDurationHours: {
        path: ["defaultDurationHours"] as const,
        name: "defaultDurationHours",
        constraints: { required: true },

        get: () => data.defaultDurationHours,
        set: (value: number) => {
          data.defaultDurationHours = value;
        },
        getError: () => errors.defaultDurationHours,
        setError: (value: Option<Array<string>>) => {
          errors.defaultDurationHours = value;
        },
        getTainted: () => tainted.defaultDurationHours,
        setTainted: (value: Option<boolean>) => {
          tainted.defaultDurationHours = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "defaultDurationHours")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField(
            "defaultDurationHours",
            data.defaultDurationHours,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      tags: {
        path: ["tags"] as const,
        name: "tags",
        constraints: { required: true },

        get: () => data.tags,
        set: (value: string[]) => {
          data.tags = value;
        },
        getError: () => errors.tags,
        setError: (value: Option<Array<string>>) => {
          errors.tags = value;
        },
        getTainted: () => tainted.tags,
        setTainted: (value: Option<boolean>) => {
          tainted.tags = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "tags")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("tags", data.tags);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
        at: (index: number) => ({
          path: ["tags", index] as const,
          name: `tags.${index}`,
          constraints: { required: true },
          get: () => data.tags[index],
          set: (value: string) => {
            data.tags[index] = value;
          },
          getError: () => errors.tags,
          setError: (value: Option<Array<string>>) => {
            errors.tags = value;
          },
          getTainted: () => tainted.tags,
          setTainted: (value: Option<boolean>) => {
            tainted.tags = value;
          },
          validate: (): Array<string> => [],
        }),
        push: (item: string) => {
          data.tags.push(item);
        },
        remove: (index: number) => {
          data.tags.splice(index, 1);
        },
        swap: (a: number, b: number) => {
          [data.tags[a], data.tags[b]] = [data.tags[b], data.tags[a]];
        },
      },
      icon: {
        path: ["icon"] as const,
        name: "icon",
        constraints: { required: true },

        get: () => data.icon,
        set: (value: string | null) => {
          data.icon = value;
        },
        getError: () => errors.icon,
        setError: (value: Option<Array<string>>) => {
          errors.icon = value;
        },
        getTainted: () => tainted.icon,
        setTainted: (value: Option<boolean>) => {
          tainted.icon = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "icon")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("icon", data.icon);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      color: {
        path: ["color"] as const,
        name: "color",
        constraints: { required: true },

        get: () => data.color,
        set: (value: string | null) => {
          data.color = value;
        },
        getError: () => errors.color,
        setError: (value: Option<Array<string>>) => {
          errors.color = value;
        },
        getTainted: () => tainted.color,
        setTainted: (value: Option<boolean>) => {
          tainted.color = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Route.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "color")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Route.validateField("color", data.color);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Route,
      Array<{ field: string; message: string }>
    > {
      return Route.fromObject(data);
    }
    function reset(newOverrides?: Partial<Route>): void {
      data = { ...Route.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        techs: Option.none(),
        active: Option.none(),
        name: Option.none(),
        phone: Option.none(),
        position: Option.none(),
        serviceRoute: Option.none(),
        defaultDurationHours: Option.none(),
        tags: Option.none(),
        icon: Option.none(),
        color: Option.none(),
      };
      tainted = {
        id: Option.none(),
        techs: Option.none(),
        active: Option.none(),
        name: Option.none(),
        phone: Option.none(),
        position: Option.none(),
        serviceRoute: Option.none(),
        defaultDurationHours: Option.none(),
        tags: Option.none(),
        icon: Option.none(),
        color: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Route, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.techs = formData.get("techs") ?? "";
    {
      const activeVal = formData.get("active");
      obj.active =
        activeVal === "true" || activeVal === "on" || activeVal === "1";
    }
    obj.name = formData.get("name") ?? "";
    obj.phone = formData.get("phone") ?? "";
    obj.position = formData.get("position") ?? "";
    {
      const serviceRouteVal = formData.get("serviceRoute");
      obj.serviceRoute =
        serviceRouteVal === "true" ||
        serviceRouteVal === "on" ||
        serviceRouteVal === "1";
    }
    {
      const defaultDurationHoursStr = formData.get("defaultDurationHours");
      obj.defaultDurationHours = defaultDurationHoursStr
        ? parseFloat(defaultDurationHoursStr as string)
        : 0;
      if (
        obj.defaultDurationHours !== undefined &&
        isNaN(obj.defaultDurationHours as number)
      )
        obj.defaultDurationHours = 0;
    }
    obj.tags = formData.getAll("tags") as Array<string>;
    obj.icon = formData.get("icon") ?? "";
    obj.color = formData.get("color") ?? "";
    return Route.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface EmailParts {
  local: string;

  domainName: string;

  topLevelDomain: string;
}

export namespace EmailParts {
  export function defaultValue(): EmailParts {
    return { local: "", domainName: "", topLevelDomain: "" } as EmailParts;
  }
}

export namespace EmailParts {
  export function toStringifiedJSON(self: EmailParts): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: EmailParts): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: EmailParts,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "EmailParts", __id };
    result["local"] = self.local;
    result["domainName"] = self.domainName;
    result["topLevelDomain"] = self.topLevelDomain;
    return result;
  }
}

export namespace EmailParts {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<EmailParts, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<EmailParts, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "EmailParts.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): EmailParts | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "EmailParts.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("local" in obj)) {
      errors.push({ field: "local", message: "missing required field" });
    }
    if (!("domainName" in obj)) {
      errors.push({ field: "domainName", message: "missing required field" });
    }
    if (!("topLevelDomain" in obj)) {
      errors.push({
        field: "topLevelDomain",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_local = obj["local"];
      instance.local = __raw_local;
    }
    {
      const __raw_domainName = obj["domainName"];
      instance.domainName = __raw_domainName;
    }
    {
      const __raw_topLevelDomain = obj["topLevelDomain"];
      instance.topLevelDomain = __raw_topLevelDomain;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as EmailParts;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof EmailParts>(
    field: K,
    value: EmailParts[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "local": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "local", message: "must not be empty" });
        }
        break;
      }
      case "domainName": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "domainName", message: "must not be empty" });
        }
        break;
      }
      case "topLevelDomain": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({
            field: "topLevelDomain",
            message: "must not be empty",
          });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<EmailParts>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("local" in partial && partial.local !== undefined) {
      const __val = partial.local as string;
      if (__val.length === 0) {
        errors.push({ field: "local", message: "must not be empty" });
      }
    }
    if ("domainName" in partial && partial.domainName !== undefined) {
      const __val = partial.domainName as string;
      if (__val.length === 0) {
        errors.push({ field: "domainName", message: "must not be empty" });
      }
    }
    if ("topLevelDomain" in partial && partial.topLevelDomain !== undefined) {
      const __val = partial.topLevelDomain as string;
      if (__val.length === 0) {
        errors.push({ field: "topLevelDomain", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace EmailParts {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    local: Option<Array<string>>;
    domainName: Option<Array<string>>;
    topLevelDomain: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      local: Option<boolean>;
      domainName: Option<boolean>;
      topLevelDomain: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly local: FieldController<string>;
    readonly domainName: FieldController<string>;
    readonly topLevelDomain: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: EmailParts;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<EmailParts, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<EmailParts>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<EmailParts>,
  ): Gigaform {
    let data = $state({ ...EmailParts.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      local: Option.none(),
      domainName: Option.none(),
      topLevelDomain: Option.none(),
    });
    let tainted = $state<Tainted>({
      local: Option.none(),
      domainName: Option.none(),
      topLevelDomain: Option.none(),
    });
    const fields: FieldControllers = {
      local: {
        path: ["local"] as const,
        name: "local",
        constraints: { required: true },

        get: () => data.local,
        set: (value: string) => {
          data.local = value;
        },
        getError: () => errors.local,
        setError: (value: Option<Array<string>>) => {
          errors.local = value;
        },
        getTainted: () => tainted.local,
        setTainted: (value: Option<boolean>) => {
          tainted.local = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = EmailParts.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "local")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = EmailParts.validateField("local", data.local);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      domainName: {
        path: ["domainName"] as const,
        name: "domainName",
        constraints: { required: true },

        get: () => data.domainName,
        set: (value: string) => {
          data.domainName = value;
        },
        getError: () => errors.domainName,
        setError: (value: Option<Array<string>>) => {
          errors.domainName = value;
        },
        getTainted: () => tainted.domainName,
        setTainted: (value: Option<boolean>) => {
          tainted.domainName = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = EmailParts.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "domainName")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = EmailParts.validateField(
            "domainName",
            data.domainName,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      topLevelDomain: {
        path: ["topLevelDomain"] as const,
        name: "topLevelDomain",
        constraints: { required: true },

        get: () => data.topLevelDomain,
        set: (value: string) => {
          data.topLevelDomain = value;
        },
        getError: () => errors.topLevelDomain,
        setError: (value: Option<Array<string>>) => {
          errors.topLevelDomain = value;
        },
        getTainted: () => tainted.topLevelDomain,
        setTainted: (value: Option<boolean>) => {
          tainted.topLevelDomain = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = EmailParts.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "topLevelDomain")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = EmailParts.validateField(
            "topLevelDomain",
            data.topLevelDomain,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      EmailParts,
      Array<{ field: string; message: string }>
    > {
      return EmailParts.fromObject(data);
    }
    function reset(newOverrides?: Partial<EmailParts>): void {
      data = { ...EmailParts.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        local: Option.none(),
        domainName: Option.none(),
        topLevelDomain: Option.none(),
      };
      tainted = {
        local: Option.none(),
        domainName: Option.none(),
        topLevelDomain: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<EmailParts, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.local = formData.get("local") ?? "";
    obj.domainName = formData.get("domainName") ?? "";
    obj.topLevelDomain = formData.get("topLevelDomain") ?? "";
    return EmailParts.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Sent {
  recipient: string | null;
  method: string | null;
}

export namespace Sent {
  export function defaultValue(): Sent {
    return { recipient: null, method: null } as Sent;
  }
}

export namespace Sent {
  export function toStringifiedJSON(self: Sent): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Sent): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Sent,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Sent", __id };
    if (self.recipient !== null) {
      result["recipient"] =
        typeof (self.recipient as any)?.__serialize === "function"
          ? (self.recipient as any).__serialize(ctx)
          : self.recipient;
    } else {
      result["recipient"] = null;
    }
    if (self.method !== null) {
      result["method"] =
        typeof (self.method as any)?.__serialize === "function"
          ? (self.method as any).__serialize(ctx)
          : self.method;
    } else {
      result["method"] = null;
    }
    return result;
  }
}

export namespace Sent {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Sent, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Sent, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Sent.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Sent | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Sent.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("recipient" in obj)) {
      errors.push({ field: "recipient", message: "missing required field" });
    }
    if (!("method" in obj)) {
      errors.push({ field: "method", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_recipient = obj["recipient"];
      instance.recipient = __raw_recipient;
    }
    {
      const __raw_method = obj["method"];
      instance.method = __raw_method;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Sent;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Sent>(
    field: K,
    value: Sent[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Sent>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Sent {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    recipient: Option<Array<string>>;
    method: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { recipient: Option<boolean>; method: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly recipient: FieldController<string | null>;
    readonly method: FieldController<string | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Sent;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Sent, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Sent>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Sent>,
  ): Gigaform {
    let data = $state({ ...Sent.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      recipient: Option.none(),
      method: Option.none(),
    });
    let tainted = $state<Tainted>({
      recipient: Option.none(),
      method: Option.none(),
    });
    const fields: FieldControllers = {
      recipient: {
        path: ["recipient"] as const,
        name: "recipient",
        constraints: { required: true },

        get: () => data.recipient,
        set: (value: string | null) => {
          data.recipient = value;
        },
        getError: () => errors.recipient,
        setError: (value: Option<Array<string>>) => {
          errors.recipient = value;
        },
        getTainted: () => tainted.recipient,
        setTainted: (value: Option<boolean>) => {
          tainted.recipient = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Sent.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "recipient")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Sent.validateField("recipient", data.recipient);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      method: {
        path: ["method"] as const,
        name: "method",
        constraints: { required: true },

        get: () => data.method,
        set: (value: string | null) => {
          data.method = value;
        },
        getError: () => errors.method,
        setError: (value: Option<Array<string>>) => {
          errors.method = value;
        },
        getTainted: () => tainted.method,
        setTainted: (value: Option<boolean>) => {
          tainted.method = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Sent.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "method")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Sent.validateField("method", data.method);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Sent,
      Array<{ field: string; message: string }>
    > {
      return Sent.fromObject(data);
    }
    function reset(newOverrides?: Partial<Sent>): void {
      data = { ...Sent.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        recipient: Option.none(),
        method: Option.none(),
      };
      tainted = { recipient: Option.none(), method: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Sent, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.recipient = formData.get("recipient") ?? "";
    obj.method = formData.get("method") ?? "";
    return Sent.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface BilledItem {
  item: Item;
<<<<<<< Updated upstream
  quantity: number;
  taxed: boolean;
=======

  quantity: number;

  taxed: boolean;

>>>>>>> Stashed changes
  upsale: boolean;
}

export namespace BilledItem {
  export function defaultValue(): BilledItem {
    return { item: "", quantity: 0, taxed: false, upsale: false } as BilledItem;
  }
}

export namespace BilledItem {
  export function toStringifiedJSON(self: BilledItem): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: BilledItem): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: BilledItem,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "BilledItem", __id };
    result["item"] =
      typeof (self.item as any)?.__serialize === "function"
        ? (self.item as any).__serialize(ctx)
        : self.item;
    result["quantity"] = self.quantity;
    result["taxed"] = self.taxed;
    result["upsale"] = self.upsale;
    return result;
  }
}

export namespace BilledItem {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<BilledItem, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<BilledItem, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "BilledItem.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): BilledItem | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "BilledItem.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("item" in obj)) {
      errors.push({ field: "item", message: "missing required field" });
    }
    if (!("quantity" in obj)) {
      errors.push({ field: "quantity", message: "missing required field" });
    }
    if (!("taxed" in obj)) {
      errors.push({ field: "taxed", message: "missing required field" });
    }
    if (!("upsale" in obj)) {
      errors.push({ field: "upsale", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_item = obj["item"];
      if (typeof (Item as any)?.__deserialize === "function") {
        const __result = (Item as any).__deserialize(__raw_item, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "item", __result);
      } else {
        instance.item = __raw_item;
      }
    }
    {
      const __raw_quantity = obj["quantity"];
      instance.quantity = __raw_quantity;
    }
    {
      const __raw_taxed = obj["taxed"];
      instance.taxed = __raw_taxed;
    }
    {
      const __raw_upsale = obj["upsale"];
      instance.upsale = __raw_upsale;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as BilledItem;
  }
}

export namespace BilledItem {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    item: Option<Array<string>>;
    quantity: Option<Array<string>>;
    taxed: Option<Array<string>>;
    upsale: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      item: Option<boolean>;
      quantity: Option<boolean>;
      taxed: Option<boolean>;
      upsale: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly item: FieldController<Item>;
    readonly quantity: FieldController<number>;
    readonly taxed: FieldController<boolean>;
    readonly upsale: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: BilledItem;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<BilledItem, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<BilledItem>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<BilledItem>,
  ): Gigaform {
    let data = $state({ ...BilledItem.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      item: Option.none(),
      quantity: Option.none(),
      taxed: Option.none(),
      upsale: Option.none(),
    });
    let tainted = $state<Tainted>({
      item: Option.none(),
      quantity: Option.none(),
      taxed: Option.none(),
      upsale: Option.none(),
    });
    const fields: FieldControllers = {
      item: {
        path: ["item"] as const,
        name: "item",
        constraints: { required: true },

        get: () => data.item,
        set: (value: Item) => {
          data.item = value;
        },
        getError: () => errors.item,
        setError: (value: Option<Array<string>>) => {
          errors.item = value;
        },
        getTainted: () => tainted.item,
        setTainted: (value: Option<boolean>) => {
          tainted.item = value;
        },
        validate: (): Array<string> => {
          const result = BilledItem.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "item")
              .map((e) => e.message);
          }
          return [];
        },
      },
      quantity: {
        path: ["quantity"] as const,
        name: "quantity",
        constraints: { required: true },

        get: () => data.quantity,
        set: (value: number) => {
          data.quantity = value;
        },
        getError: () => errors.quantity,
        setError: (value: Option<Array<string>>) => {
          errors.quantity = value;
        },
        getTainted: () => tainted.quantity,
        setTainted: (value: Option<boolean>) => {
          tainted.quantity = value;
        },
        validate: (): Array<string> => {
          const result = BilledItem.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "quantity")
              .map((e) => e.message);
          }
          return [];
        },
      },
      taxed: {
        path: ["taxed"] as const,
        name: "taxed",
        constraints: { required: true },

        get: () => data.taxed,
        set: (value: boolean) => {
          data.taxed = value;
        },
        getError: () => errors.taxed,
        setError: (value: Option<Array<string>>) => {
          errors.taxed = value;
        },
        getTainted: () => tainted.taxed,
        setTainted: (value: Option<boolean>) => {
          tainted.taxed = value;
        },
        validate: (): Array<string> => {
          const result = BilledItem.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "taxed")
              .map((e) => e.message);
          }
          return [];
        },
      },
      upsale: {
        path: ["upsale"] as const,
        name: "upsale",
        constraints: { required: true },

        get: () => data.upsale,
        set: (value: boolean) => {
          data.upsale = value;
        },
        getError: () => errors.upsale,
        setError: (value: Option<Array<string>>) => {
          errors.upsale = value;
        },
        getTainted: () => tainted.upsale,
        setTainted: (value: Option<boolean>) => {
          tainted.upsale = value;
        },
        validate: (): Array<string> => {
          const result = BilledItem.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "upsale")
              .map((e) => e.message);
          }
          return [];
        },
      },
    };
    function validate(): Result<
      BilledItem,
      Array<{ field: string; message: string }>
    > {
      return BilledItem.fromObject(data);
    }
    function reset(newOverrides?: Partial<BilledItem>): void {
      data = { ...BilledItem.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        item: Option.none(),
        quantity: Option.none(),
        taxed: Option.none(),
        upsale: Option.none(),
      };
      tainted = {
        item: Option.none(),
        quantity: Option.none(),
        taxed: Option.none(),
        upsale: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<BilledItem, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "item."
      const itemObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("item.")) {
          const fieldName = key.slice("item.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = itemObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.item = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.item = v;
          });
        } else {
          instance.item = __result;
        }
      } else {
        instance.item = __raw_item;
      }
    }
    {
      const __raw_quantity = obj["quantity"];
      instance.quantity = __raw_quantity;
    }
    {
      const __raw_taxed = obj["taxed"];
      instance.taxed = __raw_taxed;
    }
    {
      const __raw_upsale = obj["upsale"];
      instance.upsale = __raw_upsale;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as BilledItem;
  }
  export function validateField<K extends keyof BilledItem>(
    field: K,
    value: BilledItem[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<BilledItem>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace BilledItem {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    item: Option<Array<string>>;
    quantity: Option<Array<string>>;
    taxed: Option<Array<string>>;
    upsale: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      item: Option<boolean>;
      quantity: Option<boolean>;
      taxed: Option<boolean>;
      upsale: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly item: FieldController<Item>;
    readonly quantity: FieldController<number>;
    readonly taxed: FieldController<boolean>;
    readonly upsale: FieldController<boolean>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: BilledItem;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<BilledItem, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<BilledItem>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<BilledItem>,
  ): Gigaform {
    let data = $state({ ...BilledItem.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      item: Option.none(),
      quantity: Option.none(),
      taxed: Option.none(),
      upsale: Option.none(),
    });
    let tainted = $state<Tainted>({
      item: Option.none(),
      quantity: Option.none(),
      taxed: Option.none(),
      upsale: Option.none(),
    });
    const fields: FieldControllers = {
      item: {
        path: ["item"] as const,
        name: "item",
        constraints: { required: true },
        label: "Item",
        get: () => data.item,
        set: (value: Item) => {
          data.item = value;
        },
        getError: () => errors.item,
        setError: (value: Option<Array<string>>) => {
          errors.item = value;
        },
        getTainted: () => tainted.item,
        setTainted: (value: Option<boolean>) => {
          tainted.item = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField("item", data.item);
          return fieldErrors.map((e) => e.message);
        },
      },
      quantity: {
        path: ["quantity"] as const,
        name: "quantity",
        constraints: { required: true },
        label: "Quantity",
        get: () => data.quantity,
        set: (value: number) => {
          data.quantity = value;
        },
        getError: () => errors.quantity,
        setError: (value: Option<Array<string>>) => {
          errors.quantity = value;
        },
        getTainted: () => tainted.quantity,
        setTainted: (value: Option<boolean>) => {
          tainted.quantity = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField(
            "quantity",
            data.quantity,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      taxed: {
        path: ["taxed"] as const,
        name: "taxed",
        constraints: { required: true },
        label: "Taxed",
        get: () => data.taxed,
        set: (value: boolean) => {
          data.taxed = value;
        },
        getError: () => errors.taxed,
        setError: (value: Option<Array<string>>) => {
          errors.taxed = value;
        },
        getTainted: () => tainted.taxed,
        setTainted: (value: Option<boolean>) => {
          tainted.taxed = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField("taxed", data.taxed);
          return fieldErrors.map((e) => e.message);
        },
      },
      upsale: {
        path: ["upsale"] as const,
        name: "upsale",
        constraints: { required: true },
        label: "Upsale",
        get: () => data.upsale,
        set: (value: boolean) => {
          data.upsale = value;
        },
        getError: () => errors.upsale,
        setError: (value: Option<Array<string>>) => {
          errors.upsale = value;
        },
        getTainted: () => tainted.upsale,
        setTainted: (value: Option<boolean>) => {
          tainted.upsale = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = BilledItem.validateField("upsale", data.upsale);
          return fieldErrors.map((e) => e.message);
        },
      },
    };
    function validate(): Result<
      BilledItem,
      Array<{ field: string; message: string }>
    > {
      return BilledItem.fromObject(data);
    }
    function reset(newOverrides?: Partial<BilledItem>): void {
      data = { ...BilledItem.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        item: Option.none(),
        quantity: Option.none(),
        taxed: Option.none(),
        upsale: Option.none(),
      };
      tainted = {
        item: Option.none(),
        quantity: Option.none(),
        taxed: Option.none(),
        upsale: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<BilledItem, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "item."
      const itemObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("item.")) {
          const fieldName = key.slice("item.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = itemObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.item = itemObj;
    }
    {
      const quantityStr = formData.get("quantity");
      obj.quantity = quantityStr ? parseFloat(quantityStr as string) : 0;
      if (obj.quantity !== undefined && isNaN(obj.quantity as number))
        obj.quantity = 0;
    }
    {
      const taxedVal = formData.get("taxed");
      obj.taxed = taxedVal === "true" || taxedVal === "on" || taxedVal === "1";
    }
    {
      const upsaleVal = formData.get("upsale");
      obj.upsale =
        upsaleVal === "true" || upsaleVal === "on" || upsaleVal === "1";
    }
    return BilledItem.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Coordinates {
  lat: number;
  lng: number;
}

export namespace Coordinates {
  export function defaultValue(): Coordinates {
    return { lat: 0, lng: 0 } as Coordinates;
  }
}

export namespace Coordinates {
  export function toStringifiedJSON(self: Coordinates): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Coordinates): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Coordinates,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Coordinates", __id };
    result["lat"] = self.lat;
    result["lng"] = self.lng;
    return result;
  }
}

export namespace Coordinates {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Coordinates, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Coordinates, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "Coordinates.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Coordinates | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Coordinates.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("lat" in obj)) {
      errors.push({ field: "lat", message: "missing required field" });
    }
    if (!("lng" in obj)) {
      errors.push({ field: "lng", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_lat = obj["lat"];
      instance.lat = __raw_lat;
    }
    {
      const __raw_lng = obj["lng"];
      instance.lng = __raw_lng;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Coordinates;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Coordinates>(
    field: K,
    value: Coordinates[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Coordinates>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Coordinates {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    lat: Option<Array<string>>;
    lng: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { lat: Option<boolean>; lng: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly lat: FieldController<number>;
    readonly lng: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Coordinates;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Coordinates, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Coordinates>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Coordinates>,
  ): Gigaform {
    let data = $state({ ...Coordinates.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      lat: Option.none(),
      lng: Option.none(),
    });
    let tainted = $state<Tainted>({ lat: Option.none(), lng: Option.none() });
    const fields: FieldControllers = {
      lat: {
        path: ["lat"] as const,
        name: "lat",
        constraints: { required: true },

        get: () => data.lat,
        set: (value: number) => {
          data.lat = value;
        },
        getError: () => errors.lat,
        setError: (value: Option<Array<string>>) => {
          errors.lat = value;
        },
        getTainted: () => tainted.lat,
        setTainted: (value: Option<boolean>) => {
          tainted.lat = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Coordinates.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lat")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Coordinates.validateField("lat", data.lat);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      lng: {
        path: ["lng"] as const,
        name: "lng",
        constraints: { required: true },

        get: () => data.lng,
        set: (value: number) => {
          data.lng = value;
        },
        getError: () => errors.lng,
        setError: (value: Option<Array<string>>) => {
          errors.lng = value;
        },
        getTainted: () => tainted.lng,
        setTainted: (value: Option<boolean>) => {
          tainted.lng = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Coordinates.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "lng")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Coordinates.validateField("lng", data.lng);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Coordinates,
      Array<{ field: string; message: string }>
    > {
      return Coordinates.fromObject(data);
    }
    function reset(newOverrides?: Partial<Coordinates>): void {
      data = { ...Coordinates.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        lat: Option.none(),
        lng: Option.none(),
      };
      tainted = { lat: Option.none(), lng: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Coordinates, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const latStr = formData.get("lat");
      obj.lat = latStr ? parseFloat(latStr as string) : 0;
      if (obj.lat !== undefined && isNaN(obj.lat as number)) obj.lat = 0;
    }
    {
      const lngStr = formData.get("lng");
      obj.lng = lngStr ? parseFloat(lngStr as string) : 0;
      if (obj.lng !== undefined && isNaN(obj.lng as number)) obj.lng = 0;
    }
    return Coordinates.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Ordered {
  id: string;

  in: string | Account;

  out: string | Order;
  date: string;
}

export namespace Ordered {
  export function defaultValue(): Ordered {
    return { id: "", in: "", out: "", date: "" } as Ordered;
  }
}

export namespace Ordered {
  export function toStringifiedJSON(self: Ordered): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Ordered): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Ordered,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Ordered", __id };
    result["id"] = self.id;
    result["in"] = self.in;
    result["out"] = self.out;
    result["date"] = self.date;
    return result;
  }
}

export namespace Ordered {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Ordered, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Ordered, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Ordered.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Ordered | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Ordered.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("id" in obj)) {
      errors.push({ field: "id", message: "missing required field" });
    }
    if (!("in" in obj)) {
      errors.push({ field: "in", message: "missing required field" });
    }
    if (!("out" in obj)) {
      errors.push({ field: "out", message: "missing required field" });
    }
    if (!("date" in obj)) {
      errors.push({ field: "date", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_id = obj["id"];
      instance.id = __raw_id;
    }
    {
      const __raw_in = obj["in"];
      instance.in = __raw_in;
    }
    {
      const __raw_out = obj["out"];
      instance.out = __raw_out;
    }
    {
      const __raw_date = obj["date"];
      instance.date = __raw_date;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Ordered;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Ordered>(
    field: K,
    value: Ordered[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Ordered>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Ordered {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    id: Option<Array<string>>;
    in: Option<Array<string>>;
    out: Option<Array<string>>;
    date: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      id: Option<boolean>;
      in: Option<boolean>;
      out: Option<boolean>;
      date: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly id: FieldController<string>;
    readonly in: FieldController<string | Account>;
    readonly out: FieldController<string | Order>;
    readonly date: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Ordered;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Ordered, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Ordered>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Ordered>,
  ): Gigaform {
    let data = $state({ ...Ordered.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      id: Option.none(),
      in: Option.none(),
      out: Option.none(),
      date: Option.none(),
    });
    let tainted = $state<Tainted>({
      id: Option.none(),
      in: Option.none(),
      out: Option.none(),
      date: Option.none(),
    });
    const fields: FieldControllers = {
      id: {
        path: ["id"] as const,
        name: "id",
        constraints: { required: true },

        get: () => data.id,
        set: (value: string) => {
          data.id = value;
        },
        getError: () => errors.id,
        setError: (value: Option<Array<string>>) => {
          errors.id = value;
        },
        getTainted: () => tainted.id,
        setTainted: (value: Option<boolean>) => {
          tainted.id = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordered.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "id")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordered.validateField("id", data.id);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      in: {
        path: ["in"] as const,
        name: "in",
        constraints: { required: true },

        get: () => data.in,
        set: (value: string | Account) => {
          data.in = value;
        },
        getError: () => errors.in,
        setError: (value: Option<Array<string>>) => {
          errors.in = value;
        },
        getTainted: () => tainted.in,
        setTainted: (value: Option<boolean>) => {
          tainted.in = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordered.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "in")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordered.validateField("in", data.in);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      out: {
        path: ["out"] as const,
        name: "out",
        constraints: { required: true },

        get: () => data.out,
        set: (value: string | Order) => {
          data.out = value;
        },
        getError: () => errors.out,
        setError: (value: Option<Array<string>>) => {
          errors.out = value;
        },
        getTainted: () => tainted.out,
        setTainted: (value: Option<boolean>) => {
          tainted.out = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordered.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "out")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordered.validateField("out", data.out);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      date: {
        path: ["date"] as const,
        name: "date",
        constraints: { required: true },

        get: () => data.date,
        set: (value: string) => {
          data.date = value;
        },
        getError: () => errors.date,
        setError: (value: Option<Array<string>>) => {
          errors.date = value;
        },
        getTainted: () => tainted.date,
        setTainted: (value: Option<boolean>) => {
          tainted.date = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Ordered.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "date")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Ordered.validateField("date", data.date);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Ordered,
      Array<{ field: string; message: string }>
    > {
      return Ordered.fromObject(data);
    }
    function reset(newOverrides?: Partial<Ordered>): void {
      data = { ...Ordered.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        id: Option.none(),
        in: Option.none(),
        out: Option.none(),
        date: Option.none(),
      };
      tainted = {
        id: Option.none(),
        in: Option.none(),
        out: Option.none(),
        date: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Ordered, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.id = formData.get("id") ?? "";
    obj.in = formData.get("in") ?? "";
    obj.out = formData.get("out") ?? "";
    obj.date = formData.get("date") ?? "";
    return Ordered.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Email {
  canEmail: boolean;

  emailString: string;
}

export namespace Email {
  export function defaultValue(): Email {
    return { canEmail: false, emailString: "" } as Email;
  }
}

export namespace Email {
  export function toStringifiedJSON(self: Email): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Email): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Email,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Email", __id };
    result["canEmail"] = self.canEmail;
    result["emailString"] = self.emailString;
    return result;
  }
}

export namespace Email {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Email, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Email, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Email.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Email | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        { field: "_root", message: "Email.__deserialize: expected an object" },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("canEmail" in obj)) {
      errors.push({ field: "canEmail", message: "missing required field" });
    }
    if (!("emailString" in obj)) {
      errors.push({ field: "emailString", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_canEmail = obj["canEmail"];
      instance.canEmail = __raw_canEmail;
    }
    {
      const __raw_emailString = obj["emailString"];
      instance.emailString = __raw_emailString;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Email;
  }
<<<<<<< Updated upstream
}

export namespace Email {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    canEmail: Option<Array<string>>;
    emailString: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { canEmail: Option<boolean>; emailString: Option<boolean> };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly canEmail: FieldController<boolean>;
    readonly emailString: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Email;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Email, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Email>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Email>,
  ): Gigaform {
    let data = $state({ ...Email.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      canEmail: Option.none(),
      emailString: Option.none(),
    });
    let tainted = $state<Tainted>({
      canEmail: Option.none(),
      emailString: Option.none(),
    });
    const fields: FieldControllers = {
      canEmail: {
        path: ["canEmail"] as const,
        name: "canEmail",
        constraints: { required: true },

        get: () => data.canEmail,
        set: (value: boolean) => {
          data.canEmail = value;
        },
        getError: () => errors.canEmail,
        setError: (value: Option<Array<string>>) => {
          errors.canEmail = value;
        },
        getTainted: () => tainted.canEmail,
        setTainted: (value: Option<boolean>) => {
          tainted.canEmail = value;
        },
        validate: (): Array<string> => {
          const result = Email.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "canEmail")
              .map((e) => e.message);
          }
          return [];
        },
      },
      emailString: {
        path: ["emailString"] as const,
        name: "emailString",
        constraints: { required: true },

=======
  export function validateField<K extends keyof Email>(
    field: K,
    value: Email[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "emailString": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "emailString", message: "must not be empty" });
        }

        if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
          errors.push({
            field: "emailString",
            message: "must be a valid email",
          });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<Email>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("emailString" in partial && partial.emailString !== undefined) {
      const __val = partial.emailString as string;
      if (__val.length === 0) {
        errors.push({ field: "emailString", message: "must not be empty" });
      }

      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(__val)) {
        errors.push({ field: "emailString", message: "must be a valid email" });
      }
    }
    return errors;
  }
}

export namespace Email {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    canEmail: Option<Array<string>>;
    emailString: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { canEmail: Option<boolean>; emailString: Option<boolean> };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly canEmail: FieldController<boolean>;
    readonly emailString: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Email;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Email, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Email>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Email>,
  ): Gigaform {
    let data = $state({ ...Email.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      canEmail: Option.none(),
      emailString: Option.none(),
    });
    let tainted = $state<Tainted>({
      canEmail: Option.none(),
      emailString: Option.none(),
    });
    const fields: FieldControllers = {
      canEmail: {
        path: ["canEmail"] as const,
        name: "canEmail",
        constraints: { required: true },
        label: "Can Email",
        get: () => data.canEmail,
        set: (value: boolean) => {
          data.canEmail = value;
        },
        getError: () => errors.canEmail,
        setError: (value: Option<Array<string>>) => {
          errors.canEmail = value;
        },
        getTainted: () => tainted.canEmail,
        setTainted: (value: Option<boolean>) => {
          tainted.canEmail = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = Email.validateField("canEmail", data.canEmail);
          return fieldErrors.map((e) => e.message);
        },
      },
      emailString: {
        path: ["emailString"] as const,
        name: "emailString",
        constraints: { required: true, type: "email" },
        label: "Email",
>>>>>>> Stashed changes
        get: () => data.emailString,
        set: (value: string) => {
          data.emailString = value;
        },
        getError: () => errors.emailString,
        setError: (value: Option<Array<string>>) => {
          errors.emailString = value;
        },
        getTainted: () => tainted.emailString,
        setTainted: (value: Option<boolean>) => {
          tainted.emailString = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Email.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "emailString")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Email.validateField(
            "emailString",
            data.emailString,
          );
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Email,
      Array<{ field: string; message: string }>
    > {
      return Email.fromObject(data);
    }
    function reset(newOverrides?: Partial<Email>): void {
      data = { ...Email.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        canEmail: Option.none(),
        emailString: Option.none(),
      };
      tainted = { canEmail: Option.none(), emailString: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Email, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const canEmailVal = formData.get("canEmail");
      obj.canEmail =
        canEmailVal === "true" || canEmailVal === "on" || canEmailVal === "1";
    }
    obj.emailString = formData.get("emailString") ?? "";
    return Email.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface RecurrenceRule {
  interval: Interval;
  recurrenceBegins: string;
  recurrenceEnds: RecurrenceEnd | null;
  cancelledInstances: string[] | null;
  additionalInstances: string[] | null;
}

export namespace RecurrenceRule {
  export function defaultValue(): RecurrenceRule {
    return {
      interval: Interval.defaultValue(),
      recurrenceBegins: "",
      recurrenceEnds: null,
      cancelledInstances: null,
      additionalInstances: null,
    } as RecurrenceRule;
  }
}

export namespace RecurrenceRule {
  export function toStringifiedJSON(self: RecurrenceRule): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: RecurrenceRule): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: RecurrenceRule,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "RecurrenceRule", __id };
    result["interval"] =
      typeof (self.interval as any)?.__serialize === "function"
        ? (self.interval as any).__serialize(ctx)
        : self.interval;
    result["recurrenceBegins"] = self.recurrenceBegins;
    if (self.recurrenceEnds !== null) {
      result["recurrenceEnds"] =
        typeof (self.recurrenceEnds as any)?.__serialize === "function"
          ? (self.recurrenceEnds as any).__serialize(ctx)
          : self.recurrenceEnds;
    } else {
      result["recurrenceEnds"] = null;
    }
    if (self.cancelledInstances !== null) {
      result["cancelledInstances"] =
        typeof (self.cancelledInstances as any)?.__serialize === "function"
          ? (self.cancelledInstances as any).__serialize(ctx)
          : self.cancelledInstances;
    } else {
      result["cancelledInstances"] = null;
    }
    if (self.additionalInstances !== null) {
      result["additionalInstances"] =
        typeof (self.additionalInstances as any)?.__serialize === "function"
          ? (self.additionalInstances as any).__serialize(ctx)
          : self.additionalInstances;
    } else {
      result["additionalInstances"] = null;
    }
    return result;
  }
}

export namespace RecurrenceRule {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<RecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<RecurrenceRule, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message:
              "RecurrenceRule.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): RecurrenceRule | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "RecurrenceRule.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("interval" in obj)) {
      errors.push({ field: "interval", message: "missing required field" });
    }
    if (!("recurrenceBegins" in obj)) {
      errors.push({
        field: "recurrenceBegins",
        message: "missing required field",
      });
    }
    if (!("recurrenceEnds" in obj)) {
      errors.push({
        field: "recurrenceEnds",
        message: "missing required field",
      });
    }
    if (!("cancelledInstances" in obj)) {
      errors.push({
        field: "cancelledInstances",
        message: "missing required field",
      });
    }
    if (!("additionalInstances" in obj)) {
      errors.push({
        field: "additionalInstances",
        message: "missing required field",
      });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_interval = obj["interval"];
      if (typeof (Interval as any)?.__deserialize === "function") {
        const __result = (Interval as any).__deserialize(__raw_interval, ctx);
<<<<<<< Updated upstream
        ctx.assignOrDefer(instance, "interval", __result);
      } else {
        instance.interval = __raw_interval;
      }
    }
    {
      const __raw_recurrenceBegins = obj["recurrenceBegins"];
      instance.recurrenceBegins = __raw_recurrenceBegins;
    }
    {
      const __raw_recurrenceEnds = obj["recurrenceEnds"];
      instance.recurrenceEnds = __raw_recurrenceEnds;
    }
    {
      const __raw_cancelledInstances = obj["cancelledInstances"];
      instance.cancelledInstances = __raw_cancelledInstances;
    }
    {
      const __raw_additionalInstances = obj["additionalInstances"];
      instance.additionalInstances = __raw_additionalInstances;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as RecurrenceRule;
  }
}

export namespace RecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    interval: Option<Array<string>>;
    recurrenceBegins: Option<Array<string>>;
    recurrenceEnds: Option<Array<string>>;
    cancelledInstances: Option<Array<string>>;
    additionalInstances: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      interval: Option<boolean>;
      recurrenceBegins: Option<boolean>;
      recurrenceEnds: Option<boolean>;
      cancelledInstances: Option<boolean>;
      additionalInstances: Option<boolean>;
    };
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly interval: FieldController<Interval>;
    readonly recurrenceBegins: FieldController<string>;
    readonly recurrenceEnds: FieldController<RecurrenceEnd | null>;
    readonly cancelledInstances: FieldController<string[] | null>;
    readonly additionalInstances: FieldController<string[] | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: RecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      RecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<RecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<RecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...RecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      interval: Option.none(),
      recurrenceBegins: Option.none(),
      recurrenceEnds: Option.none(),
      cancelledInstances: Option.none(),
      additionalInstances: Option.none(),
    });
    let tainted = $state<Tainted>({
      interval: Option.none(),
      recurrenceBegins: Option.none(),
      recurrenceEnds: Option.none(),
      cancelledInstances: Option.none(),
      additionalInstances: Option.none(),
    });
    const fields: FieldControllers = {
      interval: {
        path: ["interval"] as const,
        name: "interval",
        constraints: { required: true },

        get: () => data.interval,
        set: (value: Interval) => {
          data.interval = value;
        },
        getError: () => errors.interval,
        setError: (value: Option<Array<string>>) => {
          errors.interval = value;
        },
        getTainted: () => tainted.interval,
        setTainted: (value: Option<boolean>) => {
          tainted.interval = value;
        },
        validate: (): Array<string> => {
          const result = RecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "interval")
              .map((e) => e.message);
          }
          return [];
        },
      },
      recurrenceBegins: {
        path: ["recurrenceBegins"] as const,
        name: "recurrenceBegins",
        constraints: { required: true },

        get: () => data.recurrenceBegins,
        set: (value: string) => {
          data.recurrenceBegins = value;
        },
        getError: () => errors.recurrenceBegins,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceBegins = value;
        },
        getTainted: () => tainted.recurrenceBegins,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceBegins = value;
        },
        validate: (): Array<string> => {
          const result = RecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "recurrenceBegins")
              .map((e) => e.message);
          }
          return [];
        },
      },
      recurrenceEnds: {
        path: ["recurrenceEnds"] as const,
        name: "recurrenceEnds",
        constraints: { required: true },

        get: () => data.recurrenceEnds,
        set: (value: RecurrenceEnd | null) => {
          data.recurrenceEnds = value;
        },
        getError: () => errors.recurrenceEnds,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceEnds = value;
        },
        getTainted: () => tainted.recurrenceEnds,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceEnds = value;
        },
        validate: (): Array<string> => {
          const result = RecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "recurrenceEnds")
              .map((e) => e.message);
          }
          return [];
        },
      },
      cancelledInstances: {
        path: ["cancelledInstances"] as const,
        name: "cancelledInstances",
        constraints: { required: true },

        get: () => data.cancelledInstances,
        set: (value: string[] | null) => {
          data.cancelledInstances = value;
        },
        getError: () => errors.cancelledInstances,
        setError: (value: Option<Array<string>>) => {
          errors.cancelledInstances = value;
        },
        getTainted: () => tainted.cancelledInstances,
        setTainted: (value: Option<boolean>) => {
          tainted.cancelledInstances = value;
        },
        validate: (): Array<string> => {
          const result = RecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "cancelledInstances")
              .map((e) => e.message);
          }
          return [];
        },
      },
      additionalInstances: {
        path: ["additionalInstances"] as const,
        name: "additionalInstances",
        constraints: { required: true },

        get: () => data.additionalInstances,
        set: (value: string[] | null) => {
          data.additionalInstances = value;
        },
        getError: () => errors.additionalInstances,
        setError: (value: Option<Array<string>>) => {
          errors.additionalInstances = value;
        },
        getTainted: () => tainted.additionalInstances,
        setTainted: (value: Option<boolean>) => {
          tainted.additionalInstances = value;
        },
        validate: (): Array<string> => {
          const result = RecurrenceRule.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "additionalInstances")
              .map((e) => e.message);
          }
          return [];
        },
      },
    };
    function validate(): Result<
      RecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return RecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<RecurrenceRule>): void {
      data = { ...RecurrenceRule.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        interval: Option.none(),
        recurrenceBegins: Option.none(),
        recurrenceEnds: Option.none(),
        cancelledInstances: Option.none(),
        additionalInstances: Option.none(),
      };
      tainted = {
        interval: Option.none(),
        recurrenceBegins: Option.none(),
        recurrenceEnds: Option.none(),
        cancelledInstances: Option.none(),
        additionalInstances: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<RecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "interval."
      const intervalObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("interval.")) {
          const fieldName = key.slice("interval.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = intervalObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
=======
        if (PendingRef.is(__result)) {
          instance.interval = null;
          ctx.deferPatch(__result.id, (v) => {
            instance.interval = v;
          });
        } else {
          instance.interval = __result;
        }
      } else {
        instance.interval = __raw_interval;
      }
    }
    {
      const __raw_recurrenceBegins = obj["recurrenceBegins"];
      instance.recurrenceBegins = __raw_recurrenceBegins;
    }
    {
      const __raw_recurrenceEnds = obj["recurrenceEnds"];
      instance.recurrenceEnds = __raw_recurrenceEnds;
    }
    {
      const __raw_cancelledInstances = obj["cancelledInstances"];
      instance.cancelledInstances = __raw_cancelledInstances;
    }
    {
      const __raw_additionalInstances = obj["additionalInstances"];
      instance.additionalInstances = __raw_additionalInstances;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as RecurrenceRule;
  }
  export function validateField<K extends keyof RecurrenceRule>(
    field: K,
    value: RecurrenceRule[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<RecurrenceRule>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace RecurrenceRule {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    interval: Option<Array<string>>;
    recurrenceBegins: Option<Array<string>>;
    recurrenceEnds: Option<Array<string>>;
    cancelledInstances: Option<Array<string>>;
    additionalInstances: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      interval: Option<boolean>;
      recurrenceBegins: Option<boolean>;
      recurrenceEnds: Option<boolean>;
      cancelledInstances: Option<boolean>;
      additionalInstances: Option<boolean>;
    };
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly interval: FieldController<Interval>;
    readonly recurrenceBegins: FieldController<string>;
    readonly recurrenceEnds: FieldController<RecurrenceEnd | null>;
    readonly cancelledInstances: FieldController<string[] | null>;
    readonly additionalInstances: FieldController<string[] | null>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: RecurrenceRule;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<
      RecurrenceRule,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<RecurrenceRule>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<RecurrenceRule>,
  ): Gigaform {
    let data = $state({ ...RecurrenceRule.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      interval: Option.none(),
      recurrenceBegins: Option.none(),
      recurrenceEnds: Option.none(),
      cancelledInstances: Option.none(),
      additionalInstances: Option.none(),
    });
    let tainted = $state<Tainted>({
      interval: Option.none(),
      recurrenceBegins: Option.none(),
      recurrenceEnds: Option.none(),
      cancelledInstances: Option.none(),
      additionalInstances: Option.none(),
    });
    const fields: FieldControllers = {
      interval: {
        path: ["interval"] as const,
        name: "interval",
        constraints: { required: true },

        get: () => data.interval,
        set: (value: Interval) => {
          data.interval = value;
        },
        getError: () => errors.interval,
        setError: (value: Option<Array<string>>) => {
          errors.interval = value;
        },
        getTainted: () => tainted.interval,
        setTainted: (value: Option<boolean>) => {
          tainted.interval = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "interval",
            data.interval,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      recurrenceBegins: {
        path: ["recurrenceBegins"] as const,
        name: "recurrenceBegins",
        constraints: { required: true },

        get: () => data.recurrenceBegins,
        set: (value: string) => {
          data.recurrenceBegins = value;
        },
        getError: () => errors.recurrenceBegins,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceBegins = value;
        },
        getTainted: () => tainted.recurrenceBegins,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceBegins = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "recurrenceBegins",
            data.recurrenceBegins,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      recurrenceEnds: {
        path: ["recurrenceEnds"] as const,
        name: "recurrenceEnds",
        constraints: { required: true },

        get: () => data.recurrenceEnds,
        set: (value: RecurrenceEnd | null) => {
          data.recurrenceEnds = value;
        },
        getError: () => errors.recurrenceEnds,
        setError: (value: Option<Array<string>>) => {
          errors.recurrenceEnds = value;
        },
        getTainted: () => tainted.recurrenceEnds,
        setTainted: (value: Option<boolean>) => {
          tainted.recurrenceEnds = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "recurrenceEnds",
            data.recurrenceEnds,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      cancelledInstances: {
        path: ["cancelledInstances"] as const,
        name: "cancelledInstances",
        constraints: { required: true },

        get: () => data.cancelledInstances,
        set: (value: string[] | null) => {
          data.cancelledInstances = value;
        },
        getError: () => errors.cancelledInstances,
        setError: (value: Option<Array<string>>) => {
          errors.cancelledInstances = value;
        },
        getTainted: () => tainted.cancelledInstances,
        setTainted: (value: Option<boolean>) => {
          tainted.cancelledInstances = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "cancelledInstances",
            data.cancelledInstances,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
      additionalInstances: {
        path: ["additionalInstances"] as const,
        name: "additionalInstances",
        constraints: { required: true },

        get: () => data.additionalInstances,
        set: (value: string[] | null) => {
          data.additionalInstances = value;
        },
        getError: () => errors.additionalInstances,
        setError: (value: Option<Array<string>>) => {
          errors.additionalInstances = value;
        },
        getTainted: () => tainted.additionalInstances,
        setTainted: (value: Option<boolean>) => {
          tainted.additionalInstances = value;
        },
        validate: (): Array<string> => {
          const fieldErrors = RecurrenceRule.validateField(
            "additionalInstances",
            data.additionalInstances,
          );
          return fieldErrors.map((e) => e.message);
        },
      },
    };
    function validate(): Result<
      RecurrenceRule,
      Array<{ field: string; message: string }>
    > {
      return RecurrenceRule.fromObject(data);
    }
    function reset(newOverrides?: Partial<RecurrenceRule>): void {
      data = { ...RecurrenceRule.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        interval: Option.none(),
        recurrenceBegins: Option.none(),
        recurrenceEnds: Option.none(),
        cancelledInstances: Option.none(),
        additionalInstances: Option.none(),
      };
      tainted = {
        interval: Option.none(),
        recurrenceBegins: Option.none(),
        recurrenceEnds: Option.none(),
        cancelledInstances: Option.none(),
        additionalInstances: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<RecurrenceRule, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      // Collect nested object fields with prefix "interval."
      const intervalObj: Record<string, unknown> = {};
      for (const [key, value] of formData.entries()) {
        if (key.startsWith("interval.")) {
          const fieldName = key.slice("interval.".length);
          // Handle deeper nesting by splitting on dots
          const parts = fieldName.split(".");
          let current = intervalObj;
          for (let i = 0; i < parts.length - 1; i++) {
            const part = parts[i];
            if (!(part in current)) {
              current[part] = {};
            }
            current = current[part] as Record<string, unknown>;
          }
          current[parts[parts.length - 1]] = value;
        }
>>>>>>> Stashed changes
      }
      obj.interval = intervalObj;
    }
    obj.recurrenceBegins = formData.get("recurrenceBegins") ?? "";
    obj.recurrenceEnds = formData.get("recurrenceEnds") ?? "";
    obj.cancelledInstances = formData.get("cancelledInstances") ?? "";
    obj.additionalInstances = formData.get("additionalInstances") ?? "";
    return RecurrenceRule.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface LastName {
  name: string;
}

export namespace LastName {
  export function defaultValue(): LastName {
    return { name: "" } as LastName;
  }
}

export namespace LastName {
  export function toStringifiedJSON(self: LastName): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: LastName): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: LastName,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "LastName", __id };
    result["name"] = self.name;
    return result;
  }
}

export namespace LastName {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<LastName, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<LastName, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "LastName.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): LastName | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "LastName.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("name" in obj)) {
      errors.push({ field: "name", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_name = obj["name"];
      instance.name = __raw_name;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as LastName;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof LastName>(
    field: K,
    value: LastName[K],
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    switch (field) {
      case "name": {
        const __val = value as string;
        if (__val.length === 0) {
          errors.push({ field: "name", message: "must not be empty" });
        }
        break;
      }
    }
    return errors;
  }
  export function validateFields(
    partial: Partial<LastName>,
  ): Array<{ field: string; message: string }> {
    const errors: Array<{ field: string; message: string }> = [];
    if ("name" in partial && partial.name !== undefined) {
      const __val = partial.name as string;
      if (__val.length === 0) {
        errors.push({ field: "name", message: "must not be empty" });
      }
    }
    return errors;
  }
>>>>>>> Stashed changes
}

export namespace LastName {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    name: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    { name: Option<boolean> };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly name: FieldController<string>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: LastName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<LastName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<LastName>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<LastName>,
  ): Gigaform {
    let data = $state({ ...LastName.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      name: Option.none(),
    });
    let tainted = $state<Tainted>({ name: Option.none() });
    const fields: FieldControllers = {
      name: {
        path: ["name"] as const,
        name: "name",
        constraints: { required: true },

        get: () => data.name,
        set: (value: string) => {
          data.name = value;
        },
        getError: () => errors.name,
        setError: (value: Option<Array<string>>) => {
          errors.name = value;
        },
        getTainted: () => tainted.name,
        setTainted: (value: Option<boolean>) => {
          tainted.name = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = LastName.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "name")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = LastName.validateField("name", data.name);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      LastName,
      Array<{ field: string; message: string }>
    > {
      return LastName.fromObject(data);
    }
    function reset(newOverrides?: Partial<LastName>): void {
      data = { ...LastName.defaultValue(), ...newOverrides };
      errors = { _errors: Option.none(), name: Option.none() };
      tainted = { name: Option.none() };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<LastName, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    obj.name = formData.get("name") ?? "";
    return LastName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export interface Cardinal {
  north: number;
  east: number;
  south: number;
  west: number;
}

export namespace Cardinal {
  export function defaultValue(): Cardinal {
    return { north: 0, east: 0, south: 0, west: 0 } as Cardinal;
  }
}

export namespace Cardinal {
  export function toStringifiedJSON(self: Cardinal): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(self, ctx));
  }
  export function toObject(self: Cardinal): Record<string, unknown> {
    const ctx = SerializeContext.create();
    return __serialize(self, ctx);
  }
  export function __serialize(
    self: Cardinal,
    ctx: SerializeContext,
  ): Record<string, unknown> {
    const existingId = ctx.getId(self);
    if (existingId !== undefined) {
      return { __ref: existingId };
    }
    const __id = ctx.register(self);
    const result: Record<string, unknown> = { __type: "Cardinal", __id };
    result["north"] = self.north;
    result["east"] = self.east;
    result["south"] = self.south;
    result["west"] = self.west;
    return result;
  }
}

export namespace Cardinal {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Cardinal, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Cardinal, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const resultOrRef = __deserialize(obj, ctx);
      if (PendingRef.is(resultOrRef)) {
        return Result.err([
          {
            field: "_root",
            message: "Cardinal.fromObject: root cannot be a forward reference",
          },
        ]);
      }
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(resultOrRef);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Cardinal | PendingRef {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref);
    }
    if (typeof value !== "object" || value === null || Array.isArray(value)) {
      throw new DeserializeError([
        {
          field: "_root",
          message: "Cardinal.__deserialize: expected an object",
        },
      ]);
    }
    const obj = value as Record<string, unknown>;
    const errors: Array<{ field: string; message: string }> = [];
    if (!("north" in obj)) {
      errors.push({ field: "north", message: "missing required field" });
    }
    if (!("east" in obj)) {
      errors.push({ field: "east", message: "missing required field" });
    }
    if (!("south" in obj)) {
      errors.push({ field: "south", message: "missing required field" });
    }
    if (!("west" in obj)) {
      errors.push({ field: "west", message: "missing required field" });
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    const instance: any = {};
    if (obj.__id !== undefined) {
      ctx.register(obj.__id as number, instance);
    }
    ctx.trackForFreeze(instance);
    {
      const __raw_north = obj["north"];
      instance.north = __raw_north;
    }
    {
      const __raw_east = obj["east"];
      instance.east = __raw_east;
    }
    {
      const __raw_south = obj["south"];
      instance.south = __raw_south;
    }
    {
      const __raw_west = obj["west"];
      instance.west = __raw_west;
    }
    if (errors.length > 0) {
      throw new DeserializeError(errors);
    }
    return instance as Cardinal;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Cardinal>(
    field: K,
    value: Cardinal[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Cardinal>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Cardinal {
  /** Nested error structure matching the data shape */ export type Errors = {
    _errors: Option<Array<string>>;
    north: Option<Array<string>>;
    east: Option<Array<string>>;
    south: Option<Array<string>>;
    west: Option<Array<string>>;
  };
  /** Nested boolean structure for tracking touched/dirty fields */ export type Tainted =
    {
      north: Option<boolean>;
      east: Option<boolean>;
      south: Option<boolean>;
      west: Option<boolean>;
    };
<<<<<<< Updated upstream
  /** Field controller interface for a single field */ export interface FieldController<
    T,
  > {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Type-safe field controllers for this form */ export interface FieldControllers {
    readonly north: FieldController<number>;
    readonly east: FieldController<number>;
    readonly south: FieldController<number>;
    readonly west: FieldController<number>;
  }
  /** Gigaform instance containing reactive state and field controllers */ export interface Gigaform {
    readonly data: Cardinal;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly fields: FieldControllers;
    validate(): Result<Cardinal, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Cardinal>): void;
  }
  /** Creates a new Gigaform instance with reactive state and field controllers. */ export function createForm(
    overrides?: Partial<Cardinal>,
  ): Gigaform {
    let data = $state({ ...Cardinal.defaultValue(), ...overrides });
    let errors = $state<Errors>({
      _errors: Option.none(),
      north: Option.none(),
      east: Option.none(),
      south: Option.none(),
      west: Option.none(),
    });
    let tainted = $state<Tainted>({
      north: Option.none(),
      east: Option.none(),
      south: Option.none(),
      west: Option.none(),
    });
    const fields: FieldControllers = {
      north: {
        path: ["north"] as const,
        name: "north",
        constraints: { required: true },

        get: () => data.north,
        set: (value: number) => {
          data.north = value;
        },
        getError: () => errors.north,
        setError: (value: Option<Array<string>>) => {
          errors.north = value;
        },
        getTainted: () => tainted.north,
        setTainted: (value: Option<boolean>) => {
          tainted.north = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Cardinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "north")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Cardinal.validateField("north", data.north);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      east: {
        path: ["east"] as const,
        name: "east",
        constraints: { required: true },

        get: () => data.east,
        set: (value: number) => {
          data.east = value;
        },
        getError: () => errors.east,
        setError: (value: Option<Array<string>>) => {
          errors.east = value;
        },
        getTainted: () => tainted.east,
        setTainted: (value: Option<boolean>) => {
          tainted.east = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Cardinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "east")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Cardinal.validateField("east", data.east);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      south: {
        path: ["south"] as const,
        name: "south",
        constraints: { required: true },

        get: () => data.south,
        set: (value: number) => {
          data.south = value;
        },
        getError: () => errors.south,
        setError: (value: Option<Array<string>>) => {
          errors.south = value;
        },
        getTainted: () => tainted.south,
        setTainted: (value: Option<boolean>) => {
          tainted.south = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Cardinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "south")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Cardinal.validateField("south", data.south);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
      west: {
        path: ["west"] as const,
        name: "west",
        constraints: { required: true },

        get: () => data.west,
        set: (value: number) => {
          data.west = value;
        },
        getError: () => errors.west,
        setError: (value: Option<Array<string>>) => {
          errors.west = value;
        },
        getTainted: () => tainted.west,
        setTainted: (value: Option<boolean>) => {
          tainted.west = value;
        },
        validate: (): Array<string> => {
<<<<<<< Updated upstream
          const result = Cardinal.fromObject(data);
          if (Result.isErr(result)) {
            const allErrors = Result.unwrapErr(result);
            return allErrors
              .filter((e) => e.field === "west")
              .map((e) => e.message);
          }
          return [];
=======
          const fieldErrors = Cardinal.validateField("west", data.west);
          return fieldErrors.map((e) => e.message);
>>>>>>> Stashed changes
        },
      },
    };
    function validate(): Result<
      Cardinal,
      Array<{ field: string; message: string }>
    > {
      return Cardinal.fromObject(data);
    }
    function reset(newOverrides?: Partial<Cardinal>): void {
      data = { ...Cardinal.defaultValue(), ...newOverrides };
      errors = {
        _errors: Option.none(),
        north: Option.none(),
        east: Option.none(),
        south: Option.none(),
        west: Option.none(),
      };
      tainted = {
        north: Option.none(),
        east: Option.none(),
        south: Option.none(),
        west: Option.none(),
      };
    }
    return {
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      fields,
      validate,
      reset,
    };
  }
  /** Parses FormData and validates it, returning a Result with the parsed data or errors. Delegates validation to fromStringifiedJSON() from @derive(Deserialize). */ export function fromFormData(
    formData: FormData,
  ): Result<Cardinal, Array<{ field: string; message: string }>> {
    const obj: Record<string, unknown> = {};
    {
      const northStr = formData.get("north");
      obj.north = northStr ? parseFloat(northStr as string) : 0;
      if (obj.north !== undefined && isNaN(obj.north as number)) obj.north = 0;
    }
    {
      const eastStr = formData.get("east");
      obj.east = eastStr ? parseFloat(eastStr as string) : 0;
      if (obj.east !== undefined && isNaN(obj.east as number)) obj.east = 0;
    }
    {
      const southStr = formData.get("south");
      obj.south = southStr ? parseFloat(southStr as string) : 0;
      if (obj.south !== undefined && isNaN(obj.south as number)) obj.south = 0;
    }
    {
      const westStr = formData.get("west");
      obj.west = westStr ? parseFloat(westStr as string) : 0;
      if (obj.west !== undefined && isNaN(obj.west as number)) obj.west = 0;
    }
    return Cardinal.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Interval =
  | /** @default */ DailyRecurrenceRule
  | WeeklyRecurrenceRule
  | MonthlyRecurrenceRule
  | YearlyRecurrenceRule;

export namespace Interval {
  export function defaultValue(): Interval {
    return DailyRecurrenceRule.defaultValue();
  }
}

export namespace Interval {
  export function toStringifiedJSON(value: Interval): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Interval): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Interval, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Interval {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Interval, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Interval, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Interval>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Interval {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Interval;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Interval.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Interval;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Interval>(
    field: K,
    value: Interval[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Interval>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Interval {
  /** Per-variant error types */ export type DailyRecurrenceRuleErrors = {
    _errors: Option<Array<string>>;
  };
  export type WeeklyRecurrenceRuleErrors = { _errors: Option<Array<string>> };
  export type MonthlyRecurrenceRuleErrors = { _errors: Option<Array<string>> };
  export type YearlyRecurrenceRuleErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type DailyRecurrenceRuleTainted = {};
  export type WeeklyRecurrenceRuleTainted = {};
  export type MonthlyRecurrenceRuleTainted = {};
  export type YearlyRecurrenceRuleTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "DailyRecurrenceRule" } & DailyRecurrenceRuleErrors)
    | ({ _type: "WeeklyRecurrenceRule" } & WeeklyRecurrenceRuleErrors)
    | ({ _type: "MonthlyRecurrenceRule" } & MonthlyRecurrenceRuleErrors)
    | ({ _type: "YearlyRecurrenceRule" } & YearlyRecurrenceRuleErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "DailyRecurrenceRule" } & DailyRecurrenceRuleTainted)
    | ({ _type: "WeeklyRecurrenceRule" } & WeeklyRecurrenceRuleTainted)
    | ({ _type: "MonthlyRecurrenceRule" } & MonthlyRecurrenceRuleTainted)
    | ({ _type: "YearlyRecurrenceRule" } & YearlyRecurrenceRuleTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface DailyRecurrenceRuleFieldControllers {}
  export interface WeeklyRecurrenceRuleFieldControllers {}
  export interface MonthlyRecurrenceRuleFieldControllers {}
  export interface YearlyRecurrenceRuleFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule";
    readonly data: Interval;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "DailyRecurrenceRule"
        | "WeeklyRecurrenceRule"
        | "MonthlyRecurrenceRule"
        | "YearlyRecurrenceRule",
    ): void;
    validate(): Result<Interval, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Interval>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly DailyRecurrenceRule: {
      readonly fields: DailyRecurrenceRuleFieldControllers;
    };
    readonly WeeklyRecurrenceRule: {
      readonly fields: WeeklyRecurrenceRuleFieldControllers;
    };
    readonly MonthlyRecurrenceRule: {
      readonly fields: MonthlyRecurrenceRuleFieldControllers;
    };
    readonly YearlyRecurrenceRule: {
      readonly fields: YearlyRecurrenceRuleFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Interval {
    switch (variant) {
      case "DailyRecurrenceRule":
        return DailyRecurrenceRule.defaultValue() as Interval;
      case "WeeklyRecurrenceRule":
        return WeeklyRecurrenceRule.defaultValue() as Interval;
      case "MonthlyRecurrenceRule":
        return MonthlyRecurrenceRule.defaultValue() as Interval;
      case "YearlyRecurrenceRule":
        return YearlyRecurrenceRule.defaultValue() as Interval;
      default:
        return DailyRecurrenceRule.defaultValue() as Interval;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Interval,
  ): Gigaform {
    const initialVariant:
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule" = "DailyRecurrenceRule";
    let currentVariant = $state<
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule"
    >(initialVariant);
    let data = $state<Interval>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      DailyRecurrenceRule: {
        fields: {} as DailyRecurrenceRuleFieldControllers,
      },
      WeeklyRecurrenceRule: {
        fields: {} as WeeklyRecurrenceRuleFieldControllers,
      },
      MonthlyRecurrenceRule: {
        fields: {} as MonthlyRecurrenceRuleFieldControllers,
      },
      YearlyRecurrenceRule: {
        fields: {} as YearlyRecurrenceRuleFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "DailyRecurrenceRule"
        | "WeeklyRecurrenceRule"
        | "MonthlyRecurrenceRule"
        | "YearlyRecurrenceRule",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Interval,
      Array<{ field: string; message: string }>
    > {
      return Interval.fromObject(data);
    }
    function reset(overrides?: Partial<Interval>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Interval, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "DailyRecurrenceRule"
      | "WeeklyRecurrenceRule"
      | "MonthlyRecurrenceRule"
      | "YearlyRecurrenceRule"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "DailyRecurrenceRule") {
    } else if (discriminant === "WeeklyRecurrenceRule") {
    } else if (discriminant === "MonthlyRecurrenceRule") {
    } else if (discriminant === "YearlyRecurrenceRule") {
    }
    return Interval.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Page =
  | /** @default */ "SalesHomeDashboard"
  | "SalesHomeProducts"
  | "SalesHomeServices"
  | "SalesHomePackages"
  | "SalesHomeTaxRates"
  | "SalesLeadsOverview"
  | "SalesLeadsActivities"
  | "SalesLeadsCampaigns"
  | "SalesLeadsDripCampaigns"
  | "SalesLeadsOpportunities"
  | "SalesLeadsPromotions"
  | "SalesAccountsOverview"
  | "SalesAccountsActivities"
  | "SalesAccountsBilling"
  | "SalesAccountsContracts"
  | "SalesOrdersOverview"
  | "SalesOrdersActivities"
  | "SalesOrdersPayments"
  | "SalesOrdersCommissions"
  | "SalesSchedulingSchedule"
  | "SalesSchedulingAppointments"
  | "SalesSchedulingRecurring"
  | "SalesSchedulingRoutes"
  | "SalesSchedulingReminders"
  | "UserHome";

export namespace Page {
  export function defaultValue(): Page {
    return "SalesHomeDashboard";
  }
}

export namespace Page {
  export function toStringifiedJSON(value: Page): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Page): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Page, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Page {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Page, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Page, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Page>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Page {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Page;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Page.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Page;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Page>(
    field: K,
    value: Page[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Page>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Page {
  /** Per-variant error types */ export type SalesHomeDashboardErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesHomeProductsErrors = { _errors: Option<Array<string>> };
  export type SalesHomeServicesErrors = { _errors: Option<Array<string>> };
  export type SalesHomePackagesErrors = { _errors: Option<Array<string>> };
  export type SalesHomeTaxRatesErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsOverviewErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsActivitiesErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsCampaignsErrors = { _errors: Option<Array<string>> };
  export type SalesLeadsDripCampaignsErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesLeadsOpportunitiesErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesLeadsPromotionsErrors = { _errors: Option<Array<string>> };
  export type SalesAccountsOverviewErrors = { _errors: Option<Array<string>> };
  export type SalesAccountsActivitiesErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesAccountsBillingErrors = { _errors: Option<Array<string>> };
  export type SalesAccountsContractsErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersOverviewErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersActivitiesErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersPaymentsErrors = { _errors: Option<Array<string>> };
  export type SalesOrdersCommissionsErrors = { _errors: Option<Array<string>> };
  export type SalesSchedulingScheduleErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesSchedulingAppointmentsErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesSchedulingRecurringErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesSchedulingRoutesErrors = { _errors: Option<Array<string>> };
  export type SalesSchedulingRemindersErrors = {
    _errors: Option<Array<string>>;
  };
  export type UserHomeErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type SalesHomeDashboardTainted = {};
  export type SalesHomeProductsTainted = {};
  export type SalesHomeServicesTainted = {};
  export type SalesHomePackagesTainted = {};
  export type SalesHomeTaxRatesTainted = {};
  export type SalesLeadsOverviewTainted = {};
  export type SalesLeadsActivitiesTainted = {};
  export type SalesLeadsCampaignsTainted = {};
  export type SalesLeadsDripCampaignsTainted = {};
  export type SalesLeadsOpportunitiesTainted = {};
  export type SalesLeadsPromotionsTainted = {};
  export type SalesAccountsOverviewTainted = {};
  export type SalesAccountsActivitiesTainted = {};
  export type SalesAccountsBillingTainted = {};
  export type SalesAccountsContractsTainted = {};
  export type SalesOrdersOverviewTainted = {};
  export type SalesOrdersActivitiesTainted = {};
  export type SalesOrdersPaymentsTainted = {};
  export type SalesOrdersCommissionsTainted = {};
  export type SalesSchedulingScheduleTainted = {};
  export type SalesSchedulingAppointmentsTainted = {};
  export type SalesSchedulingRecurringTainted = {};
  export type SalesSchedulingRoutesTainted = {};
  export type SalesSchedulingRemindersTainted = {};
  export type UserHomeTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "SalesHomeDashboard" } & SalesHomeDashboardErrors)
    | ({ _value: "SalesHomeProducts" } & SalesHomeProductsErrors)
    | ({ _value: "SalesHomeServices" } & SalesHomeServicesErrors)
    | ({ _value: "SalesHomePackages" } & SalesHomePackagesErrors)
    | ({ _value: "SalesHomeTaxRates" } & SalesHomeTaxRatesErrors)
    | ({ _value: "SalesLeadsOverview" } & SalesLeadsOverviewErrors)
    | ({ _value: "SalesLeadsActivities" } & SalesLeadsActivitiesErrors)
    | ({ _value: "SalesLeadsCampaigns" } & SalesLeadsCampaignsErrors)
    | ({ _value: "SalesLeadsDripCampaigns" } & SalesLeadsDripCampaignsErrors)
    | ({ _value: "SalesLeadsOpportunities" } & SalesLeadsOpportunitiesErrors)
    | ({ _value: "SalesLeadsPromotions" } & SalesLeadsPromotionsErrors)
    | ({ _value: "SalesAccountsOverview" } & SalesAccountsOverviewErrors)
    | ({ _value: "SalesAccountsActivities" } & SalesAccountsActivitiesErrors)
    | ({ _value: "SalesAccountsBilling" } & SalesAccountsBillingErrors)
    | ({ _value: "SalesAccountsContracts" } & SalesAccountsContractsErrors)
    | ({ _value: "SalesOrdersOverview" } & SalesOrdersOverviewErrors)
    | ({ _value: "SalesOrdersActivities" } & SalesOrdersActivitiesErrors)
    | ({ _value: "SalesOrdersPayments" } & SalesOrdersPaymentsErrors)
    | ({ _value: "SalesOrdersCommissions" } & SalesOrdersCommissionsErrors)
    | ({ _value: "SalesSchedulingSchedule" } & SalesSchedulingScheduleErrors)
    | ({
        _value: "SalesSchedulingAppointments";
      } & SalesSchedulingAppointmentsErrors)
    | ({ _value: "SalesSchedulingRecurring" } & SalesSchedulingRecurringErrors)
    | ({ _value: "SalesSchedulingRoutes" } & SalesSchedulingRoutesErrors)
    | ({ _value: "SalesSchedulingReminders" } & SalesSchedulingRemindersErrors)
    | ({ _value: "UserHome" } & UserHomeErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "SalesHomeDashboard" } & SalesHomeDashboardTainted)
    | ({ _value: "SalesHomeProducts" } & SalesHomeProductsTainted)
    | ({ _value: "SalesHomeServices" } & SalesHomeServicesTainted)
    | ({ _value: "SalesHomePackages" } & SalesHomePackagesTainted)
    | ({ _value: "SalesHomeTaxRates" } & SalesHomeTaxRatesTainted)
    | ({ _value: "SalesLeadsOverview" } & SalesLeadsOverviewTainted)
    | ({ _value: "SalesLeadsActivities" } & SalesLeadsActivitiesTainted)
    | ({ _value: "SalesLeadsCampaigns" } & SalesLeadsCampaignsTainted)
    | ({ _value: "SalesLeadsDripCampaigns" } & SalesLeadsDripCampaignsTainted)
    | ({ _value: "SalesLeadsOpportunities" } & SalesLeadsOpportunitiesTainted)
    | ({ _value: "SalesLeadsPromotions" } & SalesLeadsPromotionsTainted)
    | ({ _value: "SalesAccountsOverview" } & SalesAccountsOverviewTainted)
    | ({ _value: "SalesAccountsActivities" } & SalesAccountsActivitiesTainted)
    | ({ _value: "SalesAccountsBilling" } & SalesAccountsBillingTainted)
    | ({ _value: "SalesAccountsContracts" } & SalesAccountsContractsTainted)
    | ({ _value: "SalesOrdersOverview" } & SalesOrdersOverviewTainted)
    | ({ _value: "SalesOrdersActivities" } & SalesOrdersActivitiesTainted)
    | ({ _value: "SalesOrdersPayments" } & SalesOrdersPaymentsTainted)
    | ({ _value: "SalesOrdersCommissions" } & SalesOrdersCommissionsTainted)
    | ({ _value: "SalesSchedulingSchedule" } & SalesSchedulingScheduleTainted)
    | ({
        _value: "SalesSchedulingAppointments";
      } & SalesSchedulingAppointmentsTainted)
    | ({ _value: "SalesSchedulingRecurring" } & SalesSchedulingRecurringTainted)
    | ({ _value: "SalesSchedulingRoutes" } & SalesSchedulingRoutesTainted)
    | ({ _value: "SalesSchedulingReminders" } & SalesSchedulingRemindersTainted)
    | ({ _value: "UserHome" } & UserHomeTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface SalesHomeDashboardFieldControllers {}
  export interface SalesHomeProductsFieldControllers {}
  export interface SalesHomeServicesFieldControllers {}
  export interface SalesHomePackagesFieldControllers {}
  export interface SalesHomeTaxRatesFieldControllers {}
  export interface SalesLeadsOverviewFieldControllers {}
  export interface SalesLeadsActivitiesFieldControllers {}
  export interface SalesLeadsCampaignsFieldControllers {}
  export interface SalesLeadsDripCampaignsFieldControllers {}
  export interface SalesLeadsOpportunitiesFieldControllers {}
  export interface SalesLeadsPromotionsFieldControllers {}
  export interface SalesAccountsOverviewFieldControllers {}
  export interface SalesAccountsActivitiesFieldControllers {}
  export interface SalesAccountsBillingFieldControllers {}
  export interface SalesAccountsContractsFieldControllers {}
  export interface SalesOrdersOverviewFieldControllers {}
  export interface SalesOrdersActivitiesFieldControllers {}
  export interface SalesOrdersPaymentsFieldControllers {}
  export interface SalesOrdersCommissionsFieldControllers {}
  export interface SalesSchedulingScheduleFieldControllers {}
  export interface SalesSchedulingAppointmentsFieldControllers {}
  export interface SalesSchedulingRecurringFieldControllers {}
  export interface SalesSchedulingRoutesFieldControllers {}
  export interface SalesSchedulingRemindersFieldControllers {}
  export interface UserHomeFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome";
    readonly data: Page;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "SalesHomeDashboard"
        | "SalesHomeProducts"
        | "SalesHomeServices"
        | "SalesHomePackages"
        | "SalesHomeTaxRates"
        | "SalesLeadsOverview"
        | "SalesLeadsActivities"
        | "SalesLeadsCampaigns"
        | "SalesLeadsDripCampaigns"
        | "SalesLeadsOpportunities"
        | "SalesLeadsPromotions"
        | "SalesAccountsOverview"
        | "SalesAccountsActivities"
        | "SalesAccountsBilling"
        | "SalesAccountsContracts"
        | "SalesOrdersOverview"
        | "SalesOrdersActivities"
        | "SalesOrdersPayments"
        | "SalesOrdersCommissions"
        | "SalesSchedulingSchedule"
        | "SalesSchedulingAppointments"
        | "SalesSchedulingRecurring"
        | "SalesSchedulingRoutes"
        | "SalesSchedulingReminders"
        | "UserHome",
    ): void;
    validate(): Result<Page, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Page>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly SalesHomeDashboard: {
      readonly fields: SalesHomeDashboardFieldControllers;
    };
    readonly SalesHomeProducts: {
      readonly fields: SalesHomeProductsFieldControllers;
    };
    readonly SalesHomeServices: {
      readonly fields: SalesHomeServicesFieldControllers;
    };
    readonly SalesHomePackages: {
      readonly fields: SalesHomePackagesFieldControllers;
    };
    readonly SalesHomeTaxRates: {
      readonly fields: SalesHomeTaxRatesFieldControllers;
    };
    readonly SalesLeadsOverview: {
      readonly fields: SalesLeadsOverviewFieldControllers;
    };
    readonly SalesLeadsActivities: {
      readonly fields: SalesLeadsActivitiesFieldControllers;
    };
    readonly SalesLeadsCampaigns: {
      readonly fields: SalesLeadsCampaignsFieldControllers;
    };
    readonly SalesLeadsDripCampaigns: {
      readonly fields: SalesLeadsDripCampaignsFieldControllers;
    };
    readonly SalesLeadsOpportunities: {
      readonly fields: SalesLeadsOpportunitiesFieldControllers;
    };
    readonly SalesLeadsPromotions: {
      readonly fields: SalesLeadsPromotionsFieldControllers;
    };
    readonly SalesAccountsOverview: {
      readonly fields: SalesAccountsOverviewFieldControllers;
    };
    readonly SalesAccountsActivities: {
      readonly fields: SalesAccountsActivitiesFieldControllers;
    };
    readonly SalesAccountsBilling: {
      readonly fields: SalesAccountsBillingFieldControllers;
    };
    readonly SalesAccountsContracts: {
      readonly fields: SalesAccountsContractsFieldControllers;
    };
    readonly SalesOrdersOverview: {
      readonly fields: SalesOrdersOverviewFieldControllers;
    };
    readonly SalesOrdersActivities: {
      readonly fields: SalesOrdersActivitiesFieldControllers;
    };
    readonly SalesOrdersPayments: {
      readonly fields: SalesOrdersPaymentsFieldControllers;
    };
    readonly SalesOrdersCommissions: {
      readonly fields: SalesOrdersCommissionsFieldControllers;
    };
    readonly SalesSchedulingSchedule: {
      readonly fields: SalesSchedulingScheduleFieldControllers;
    };
    readonly SalesSchedulingAppointments: {
      readonly fields: SalesSchedulingAppointmentsFieldControllers;
    };
    readonly SalesSchedulingRecurring: {
      readonly fields: SalesSchedulingRecurringFieldControllers;
    };
    readonly SalesSchedulingRoutes: {
      readonly fields: SalesSchedulingRoutesFieldControllers;
    };
    readonly SalesSchedulingReminders: {
      readonly fields: SalesSchedulingRemindersFieldControllers;
    };
    readonly UserHome: { readonly fields: UserHomeFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Page {
    switch (variant) {
      case "SalesHomeDashboard":
        return "SalesHomeDashboard" as Page;
      case "SalesHomeProducts":
        return "SalesHomeProducts" as Page;
      case "SalesHomeServices":
        return "SalesHomeServices" as Page;
      case "SalesHomePackages":
        return "SalesHomePackages" as Page;
      case "SalesHomeTaxRates":
        return "SalesHomeTaxRates" as Page;
      case "SalesLeadsOverview":
        return "SalesLeadsOverview" as Page;
      case "SalesLeadsActivities":
        return "SalesLeadsActivities" as Page;
      case "SalesLeadsCampaigns":
        return "SalesLeadsCampaigns" as Page;
      case "SalesLeadsDripCampaigns":
        return "SalesLeadsDripCampaigns" as Page;
      case "SalesLeadsOpportunities":
        return "SalesLeadsOpportunities" as Page;
      case "SalesLeadsPromotions":
        return "SalesLeadsPromotions" as Page;
      case "SalesAccountsOverview":
        return "SalesAccountsOverview" as Page;
      case "SalesAccountsActivities":
        return "SalesAccountsActivities" as Page;
      case "SalesAccountsBilling":
        return "SalesAccountsBilling" as Page;
      case "SalesAccountsContracts":
        return "SalesAccountsContracts" as Page;
      case "SalesOrdersOverview":
        return "SalesOrdersOverview" as Page;
      case "SalesOrdersActivities":
        return "SalesOrdersActivities" as Page;
      case "SalesOrdersPayments":
        return "SalesOrdersPayments" as Page;
      case "SalesOrdersCommissions":
        return "SalesOrdersCommissions" as Page;
      case "SalesSchedulingSchedule":
        return "SalesSchedulingSchedule" as Page;
      case "SalesSchedulingAppointments":
        return "SalesSchedulingAppointments" as Page;
      case "SalesSchedulingRecurring":
        return "SalesSchedulingRecurring" as Page;
      case "SalesSchedulingRoutes":
        return "SalesSchedulingRoutes" as Page;
      case "SalesSchedulingReminders":
        return "SalesSchedulingReminders" as Page;
      case "UserHome":
        return "UserHome" as Page;
      default:
        return "SalesHomeDashboard" as Page;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Page,
  ): Gigaform {
    const initialVariant:
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome" =
      (initial as
        | "SalesHomeDashboard"
        | "SalesHomeProducts"
        | "SalesHomeServices"
        | "SalesHomePackages"
        | "SalesHomeTaxRates"
        | "SalesLeadsOverview"
        | "SalesLeadsActivities"
        | "SalesLeadsCampaigns"
        | "SalesLeadsDripCampaigns"
        | "SalesLeadsOpportunities"
        | "SalesLeadsPromotions"
        | "SalesAccountsOverview"
        | "SalesAccountsActivities"
        | "SalesAccountsBilling"
        | "SalesAccountsContracts"
        | "SalesOrdersOverview"
        | "SalesOrdersActivities"
        | "SalesOrdersPayments"
        | "SalesOrdersCommissions"
        | "SalesSchedulingSchedule"
        | "SalesSchedulingAppointments"
        | "SalesSchedulingRecurring"
        | "SalesSchedulingRoutes"
        | "SalesSchedulingReminders"
        | "UserHome") ?? "SalesHomeDashboard";
    let currentVariant = $state<
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome"
    >(initialVariant);
    let data = $state<Page>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      SalesHomeDashboard: {
        fields: {} as SalesHomeDashboardFieldControllers,
      },
      SalesHomeProducts: {
        fields: {} as SalesHomeProductsFieldControllers,
      },
      SalesHomeServices: {
        fields: {} as SalesHomeServicesFieldControllers,
      },
      SalesHomePackages: {
        fields: {} as SalesHomePackagesFieldControllers,
      },
      SalesHomeTaxRates: {
        fields: {} as SalesHomeTaxRatesFieldControllers,
      },
      SalesLeadsOverview: {
        fields: {} as SalesLeadsOverviewFieldControllers,
      },
      SalesLeadsActivities: {
        fields: {} as SalesLeadsActivitiesFieldControllers,
      },
      SalesLeadsCampaigns: {
        fields: {} as SalesLeadsCampaignsFieldControllers,
      },
      SalesLeadsDripCampaigns: {
        fields: {} as SalesLeadsDripCampaignsFieldControllers,
      },
      SalesLeadsOpportunities: {
        fields: {} as SalesLeadsOpportunitiesFieldControllers,
      },
      SalesLeadsPromotions: {
        fields: {} as SalesLeadsPromotionsFieldControllers,
      },
      SalesAccountsOverview: {
        fields: {} as SalesAccountsOverviewFieldControllers,
      },
      SalesAccountsActivities: {
        fields: {} as SalesAccountsActivitiesFieldControllers,
      },
      SalesAccountsBilling: {
        fields: {} as SalesAccountsBillingFieldControllers,
      },
      SalesAccountsContracts: {
        fields: {} as SalesAccountsContractsFieldControllers,
      },
      SalesOrdersOverview: {
        fields: {} as SalesOrdersOverviewFieldControllers,
      },
      SalesOrdersActivities: {
        fields: {} as SalesOrdersActivitiesFieldControllers,
      },
      SalesOrdersPayments: {
        fields: {} as SalesOrdersPaymentsFieldControllers,
      },
      SalesOrdersCommissions: {
        fields: {} as SalesOrdersCommissionsFieldControllers,
      },
      SalesSchedulingSchedule: {
        fields: {} as SalesSchedulingScheduleFieldControllers,
      },
      SalesSchedulingAppointments: {
        fields: {} as SalesSchedulingAppointmentsFieldControllers,
      },
      SalesSchedulingRecurring: {
        fields: {} as SalesSchedulingRecurringFieldControllers,
      },
      SalesSchedulingRoutes: {
        fields: {} as SalesSchedulingRoutesFieldControllers,
      },
      SalesSchedulingReminders: {
        fields: {} as SalesSchedulingRemindersFieldControllers,
      },
      UserHome: {
        fields: {} as UserHomeFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "SalesHomeDashboard"
        | "SalesHomeProducts"
        | "SalesHomeServices"
        | "SalesHomePackages"
        | "SalesHomeTaxRates"
        | "SalesLeadsOverview"
        | "SalesLeadsActivities"
        | "SalesLeadsCampaigns"
        | "SalesLeadsDripCampaigns"
        | "SalesLeadsOpportunities"
        | "SalesLeadsPromotions"
        | "SalesAccountsOverview"
        | "SalesAccountsActivities"
        | "SalesAccountsBilling"
        | "SalesAccountsContracts"
        | "SalesOrdersOverview"
        | "SalesOrdersActivities"
        | "SalesOrdersPayments"
        | "SalesOrdersCommissions"
        | "SalesSchedulingSchedule"
        | "SalesSchedulingAppointments"
        | "SalesSchedulingRecurring"
        | "SalesSchedulingRoutes"
        | "SalesSchedulingReminders"
        | "UserHome",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Page,
      Array<{ field: string; message: string }>
    > {
      return Page.fromObject(data);
    }
    function reset(overrides?: Partial<Page>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Page, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "SalesHomeDashboard"
      | "SalesHomeProducts"
      | "SalesHomeServices"
      | "SalesHomePackages"
      | "SalesHomeTaxRates"
      | "SalesLeadsOverview"
      | "SalesLeadsActivities"
      | "SalesLeadsCampaigns"
      | "SalesLeadsDripCampaigns"
      | "SalesLeadsOpportunities"
      | "SalesLeadsPromotions"
      | "SalesAccountsOverview"
      | "SalesAccountsActivities"
      | "SalesAccountsBilling"
      | "SalesAccountsContracts"
      | "SalesOrdersOverview"
      | "SalesOrdersActivities"
      | "SalesOrdersPayments"
      | "SalesOrdersCommissions"
      | "SalesSchedulingSchedule"
      | "SalesSchedulingAppointments"
      | "SalesSchedulingRecurring"
      | "SalesSchedulingRoutes"
      | "SalesSchedulingReminders"
      | "UserHome"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "SalesHomeDashboard") {
    } else if (discriminant === "SalesHomeProducts") {
    } else if (discriminant === "SalesHomeServices") {
    } else if (discriminant === "SalesHomePackages") {
    } else if (discriminant === "SalesHomeTaxRates") {
    } else if (discriminant === "SalesLeadsOverview") {
    } else if (discriminant === "SalesLeadsActivities") {
    } else if (discriminant === "SalesLeadsCampaigns") {
    } else if (discriminant === "SalesLeadsDripCampaigns") {
    } else if (discriminant === "SalesLeadsOpportunities") {
    } else if (discriminant === "SalesLeadsPromotions") {
    } else if (discriminant === "SalesAccountsOverview") {
    } else if (discriminant === "SalesAccountsActivities") {
    } else if (discriminant === "SalesAccountsBilling") {
    } else if (discriminant === "SalesAccountsContracts") {
    } else if (discriminant === "SalesOrdersOverview") {
    } else if (discriminant === "SalesOrdersActivities") {
    } else if (discriminant === "SalesOrdersPayments") {
    } else if (discriminant === "SalesOrdersCommissions") {
    } else if (discriminant === "SalesSchedulingSchedule") {
    } else if (discriminant === "SalesSchedulingAppointments") {
    } else if (discriminant === "SalesSchedulingRecurring") {
    } else if (discriminant === "SalesSchedulingRoutes") {
    } else if (discriminant === "SalesSchedulingReminders") {
    } else if (discriminant === "UserHome") {
    }
    return Page.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type UserRole =
  | /** @default */ "Administrator"
  | "SalesRepresentative"
  | "Technician"
  | "HumanResources"
  | "InformationTechnology";

export namespace UserRole {
  export function defaultValue(): UserRole {
    return "Administrator";
  }
}

export namespace UserRole {
  export function toStringifiedJSON(value: UserRole): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: UserRole): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: UserRole, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace UserRole {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<UserRole, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<UserRole, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<UserRole>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): UserRole {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as UserRole;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "UserRole.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as UserRole;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof UserRole>(
    field: K,
    value: UserRole[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<UserRole>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace UserRole {
  /** Per-variant error types */ export type AdministratorErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesRepresentativeErrors = { _errors: Option<Array<string>> };
  export type TechnicianErrors = { _errors: Option<Array<string>> };
  export type HumanResourcesErrors = { _errors: Option<Array<string>> };
  export type InformationTechnologyErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type AdministratorTainted = {};
  export type SalesRepresentativeTainted = {};
  export type TechnicianTainted = {};
  export type HumanResourcesTainted = {};
  export type InformationTechnologyTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Administrator" } & AdministratorErrors)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeErrors)
    | ({ _value: "Technician" } & TechnicianErrors)
    | ({ _value: "HumanResources" } & HumanResourcesErrors)
    | ({ _value: "InformationTechnology" } & InformationTechnologyErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Administrator" } & AdministratorTainted)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeTainted)
    | ({ _value: "Technician" } & TechnicianTainted)
    | ({ _value: "HumanResources" } & HumanResourcesTainted)
    | ({ _value: "InformationTechnology" } & InformationTechnologyTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface AdministratorFieldControllers {}
  export interface SalesRepresentativeFieldControllers {}
  export interface TechnicianFieldControllers {}
  export interface HumanResourcesFieldControllers {}
  export interface InformationTechnologyFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology";
    readonly data: UserRole;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Administrator"
        | "SalesRepresentative"
        | "Technician"
        | "HumanResources"
        | "InformationTechnology",
    ): void;
    validate(): Result<UserRole, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<UserRole>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Administrator: { readonly fields: AdministratorFieldControllers };
    readonly SalesRepresentative: {
      readonly fields: SalesRepresentativeFieldControllers;
    };
    readonly Technician: { readonly fields: TechnicianFieldControllers };
    readonly HumanResources: {
      readonly fields: HumanResourcesFieldControllers;
    };
    readonly InformationTechnology: {
      readonly fields: InformationTechnologyFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): UserRole {
    switch (variant) {
      case "Administrator":
        return "Administrator" as UserRole;
      case "SalesRepresentative":
        return "SalesRepresentative" as UserRole;
      case "Technician":
        return "Technician" as UserRole;
      case "HumanResources":
        return "HumanResources" as UserRole;
      case "InformationTechnology":
        return "InformationTechnology" as UserRole;
      default:
        return "Administrator" as UserRole;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: UserRole,
  ): Gigaform {
    const initialVariant:
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology" =
      (initial as
        | "Administrator"
        | "SalesRepresentative"
        | "Technician"
        | "HumanResources"
        | "InformationTechnology") ?? "Administrator";
    let currentVariant = $state<
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology"
    >(initialVariant);
    let data = $state<UserRole>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Administrator: {
        fields: {} as AdministratorFieldControllers,
      },
      SalesRepresentative: {
        fields: {} as SalesRepresentativeFieldControllers,
      },
      Technician: {
        fields: {} as TechnicianFieldControllers,
      },
      HumanResources: {
        fields: {} as HumanResourcesFieldControllers,
      },
      InformationTechnology: {
        fields: {} as InformationTechnologyFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Administrator"
        | "SalesRepresentative"
        | "Technician"
        | "HumanResources"
        | "InformationTechnology",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      UserRole,
      Array<{ field: string; message: string }>
    > {
      return UserRole.fromObject(data);
    }
    function reset(overrides?: Partial<UserRole>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<UserRole, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Administrator"
      | "SalesRepresentative"
      | "Technician"
      | "HumanResources"
      | "InformationTechnology"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Administrator") {
    } else if (discriminant === "SalesRepresentative") {
    } else if (discriminant === "Technician") {
    } else if (discriminant === "HumanResources") {
    } else if (discriminant === "InformationTechnology") {
    }
    return UserRole.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Target =
  | /** @default */ Account
  | User
  | Employee
  | Appointment
  | Lead
  | TaxRate
  | Site
  | Route
  | Company
  | Product
  | Service
  | Order
  | Payment
  | Package
  | Promotion
  | Represents
  | Ordered;

export namespace Target {
  export function defaultValue(): Target {
    return Account.defaultValue();
  }
}

export namespace Target {
  export function toStringifiedJSON(value: Target): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Target): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Target, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Target {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Target, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Target, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Target>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Target {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Target;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Target.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Target;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Target>(
    field: K,
    value: Target[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Target>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Target {
  /** Per-variant error types */ export type AccountErrors = {
    _errors: Option<Array<string>>;
  };
  export type UserErrors = { _errors: Option<Array<string>> };
  export type EmployeeErrors = { _errors: Option<Array<string>> };
  export type AppointmentErrors = { _errors: Option<Array<string>> };
  export type LeadErrors = { _errors: Option<Array<string>> };
  export type TaxRateErrors = { _errors: Option<Array<string>> };
  export type SiteErrors = { _errors: Option<Array<string>> };
  export type RouteErrors = { _errors: Option<Array<string>> };
  export type CompanyErrors = { _errors: Option<Array<string>> };
  export type ProductErrors = { _errors: Option<Array<string>> };
  export type ServiceErrors = { _errors: Option<Array<string>> };
  export type OrderErrors = { _errors: Option<Array<string>> };
  export type PaymentErrors = { _errors: Option<Array<string>> };
  export type PackageErrors = { _errors: Option<Array<string>> };
  export type PromotionErrors = { _errors: Option<Array<string>> };
  export type RepresentsErrors = { _errors: Option<Array<string>> };
  export type OrderedErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type AccountTainted = {};
  export type UserTainted = {};
  export type EmployeeTainted = {};
  export type AppointmentTainted = {};
  export type LeadTainted = {};
  export type TaxRateTainted = {};
  export type SiteTainted = {};
  export type RouteTainted = {};
  export type CompanyTainted = {};
  export type ProductTainted = {};
  export type ServiceTainted = {};
  export type OrderTainted = {};
  export type PaymentTainted = {};
  export type PackageTainted = {};
  export type PromotionTainted = {};
  export type RepresentsTainted = {};
  export type OrderedTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "Account" } & AccountErrors)
    | ({ _type: "User" } & UserErrors)
    | ({ _type: "Employee" } & EmployeeErrors)
    | ({ _type: "Appointment" } & AppointmentErrors)
    | ({ _type: "Lead" } & LeadErrors)
    | ({ _type: "TaxRate" } & TaxRateErrors)
    | ({ _type: "Site" } & SiteErrors)
    | ({ _type: "Route" } & RouteErrors)
    | ({ _type: "Company" } & CompanyErrors)
    | ({ _type: "Product" } & ProductErrors)
    | ({ _type: "Service" } & ServiceErrors)
    | ({ _type: "Order" } & OrderErrors)
    | ({ _type: "Payment" } & PaymentErrors)
    | ({ _type: "Package" } & PackageErrors)
    | ({ _type: "Promotion" } & PromotionErrors)
    | ({ _type: "Represents" } & RepresentsErrors)
    | ({ _type: "Ordered" } & OrderedErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "Account" } & AccountTainted)
    | ({ _type: "User" } & UserTainted)
    | ({ _type: "Employee" } & EmployeeTainted)
    | ({ _type: "Appointment" } & AppointmentTainted)
    | ({ _type: "Lead" } & LeadTainted)
    | ({ _type: "TaxRate" } & TaxRateTainted)
    | ({ _type: "Site" } & SiteTainted)
    | ({ _type: "Route" } & RouteTainted)
    | ({ _type: "Company" } & CompanyTainted)
    | ({ _type: "Product" } & ProductTainted)
    | ({ _type: "Service" } & ServiceTainted)
    | ({ _type: "Order" } & OrderTainted)
    | ({ _type: "Payment" } & PaymentTainted)
    | ({ _type: "Package" } & PackageTainted)
    | ({ _type: "Promotion" } & PromotionTainted)
    | ({ _type: "Represents" } & RepresentsTainted)
    | ({ _type: "Ordered" } & OrderedTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface AccountFieldControllers {}
  export interface UserFieldControllers {}
  export interface EmployeeFieldControllers {}
  export interface AppointmentFieldControllers {}
  export interface LeadFieldControllers {}
  export interface TaxRateFieldControllers {}
  export interface SiteFieldControllers {}
  export interface RouteFieldControllers {}
  export interface CompanyFieldControllers {}
  export interface ProductFieldControllers {}
  export interface ServiceFieldControllers {}
  export interface OrderFieldControllers {}
  export interface PaymentFieldControllers {}
  export interface PackageFieldControllers {}
  export interface PromotionFieldControllers {}
  export interface RepresentsFieldControllers {}
  export interface OrderedFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered";
    readonly data: Target;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Account"
        | "User"
        | "Employee"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void;
    validate(): Result<Target, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Target>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Account: { readonly fields: AccountFieldControllers };
    readonly User: { readonly fields: UserFieldControllers };
    readonly Employee: { readonly fields: EmployeeFieldControllers };
    readonly Appointment: { readonly fields: AppointmentFieldControllers };
    readonly Lead: { readonly fields: LeadFieldControllers };
    readonly TaxRate: { readonly fields: TaxRateFieldControllers };
    readonly Site: { readonly fields: SiteFieldControllers };
    readonly Route: { readonly fields: RouteFieldControllers };
    readonly Company: { readonly fields: CompanyFieldControllers };
    readonly Product: { readonly fields: ProductFieldControllers };
    readonly Service: { readonly fields: ServiceFieldControllers };
    readonly Order: { readonly fields: OrderFieldControllers };
    readonly Payment: { readonly fields: PaymentFieldControllers };
    readonly Package: { readonly fields: PackageFieldControllers };
    readonly Promotion: { readonly fields: PromotionFieldControllers };
    readonly Represents: { readonly fields: RepresentsFieldControllers };
    readonly Ordered: { readonly fields: OrderedFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Target {
    switch (variant) {
      case "Account":
        return Account.defaultValue() as Target;
      case "User":
        return User.defaultValue() as Target;
      case "Employee":
        return Employee.defaultValue() as Target;
      case "Appointment":
        return Appointment.defaultValue() as Target;
      case "Lead":
        return Lead.defaultValue() as Target;
      case "TaxRate":
        return TaxRate.defaultValue() as Target;
      case "Site":
        return Site.defaultValue() as Target;
      case "Route":
        return Route.defaultValue() as Target;
      case "Company":
        return Company.defaultValue() as Target;
      case "Product":
        return Product.defaultValue() as Target;
      case "Service":
        return Service.defaultValue() as Target;
      case "Order":
        return Order.defaultValue() as Target;
      case "Payment":
        return Payment.defaultValue() as Target;
      case "Package":
        return Package.defaultValue() as Target;
      case "Promotion":
        return Promotion.defaultValue() as Target;
      case "Represents":
        return Represents.defaultValue() as Target;
      case "Ordered":
        return Ordered.defaultValue() as Target;
      default:
        return Account.defaultValue() as Target;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Target,
  ): Gigaform {
    const initialVariant:
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered" = "Account";
    let currentVariant = $state<
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
    >(initialVariant);
    let data = $state<Target>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Account: {
        fields: {} as AccountFieldControllers,
      },
      User: {
        fields: {} as UserFieldControllers,
      },
      Employee: {
        fields: {} as EmployeeFieldControllers,
      },
      Appointment: {
        fields: {} as AppointmentFieldControllers,
      },
      Lead: {
        fields: {} as LeadFieldControllers,
      },
      TaxRate: {
        fields: {} as TaxRateFieldControllers,
      },
      Site: {
        fields: {} as SiteFieldControllers,
      },
      Route: {
        fields: {} as RouteFieldControllers,
      },
      Company: {
        fields: {} as CompanyFieldControllers,
      },
      Product: {
        fields: {} as ProductFieldControllers,
      },
      Service: {
        fields: {} as ServiceFieldControllers,
      },
      Order: {
        fields: {} as OrderFieldControllers,
      },
      Payment: {
        fields: {} as PaymentFieldControllers,
      },
      Package: {
        fields: {} as PackageFieldControllers,
      },
      Promotion: {
        fields: {} as PromotionFieldControllers,
      },
      Represents: {
        fields: {} as RepresentsFieldControllers,
      },
      Ordered: {
        fields: {} as OrderedFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Account"
        | "User"
        | "Employee"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Target,
      Array<{ field: string; message: string }>
    > {
      return Target.fromObject(data);
    }
    function reset(overrides?: Partial<Target>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Target, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "Account"
      | "User"
      | "Employee"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "Account") {
    } else if (discriminant === "User") {
    } else if (discriminant === "Employee") {
    } else if (discriminant === "Appointment") {
    } else if (discriminant === "Lead") {
    } else if (discriminant === "TaxRate") {
    } else if (discriminant === "Site") {
    } else if (discriminant === "Route") {
    } else if (discriminant === "Company") {
    } else if (discriminant === "Product") {
    } else if (discriminant === "Service") {
    } else if (discriminant === "Order") {
    } else if (discriminant === "Payment") {
    } else if (discriminant === "Package") {
    } else if (discriminant === "Promotion") {
    } else if (discriminant === "Represents") {
    } else if (discriminant === "Ordered") {
    }
    return Target.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type RecurrenceEnd = number | string;

export namespace RecurrenceEnd {
  export function defaultValue(): RecurrenceEnd {
    return 0;
  }
}

export namespace RecurrenceEnd {
  export function toStringifiedJSON(value: RecurrenceEnd): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: RecurrenceEnd): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: RecurrenceEnd,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace RecurrenceEnd {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<RecurrenceEnd, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<RecurrenceEnd, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<RecurrenceEnd>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): RecurrenceEnd {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as RecurrenceEnd;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "RecurrenceEnd.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as RecurrenceEnd;
  }
<<<<<<< Updated upstream
}

export type OverviewDisplay = /** @default */ "Card" | "Table";

export namespace OverviewDisplay {
  export function defaultValue(): OverviewDisplay {
    return "Card";
  }
}

export namespace OverviewDisplay {
  export function toStringifiedJSON(value: OverviewDisplay): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: OverviewDisplay): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: OverviewDisplay,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
=======
  export function validateField<K extends keyof RecurrenceEnd>(
    field: K,
    value: RecurrenceEnd[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<RecurrenceEnd>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace RecurrenceEnd {
  /** Per-variant error types */ export type NumberErrors = {
    _errors: Option<Array<string>>;
  };
  export type StringErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type NumberTainted = {};
  export type StringTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "number" } & NumberErrors)
    | ({ _type: "string" } & StringErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "number" } & NumberTainted)
    | ({ _type: "string" } & StringTainted);
  /** Per-variant field controller types */ export interface NumberFieldControllers {}
  export interface StringFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "number" | "string";
    readonly data: RecurrenceEnd;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "number" | "string"): void;
    validate(): Result<
      RecurrenceEnd,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<RecurrenceEnd>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly number: { readonly fields: NumberFieldControllers };
    readonly string: { readonly fields: StringFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): RecurrenceEnd {
    switch (variant) {
      case "number":
        return 0 as RecurrenceEnd;
      case "string":
        return "" as RecurrenceEnd;
      default:
        return 0 as RecurrenceEnd;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: RecurrenceEnd,
  ): Gigaform {
    const initialVariant: "number" | "string" = "number";
    let currentVariant = $state<"number" | "string">(initialVariant);
    let data = $state<RecurrenceEnd>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      number: {
        fields: {} as NumberFieldControllers,
      },
      string: {
        fields: {} as StringFieldControllers,
      },
    };
    function switchVariant(variant: "number" | "string"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      RecurrenceEnd,
      Array<{ field: string; message: string }>
    > {
      return RecurrenceEnd.fromObject(data);
    }
    function reset(overrides?: Partial<RecurrenceEnd>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<RecurrenceEnd, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as "number" | "string" | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "number") {
    } else if (discriminant === "string") {
    }
    return RecurrenceEnd.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type OverviewDisplay = /** @default */ "Card" | "Table";

export namespace OverviewDisplay {
  export function defaultValue(): OverviewDisplay {
    return "Card";
>>>>>>> Stashed changes
  }
}

export namespace OverviewDisplay {
<<<<<<< Updated upstream
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(result);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): OverviewDisplay {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as OverviewDisplay;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "OverviewDisplay.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as OverviewDisplay;
=======
  export function toStringifiedJSON(value: OverviewDisplay): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: OverviewDisplay): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: OverviewDisplay,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
>>>>>>> Stashed changes
  }
}

export namespace OverviewDisplay {
<<<<<<< Updated upstream
  /** Per-variant error types */ export type CardErrors = {
    _errors: Option<Array<string>>;
  };
  export type TableErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CardTainted = {};
  export type TableTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Card" } & CardErrors)
    | ({ _value: "Table" } & TableErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Card" } & CardTainted)
    | ({ _value: "Table" } & TableTainted);
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Per-variant field controller types */ export interface CardFieldControllers {}
  export interface TableFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Card" | "Table";
    readonly data: OverviewDisplay;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Card" | "Table"): void;
    validate(): Result<
      OverviewDisplay,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<OverviewDisplay>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Card: { readonly fields: CardFieldControllers };
    readonly Table: { readonly fields: TableFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): OverviewDisplay {
    switch (variant) {
      case "Card":
        return "Card" as OverviewDisplay;
      case "Table":
        return "Table" as OverviewDisplay;
      default:
        return "Card" as OverviewDisplay;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: OverviewDisplay,
  ): Gigaform {
    const initialVariant: "Card" | "Table" =
      (initial as "Card" | "Table") ?? "Card";
    let currentVariant = $state<"Card" | "Table">(initialVariant);
    let data = $state<OverviewDisplay>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Card: {
        fields: {} as CardFieldControllers,
      },
      Table: {
        fields: {} as TableFieldControllers,
      },
    };
    function switchVariant(variant: "Card" | "Table"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      OverviewDisplay,
      Array<{ field: string; message: string }>
    > {
      return OverviewDisplay.fromObject(data);
    }
    function reset(overrides?: Partial<OverviewDisplay>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as "Card" | "Table" | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Card") {
    } else if (discriminant === "Table") {
    }
    return OverviewDisplay.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type IntervalUnit = /** @default */ "Day" | "Week" | "Month" | "Year";

export namespace IntervalUnit {
  export function defaultValue(): IntervalUnit {
    return "Day";
  }
}

export namespace IntervalUnit {
  export function toStringifiedJSON(value: IntervalUnit): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: IntervalUnit): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: IntervalUnit,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
=======
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok<OverviewDisplay>(result);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): OverviewDisplay {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as OverviewDisplay;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "OverviewDisplay.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as OverviewDisplay;
  }
  export function validateField<K extends keyof OverviewDisplay>(
    field: K,
    value: OverviewDisplay[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<OverviewDisplay>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace OverviewDisplay {
  /** Per-variant error types */ export type CardErrors = {
    _errors: Option<Array<string>>;
  };
  export type TableErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CardTainted = {};
  export type TableTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Card" } & CardErrors)
    | ({ _value: "Table" } & TableErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Card" } & CardTainted)
    | ({ _value: "Table" } & TableTainted);
  /** Per-variant field controller types */ export interface CardFieldControllers {}
  export interface TableFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Card" | "Table";
    readonly data: OverviewDisplay;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Card" | "Table"): void;
    validate(): Result<
      OverviewDisplay,
      Array<{ field: string; message: string }>
    >;
    reset(overrides?: Partial<OverviewDisplay>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Card: { readonly fields: CardFieldControllers };
    readonly Table: { readonly fields: TableFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): OverviewDisplay {
    switch (variant) {
      case "Card":
        return "Card" as OverviewDisplay;
      case "Table":
        return "Table" as OverviewDisplay;
      default:
        return "Card" as OverviewDisplay;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: OverviewDisplay,
  ): Gigaform {
    const initialVariant: "Card" | "Table" =
      (initial as "Card" | "Table") ?? "Card";
    let currentVariant = $state<"Card" | "Table">(initialVariant);
    let data = $state<OverviewDisplay>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Card: {
        fields: {} as CardFieldControllers,
      },
      Table: {
        fields: {} as TableFieldControllers,
      },
    };
    function switchVariant(variant: "Card" | "Table"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      OverviewDisplay,
      Array<{ field: string; message: string }>
    > {
      return OverviewDisplay.fromObject(data);
    }
    function reset(overrides?: Partial<OverviewDisplay>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<OverviewDisplay, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as "Card" | "Table" | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Card") {
    } else if (discriminant === "Table") {
    }
    return OverviewDisplay.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type IntervalUnit = /** @default */ "Day" | "Week" | "Month" | "Year";

export namespace IntervalUnit {
  export function defaultValue(): IntervalUnit {
    return "Day";
>>>>>>> Stashed changes
  }
}

export namespace IntervalUnit {
<<<<<<< Updated upstream
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<IntervalUnit, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<IntervalUnit, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(result);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): IntervalUnit {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as IntervalUnit;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "IntervalUnit.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as IntervalUnit;
=======
  export function toStringifiedJSON(value: IntervalUnit): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: IntervalUnit): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: IntervalUnit,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
>>>>>>> Stashed changes
  }
}

export namespace IntervalUnit {
<<<<<<< Updated upstream
  /** Per-variant error types */ export type DayErrors = {
    _errors: Option<Array<string>>;
  };
  export type WeekErrors = { _errors: Option<Array<string>> };
  export type MonthErrors = { _errors: Option<Array<string>> };
  export type YearErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type DayTainted = {};
  export type WeekTainted = {};
  export type MonthTainted = {};
  export type YearTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Day" } & DayErrors)
    | ({ _value: "Week" } & WeekErrors)
    | ({ _value: "Month" } & MonthErrors)
    | ({ _value: "Year" } & YearErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Day" } & DayTainted)
    | ({ _value: "Week" } & WeekTainted)
    | ({ _value: "Month" } & MonthTainted)
    | ({ _value: "Year" } & YearTainted);
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Per-variant field controller types */ export interface DayFieldControllers {}
  export interface WeekFieldControllers {}
  export interface MonthFieldControllers {}
  export interface YearFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Day" | "Week" | "Month" | "Year";
    readonly data: IntervalUnit;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void;
    validate(): Result<IntervalUnit, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<IntervalUnit>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Day: { readonly fields: DayFieldControllers };
    readonly Week: { readonly fields: WeekFieldControllers };
    readonly Month: { readonly fields: MonthFieldControllers };
    readonly Year: { readonly fields: YearFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): IntervalUnit {
    switch (variant) {
      case "Day":
        return "Day" as IntervalUnit;
      case "Week":
        return "Week" as IntervalUnit;
      case "Month":
        return "Month" as IntervalUnit;
      case "Year":
        return "Year" as IntervalUnit;
      default:
        return "Day" as IntervalUnit;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: IntervalUnit,
  ): Gigaform {
    const initialVariant: "Day" | "Week" | "Month" | "Year" =
      (initial as "Day" | "Week" | "Month" | "Year") ?? "Day";
    let currentVariant = $state<"Day" | "Week" | "Month" | "Year">(
      initialVariant,
    );
    let data = $state<IntervalUnit>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Day: {
        fields: {} as DayFieldControllers,
      },
      Week: {
        fields: {} as WeekFieldControllers,
      },
      Month: {
        fields: {} as MonthFieldControllers,
      },
      Year: {
        fields: {} as YearFieldControllers,
      },
    };
    function switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      IntervalUnit,
      Array<{ field: string; message: string }>
    > {
      return IntervalUnit.fromObject(data);
    }
    function reset(overrides?: Partial<IntervalUnit>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<IntervalUnit, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Day"
      | "Week"
      | "Month"
      | "Year"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Day") {
    } else if (discriminant === "Week") {
    } else if (discriminant === "Month") {
    } else if (discriminant === "Year") {
    }
    return IntervalUnit.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Sector = /** @default */ "Residential" | "Commercial";

export namespace Sector {
  export function defaultValue(): Sector {
    return "Residential";
  }
}

export namespace Sector {
  export function toStringifiedJSON(value: Sector): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Sector): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Sector, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
=======
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<IntervalUnit, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<IntervalUnit, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok<IntervalUnit>(result);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): IntervalUnit {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as IntervalUnit;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "IntervalUnit.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as IntervalUnit;
  }
  export function validateField<K extends keyof IntervalUnit>(
    field: K,
    value: IntervalUnit[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<IntervalUnit>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace IntervalUnit {
  /** Per-variant error types */ export type DayErrors = {
    _errors: Option<Array<string>>;
  };
  export type WeekErrors = { _errors: Option<Array<string>> };
  export type MonthErrors = { _errors: Option<Array<string>> };
  export type YearErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type DayTainted = {};
  export type WeekTainted = {};
  export type MonthTainted = {};
  export type YearTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Day" } & DayErrors)
    | ({ _value: "Week" } & WeekErrors)
    | ({ _value: "Month" } & MonthErrors)
    | ({ _value: "Year" } & YearErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Day" } & DayTainted)
    | ({ _value: "Week" } & WeekTainted)
    | ({ _value: "Month" } & MonthTainted)
    | ({ _value: "Year" } & YearTainted);
  /** Per-variant field controller types */ export interface DayFieldControllers {}
  export interface WeekFieldControllers {}
  export interface MonthFieldControllers {}
  export interface YearFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Day" | "Week" | "Month" | "Year";
    readonly data: IntervalUnit;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void;
    validate(): Result<IntervalUnit, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<IntervalUnit>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Day: { readonly fields: DayFieldControllers };
    readonly Week: { readonly fields: WeekFieldControllers };
    readonly Month: { readonly fields: MonthFieldControllers };
    readonly Year: { readonly fields: YearFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): IntervalUnit {
    switch (variant) {
      case "Day":
        return "Day" as IntervalUnit;
      case "Week":
        return "Week" as IntervalUnit;
      case "Month":
        return "Month" as IntervalUnit;
      case "Year":
        return "Year" as IntervalUnit;
      default:
        return "Day" as IntervalUnit;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: IntervalUnit,
  ): Gigaform {
    const initialVariant: "Day" | "Week" | "Month" | "Year" =
      (initial as "Day" | "Week" | "Month" | "Year") ?? "Day";
    let currentVariant = $state<"Day" | "Week" | "Month" | "Year">(
      initialVariant,
    );
    let data = $state<IntervalUnit>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Day: {
        fields: {} as DayFieldControllers,
      },
      Week: {
        fields: {} as WeekFieldControllers,
      },
      Month: {
        fields: {} as MonthFieldControllers,
      },
      Year: {
        fields: {} as YearFieldControllers,
      },
    };
    function switchVariant(variant: "Day" | "Week" | "Month" | "Year"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      IntervalUnit,
      Array<{ field: string; message: string }>
    > {
      return IntervalUnit.fromObject(data);
    }
    function reset(overrides?: Partial<IntervalUnit>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<IntervalUnit, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Day"
      | "Week"
      | "Month"
      | "Year"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Day") {
    } else if (discriminant === "Week") {
    } else if (discriminant === "Month") {
    } else if (discriminant === "Year") {
    }
    return IntervalUnit.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Sector = /** @default */ "Residential" | "Commercial";

export namespace Sector {
  export function defaultValue(): Sector {
    return "Residential";
>>>>>>> Stashed changes
  }
}

export namespace Sector {
<<<<<<< Updated upstream
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Sector, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Sector, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok(result);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Sector {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Sector;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Sector.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Sector;
=======
  export function toStringifiedJSON(value: Sector): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Sector): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Sector, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
>>>>>>> Stashed changes
  }
}

export namespace Sector {
<<<<<<< Updated upstream
=======
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Sector, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Sector, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok<Sector>(result);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Sector {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Sector;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Sector.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Sector;
  }
  export function validateField<K extends keyof Sector>(
    field: K,
    value: Sector[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Sector>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace Sector {
>>>>>>> Stashed changes
  /** Per-variant error types */ export type ResidentialErrors = {
    _errors: Option<Array<string>>;
  };
  export type CommercialErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type ResidentialTainted = {};
  export type CommercialTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Residential" } & ResidentialErrors)
    | ({ _value: "Commercial" } & CommercialErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Residential" } & ResidentialTainted)
    | ({ _value: "Commercial" } & CommercialTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface ResidentialFieldControllers {}
  export interface CommercialFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Residential" | "Commercial";
    readonly data: Sector;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Residential" | "Commercial"): void;
    validate(): Result<Sector, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Sector>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Residential: { readonly fields: ResidentialFieldControllers };
    readonly Commercial: { readonly fields: CommercialFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Sector {
    switch (variant) {
      case "Residential":
        return "Residential" as Sector;
      case "Commercial":
        return "Commercial" as Sector;
      default:
        return "Residential" as Sector;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Sector,
  ): Gigaform {
    const initialVariant: "Residential" | "Commercial" =
      (initial as "Residential" | "Commercial") ?? "Residential";
    let currentVariant = $state<"Residential" | "Commercial">(initialVariant);
    let data = $state<Sector>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Residential: {
        fields: {} as ResidentialFieldControllers,
      },
      Commercial: {
        fields: {} as CommercialFieldControllers,
      },
    };
    function switchVariant(variant: "Residential" | "Commercial"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Sector,
      Array<{ field: string; message: string }>
    > {
      return Sector.fromObject(data);
    }
    function reset(overrides?: Partial<Sector>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Sector, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Residential"
      | "Commercial"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Residential") {
    } else if (discriminant === "Commercial") {
    }
    return Sector.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Weekday =
  | /** @default */ "Monday"
  | "Tuesday"
  | "Wednesday"
  | "Thursday"
  | "Friday"
  | "Saturday"
  | "Sunday";

export namespace Weekday {
  export function defaultValue(): Weekday {
    return "Monday";
  }
}

export namespace Weekday {
  export function toStringifiedJSON(value: Weekday): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Weekday): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Weekday, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Weekday {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Weekday, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Weekday, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Weekday>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Weekday {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Weekday;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Weekday.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Weekday;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Weekday>(
    field: K,
    value: Weekday[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Weekday>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Weekday {
  /** Per-variant error types */ export type MondayErrors = {
    _errors: Option<Array<string>>;
  };
  export type TuesdayErrors = { _errors: Option<Array<string>> };
  export type WednesdayErrors = { _errors: Option<Array<string>> };
  export type ThursdayErrors = { _errors: Option<Array<string>> };
  export type FridayErrors = { _errors: Option<Array<string>> };
  export type SaturdayErrors = { _errors: Option<Array<string>> };
  export type SundayErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type MondayTainted = {};
  export type TuesdayTainted = {};
  export type WednesdayTainted = {};
  export type ThursdayTainted = {};
  export type FridayTainted = {};
  export type SaturdayTainted = {};
  export type SundayTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Monday" } & MondayErrors)
    | ({ _value: "Tuesday" } & TuesdayErrors)
    | ({ _value: "Wednesday" } & WednesdayErrors)
    | ({ _value: "Thursday" } & ThursdayErrors)
    | ({ _value: "Friday" } & FridayErrors)
    | ({ _value: "Saturday" } & SaturdayErrors)
    | ({ _value: "Sunday" } & SundayErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Monday" } & MondayTainted)
    | ({ _value: "Tuesday" } & TuesdayTainted)
    | ({ _value: "Wednesday" } & WednesdayTainted)
    | ({ _value: "Thursday" } & ThursdayTainted)
    | ({ _value: "Friday" } & FridayTainted)
    | ({ _value: "Saturday" } & SaturdayTainted)
    | ({ _value: "Sunday" } & SundayTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface MondayFieldControllers {}
  export interface TuesdayFieldControllers {}
  export interface WednesdayFieldControllers {}
  export interface ThursdayFieldControllers {}
  export interface FridayFieldControllers {}
  export interface SaturdayFieldControllers {}
  export interface SundayFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday";
    readonly data: Weekday;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Monday"
        | "Tuesday"
        | "Wednesday"
        | "Thursday"
        | "Friday"
        | "Saturday"
        | "Sunday",
    ): void;
    validate(): Result<Weekday, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Weekday>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Monday: { readonly fields: MondayFieldControllers };
    readonly Tuesday: { readonly fields: TuesdayFieldControllers };
    readonly Wednesday: { readonly fields: WednesdayFieldControllers };
    readonly Thursday: { readonly fields: ThursdayFieldControllers };
    readonly Friday: { readonly fields: FridayFieldControllers };
    readonly Saturday: { readonly fields: SaturdayFieldControllers };
    readonly Sunday: { readonly fields: SundayFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Weekday {
    switch (variant) {
      case "Monday":
        return "Monday" as Weekday;
      case "Tuesday":
        return "Tuesday" as Weekday;
      case "Wednesday":
        return "Wednesday" as Weekday;
      case "Thursday":
        return "Thursday" as Weekday;
      case "Friday":
        return "Friday" as Weekday;
      case "Saturday":
        return "Saturday" as Weekday;
      case "Sunday":
        return "Sunday" as Weekday;
      default:
        return "Monday" as Weekday;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Weekday,
  ): Gigaform {
    const initialVariant:
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday" =
      (initial as
        | "Monday"
        | "Tuesday"
        | "Wednesday"
        | "Thursday"
        | "Friday"
        | "Saturday"
        | "Sunday") ?? "Monday";
    let currentVariant = $state<
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday"
    >(initialVariant);
    let data = $state<Weekday>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Monday: {
        fields: {} as MondayFieldControllers,
      },
      Tuesday: {
        fields: {} as TuesdayFieldControllers,
      },
      Wednesday: {
        fields: {} as WednesdayFieldControllers,
      },
      Thursday: {
        fields: {} as ThursdayFieldControllers,
      },
      Friday: {
        fields: {} as FridayFieldControllers,
      },
      Saturday: {
        fields: {} as SaturdayFieldControllers,
      },
      Sunday: {
        fields: {} as SundayFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Monday"
        | "Tuesday"
        | "Wednesday"
        | "Thursday"
        | "Friday"
        | "Saturday"
        | "Sunday",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Weekday,
      Array<{ field: string; message: string }>
    > {
      return Weekday.fromObject(data);
    }
    function reset(overrides?: Partial<Weekday>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Weekday, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Monday"
      | "Tuesday"
      | "Wednesday"
      | "Thursday"
      | "Friday"
      | "Saturday"
      | "Sunday"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Monday") {
    } else if (discriminant === "Tuesday") {
    } else if (discriminant === "Wednesday") {
    } else if (discriminant === "Thursday") {
    } else if (discriminant === "Friday") {
    } else if (discriminant === "Saturday") {
    } else if (discriminant === "Sunday") {
    }
    return Weekday.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Status = /** @default */ "Scheduled" | "OnDeck" | "Waiting";

export namespace Status {
  export function defaultValue(): Status {
    return "Scheduled";
  }
}

export namespace Status {
  export function toStringifiedJSON(value: Status): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Status): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Status, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Status {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Status, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Status, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Status>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Status {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Status;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Status.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Status;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Status>(
    field: K,
    value: Status[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Status>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Status {
  /** Per-variant error types */ export type ScheduledErrors = {
    _errors: Option<Array<string>>;
  };
  export type OnDeckErrors = { _errors: Option<Array<string>> };
  export type WaitingErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type ScheduledTainted = {};
  export type OnDeckTainted = {};
  export type WaitingTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Scheduled" } & ScheduledErrors)
    | ({ _value: "OnDeck" } & OnDeckErrors)
    | ({ _value: "Waiting" } & WaitingErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Scheduled" } & ScheduledTainted)
    | ({ _value: "OnDeck" } & OnDeckTainted)
    | ({ _value: "Waiting" } & WaitingTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface ScheduledFieldControllers {}
  export interface OnDeckFieldControllers {}
  export interface WaitingFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Scheduled" | "OnDeck" | "Waiting";
    readonly data: Status;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void;
    validate(): Result<Status, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Status>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Scheduled: { readonly fields: ScheduledFieldControllers };
    readonly OnDeck: { readonly fields: OnDeckFieldControllers };
    readonly Waiting: { readonly fields: WaitingFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Status {
    switch (variant) {
      case "Scheduled":
        return "Scheduled" as Status;
      case "OnDeck":
        return "OnDeck" as Status;
      case "Waiting":
        return "Waiting" as Status;
      default:
        return "Scheduled" as Status;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Status,
  ): Gigaform {
    const initialVariant: "Scheduled" | "OnDeck" | "Waiting" =
      (initial as "Scheduled" | "OnDeck" | "Waiting") ?? "Scheduled";
    let currentVariant = $state<"Scheduled" | "OnDeck" | "Waiting">(
      initialVariant,
    );
    let data = $state<Status>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Scheduled: {
        fields: {} as ScheduledFieldControllers,
      },
      OnDeck: {
        fields: {} as OnDeckFieldControllers,
      },
      Waiting: {
        fields: {} as WaitingFieldControllers,
      },
    };
    function switchVariant(variant: "Scheduled" | "OnDeck" | "Waiting"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Status,
      Array<{ field: string; message: string }>
    > {
      return Status.fromObject(data);
    }
    function reset(overrides?: Partial<Status>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Status, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Scheduled"
      | "OnDeck"
      | "Waiting"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Scheduled") {
    } else if (discriminant === "OnDeck") {
    } else if (discriminant === "Waiting") {
    }
    return Status.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type NextStep = /** @default */
  | "InitialContact"
  | "Qualified"
  | "Estimate"
  | "Negotiation";

export namespace NextStep {
  export function defaultValue(): NextStep {
    return "InitialContact";
  }
}

export namespace NextStep {
  export function toStringifiedJSON(value: NextStep): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: NextStep): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: NextStep, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace NextStep {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<NextStep, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<NextStep, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<NextStep>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): NextStep {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as NextStep;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "NextStep.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as NextStep;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof NextStep>(
    field: K,
    value: NextStep[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<NextStep>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace NextStep {
  /** Per-variant error types */ export type InitialContactErrors = {
    _errors: Option<Array<string>>;
  };
  export type QualifiedErrors = { _errors: Option<Array<string>> };
  export type EstimateErrors = { _errors: Option<Array<string>> };
  export type NegotiationErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type InitialContactTainted = {};
  export type QualifiedTainted = {};
  export type EstimateTainted = {};
  export type NegotiationTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "InitialContact" } & InitialContactErrors)
    | ({ _value: "Qualified" } & QualifiedErrors)
    | ({ _value: "Estimate" } & EstimateErrors)
    | ({ _value: "Negotiation" } & NegotiationErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "InitialContact" } & InitialContactTainted)
    | ({ _value: "Qualified" } & QualifiedTainted)
    | ({ _value: "Estimate" } & EstimateTainted)
    | ({ _value: "Negotiation" } & NegotiationTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface InitialContactFieldControllers {}
  export interface QualifiedFieldControllers {}
  export interface EstimateFieldControllers {}
  export interface NegotiationFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation";
    readonly data: NextStep;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation",
    ): void;
    validate(): Result<NextStep, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<NextStep>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly InitialContact: {
      readonly fields: InitialContactFieldControllers;
    };
    readonly Qualified: { readonly fields: QualifiedFieldControllers };
    readonly Estimate: { readonly fields: EstimateFieldControllers };
    readonly Negotiation: { readonly fields: NegotiationFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): NextStep {
    switch (variant) {
      case "InitialContact":
        return "InitialContact" as NextStep;
      case "Qualified":
        return "Qualified" as NextStep;
      case "Estimate":
        return "Estimate" as NextStep;
      case "Negotiation":
        return "Negotiation" as NextStep;
      default:
        return "InitialContact" as NextStep;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: NextStep,
  ): Gigaform {
    const initialVariant:
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation" =
      (initial as
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation") ?? "InitialContact";
    let currentVariant = $state<
      "InitialContact" | "Qualified" | "Estimate" | "Negotiation"
    >(initialVariant);
    let data = $state<NextStep>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      InitialContact: {
        fields: {} as InitialContactFieldControllers,
      },
      Qualified: {
        fields: {} as QualifiedFieldControllers,
      },
      Estimate: {
        fields: {} as EstimateFieldControllers,
      },
      Negotiation: {
        fields: {} as NegotiationFieldControllers,
      },
    };
    function switchVariant(
      variant: "InitialContact" | "Qualified" | "Estimate" | "Negotiation",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      NextStep,
      Array<{ field: string; message: string }>
    > {
      return NextStep.fromObject(data);
    }
    function reset(overrides?: Partial<NextStep>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<NextStep, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "InitialContact") {
    } else if (discriminant === "Qualified") {
    } else if (discriminant === "Estimate") {
    } else if (discriminant === "Negotiation") {
    }
    return NextStep.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type LeadStage =
  | /** @default */ "Open"
  | "InitialContact"
  | "Qualified"
  | "Estimate"
  | "Negotiation";

export namespace LeadStage {
  export function defaultValue(): LeadStage {
    return "Open";
  }
}

export namespace LeadStage {
  export function toStringifiedJSON(value: LeadStage): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: LeadStage): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: LeadStage,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace LeadStage {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<LeadStage, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<LeadStage, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<LeadStage>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): LeadStage {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as LeadStage;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "LeadStage.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as LeadStage;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof LeadStage>(
    field: K,
    value: LeadStage[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<LeadStage>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace LeadStage {
  /** Per-variant error types */ export type OpenErrors = {
    _errors: Option<Array<string>>;
  };
  export type InitialContactErrors = { _errors: Option<Array<string>> };
  export type QualifiedErrors = { _errors: Option<Array<string>> };
  export type EstimateErrors = { _errors: Option<Array<string>> };
  export type NegotiationErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type OpenTainted = {};
  export type InitialContactTainted = {};
  export type QualifiedTainted = {};
  export type EstimateTainted = {};
  export type NegotiationTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Open" } & OpenErrors)
    | ({ _value: "InitialContact" } & InitialContactErrors)
    | ({ _value: "Qualified" } & QualifiedErrors)
    | ({ _value: "Estimate" } & EstimateErrors)
    | ({ _value: "Negotiation" } & NegotiationErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Open" } & OpenTainted)
    | ({ _value: "InitialContact" } & InitialContactTainted)
    | ({ _value: "Qualified" } & QualifiedTainted)
    | ({ _value: "Estimate" } & EstimateTainted)
    | ({ _value: "Negotiation" } & NegotiationTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface OpenFieldControllers {}
  export interface InitialContactFieldControllers {}
  export interface QualifiedFieldControllers {}
  export interface EstimateFieldControllers {}
  export interface NegotiationFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Open"
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation";
    readonly data: LeadStage;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Open"
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation",
    ): void;
    validate(): Result<LeadStage, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<LeadStage>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Open: { readonly fields: OpenFieldControllers };
    readonly InitialContact: {
      readonly fields: InitialContactFieldControllers;
    };
    readonly Qualified: { readonly fields: QualifiedFieldControllers };
    readonly Estimate: { readonly fields: EstimateFieldControllers };
    readonly Negotiation: { readonly fields: NegotiationFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): LeadStage {
    switch (variant) {
      case "Open":
        return "Open" as LeadStage;
      case "InitialContact":
        return "InitialContact" as LeadStage;
      case "Qualified":
        return "Qualified" as LeadStage;
      case "Estimate":
        return "Estimate" as LeadStage;
      case "Negotiation":
        return "Negotiation" as LeadStage;
      default:
        return "Open" as LeadStage;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: LeadStage,
  ): Gigaform {
    const initialVariant:
      | "Open"
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation" =
      (initial as
        | "Open"
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation") ?? "Open";
    let currentVariant = $state<
      "Open" | "InitialContact" | "Qualified" | "Estimate" | "Negotiation"
    >(initialVariant);
    let data = $state<LeadStage>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Open: {
        fields: {} as OpenFieldControllers,
      },
      InitialContact: {
        fields: {} as InitialContactFieldControllers,
      },
      Qualified: {
        fields: {} as QualifiedFieldControllers,
      },
      Estimate: {
        fields: {} as EstimateFieldControllers,
      },
      Negotiation: {
        fields: {} as NegotiationFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Open"
        | "InitialContact"
        | "Qualified"
        | "Estimate"
        | "Negotiation",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      LeadStage,
      Array<{ field: string; message: string }>
    > {
      return LeadStage.fromObject(data);
    }
    function reset(overrides?: Partial<LeadStage>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<LeadStage, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Open"
      | "InitialContact"
      | "Qualified"
      | "Estimate"
      | "Negotiation"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Open") {
    } else if (discriminant === "InitialContact") {
    } else if (discriminant === "Qualified") {
    } else if (discriminant === "Estimate") {
    } else if (discriminant === "Negotiation") {
    }
    return LeadStage.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type AccountName = /** @default */ CompanyName | PersonName;

export namespace AccountName {
  export function defaultValue(): AccountName {
    return CompanyName.defaultValue();
  }
}

export namespace AccountName {
  export function toStringifiedJSON(value: AccountName): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: AccountName): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: AccountName,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace AccountName {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<AccountName, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<AccountName, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<AccountName>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): AccountName {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as AccountName;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "AccountName.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as AccountName;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof AccountName>(
    field: K,
    value: AccountName[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<AccountName>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace AccountName {
  /** Per-variant error types */ export type CompanyNameErrors = {
    _errors: Option<Array<string>>;
  };
  export type PersonNameErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CompanyNameTainted = {};
  export type PersonNameTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "CompanyName" } & CompanyNameErrors)
    | ({ _type: "PersonName" } & PersonNameErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "CompanyName" } & CompanyNameTainted)
    | ({ _type: "PersonName" } & PersonNameTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface CompanyNameFieldControllers {}
  export interface PersonNameFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "CompanyName" | "PersonName";
    readonly data: AccountName;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "CompanyName" | "PersonName"): void;
    validate(): Result<AccountName, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<AccountName>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly CompanyName: { readonly fields: CompanyNameFieldControllers };
    readonly PersonName: { readonly fields: PersonNameFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): AccountName {
    switch (variant) {
      case "CompanyName":
        return CompanyName.defaultValue() as AccountName;
      case "PersonName":
        return PersonName.defaultValue() as AccountName;
      default:
        return CompanyName.defaultValue() as AccountName;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: AccountName,
  ): Gigaform {
    const initialVariant: "CompanyName" | "PersonName" = "CompanyName";
    let currentVariant = $state<"CompanyName" | "PersonName">(initialVariant);
    let data = $state<AccountName>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      CompanyName: {
        fields: {} as CompanyNameFieldControllers,
      },
      PersonName: {
        fields: {} as PersonNameFieldControllers,
      },
    };
    function switchVariant(variant: "CompanyName" | "PersonName"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      AccountName,
      Array<{ field: string; message: string }>
    > {
      return AccountName.fromObject(data);
    }
    function reset(overrides?: Partial<AccountName>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<AccountName, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "CompanyName"
      | "PersonName"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "CompanyName") {
    } else if (discriminant === "PersonName") {
    }
    return AccountName.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Priority = /** @default */ "Medium" | "High" | "Low";

export namespace Priority {
  export function defaultValue(): Priority {
    return "Medium";
  }
}

export namespace Priority {
  export function toStringifiedJSON(value: Priority): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Priority): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Priority, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Priority {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Priority, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Priority, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Priority>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Priority {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Priority;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Priority.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Priority;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Priority>(
    field: K,
    value: Priority[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Priority>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Priority {
  /** Per-variant error types */ export type MediumErrors = {
    _errors: Option<Array<string>>;
  };
  export type HighErrors = { _errors: Option<Array<string>> };
  export type LowErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type MediumTainted = {};
  export type HighTainted = {};
  export type LowTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Medium" } & MediumErrors)
    | ({ _value: "High" } & HighErrors)
    | ({ _value: "Low" } & LowErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Medium" } & MediumTainted)
    | ({ _value: "High" } & HighTainted)
    | ({ _value: "Low" } & LowTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface MediumFieldControllers {}
  export interface HighFieldControllers {}
  export interface LowFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Medium" | "High" | "Low";
    readonly data: Priority;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Medium" | "High" | "Low"): void;
    validate(): Result<Priority, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Priority>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Medium: { readonly fields: MediumFieldControllers };
    readonly High: { readonly fields: HighFieldControllers };
    readonly Low: { readonly fields: LowFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Priority {
    switch (variant) {
      case "Medium":
        return "Medium" as Priority;
      case "High":
        return "High" as Priority;
      case "Low":
        return "Low" as Priority;
      default:
        return "Medium" as Priority;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Priority,
  ): Gigaform {
    const initialVariant: "Medium" | "High" | "Low" =
      (initial as "Medium" | "High" | "Low") ?? "Medium";
    let currentVariant = $state<"Medium" | "High" | "Low">(initialVariant);
    let data = $state<Priority>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Medium: {
        fields: {} as MediumFieldControllers,
      },
      High: {
        fields: {} as HighFieldControllers,
      },
      Low: {
        fields: {} as LowFieldControllers,
      },
    };
    function switchVariant(variant: "Medium" | "High" | "Low"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Priority,
      Array<{ field: string; message: string }>
    > {
      return Priority.fromObject(data);
    }
    function reset(overrides?: Partial<Priority>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Priority, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Medium"
      | "High"
      | "Low"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Medium") {
    } else if (discriminant === "High") {
    } else if (discriminant === "Low") {
    }
    return Priority.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Applications =
  | /** @default */ "Sales"
  | "Accounting"
  | "Errand"
  | "HumanResources"
  | "Logistics"
  | "Marketing"
  | "Website";

export namespace Applications {
  export function defaultValue(): Applications {
    return "Sales";
  }
}

export namespace Applications {
  export function toStringifiedJSON(value: Applications): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Applications): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: Applications,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Applications {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Applications, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Applications, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Applications>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): Applications {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Applications;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Applications.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Applications;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Applications>(
    field: K,
    value: Applications[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Applications>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Applications {
  /** Per-variant error types */ export type SalesErrors = {
    _errors: Option<Array<string>>;
  };
  export type AccountingErrors = { _errors: Option<Array<string>> };
  export type ErrandErrors = { _errors: Option<Array<string>> };
  export type HumanResourcesErrors = { _errors: Option<Array<string>> };
  export type LogisticsErrors = { _errors: Option<Array<string>> };
  export type MarketingErrors = { _errors: Option<Array<string>> };
  export type WebsiteErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type SalesTainted = {};
  export type AccountingTainted = {};
  export type ErrandTainted = {};
  export type HumanResourcesTainted = {};
  export type LogisticsTainted = {};
  export type MarketingTainted = {};
  export type WebsiteTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Sales" } & SalesErrors)
    | ({ _value: "Accounting" } & AccountingErrors)
    | ({ _value: "Errand" } & ErrandErrors)
    | ({ _value: "HumanResources" } & HumanResourcesErrors)
    | ({ _value: "Logistics" } & LogisticsErrors)
    | ({ _value: "Marketing" } & MarketingErrors)
    | ({ _value: "Website" } & WebsiteErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Sales" } & SalesTainted)
    | ({ _value: "Accounting" } & AccountingTainted)
    | ({ _value: "Errand" } & ErrandTainted)
    | ({ _value: "HumanResources" } & HumanResourcesTainted)
    | ({ _value: "Logistics" } & LogisticsTainted)
    | ({ _value: "Marketing" } & MarketingTainted)
    | ({ _value: "Website" } & WebsiteTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface SalesFieldControllers {}
  export interface AccountingFieldControllers {}
  export interface ErrandFieldControllers {}
  export interface HumanResourcesFieldControllers {}
  export interface LogisticsFieldControllers {}
  export interface MarketingFieldControllers {}
  export interface WebsiteFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website";
    readonly data: Applications;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Sales"
        | "Accounting"
        | "Errand"
        | "HumanResources"
        | "Logistics"
        | "Marketing"
        | "Website",
    ): void;
    validate(): Result<Applications, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Applications>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Sales: { readonly fields: SalesFieldControllers };
    readonly Accounting: { readonly fields: AccountingFieldControllers };
    readonly Errand: { readonly fields: ErrandFieldControllers };
    readonly HumanResources: {
      readonly fields: HumanResourcesFieldControllers;
    };
    readonly Logistics: { readonly fields: LogisticsFieldControllers };
    readonly Marketing: { readonly fields: MarketingFieldControllers };
    readonly Website: { readonly fields: WebsiteFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Applications {
    switch (variant) {
      case "Sales":
        return "Sales" as Applications;
      case "Accounting":
        return "Accounting" as Applications;
      case "Errand":
        return "Errand" as Applications;
      case "HumanResources":
        return "HumanResources" as Applications;
      case "Logistics":
        return "Logistics" as Applications;
      case "Marketing":
        return "Marketing" as Applications;
      case "Website":
        return "Website" as Applications;
      default:
        return "Sales" as Applications;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Applications,
  ): Gigaform {
    const initialVariant:
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website" =
      (initial as
        | "Sales"
        | "Accounting"
        | "Errand"
        | "HumanResources"
        | "Logistics"
        | "Marketing"
        | "Website") ?? "Sales";
    let currentVariant = $state<
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website"
    >(initialVariant);
    let data = $state<Applications>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Sales: {
        fields: {} as SalesFieldControllers,
      },
      Accounting: {
        fields: {} as AccountingFieldControllers,
      },
      Errand: {
        fields: {} as ErrandFieldControllers,
      },
      HumanResources: {
        fields: {} as HumanResourcesFieldControllers,
      },
      Logistics: {
        fields: {} as LogisticsFieldControllers,
      },
      Marketing: {
        fields: {} as MarketingFieldControllers,
      },
      Website: {
        fields: {} as WebsiteFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Sales"
        | "Accounting"
        | "Errand"
        | "HumanResources"
        | "Logistics"
        | "Marketing"
        | "Website",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Applications,
      Array<{ field: string; message: string }>
    > {
      return Applications.fromObject(data);
    }
    function reset(overrides?: Partial<Applications>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Applications, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Sales"
      | "Accounting"
      | "Errand"
      | "HumanResources"
      | "Logistics"
      | "Marketing"
      | "Website"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Sales") {
    } else if (discriminant === "Accounting") {
    } else if (discriminant === "Errand") {
    } else if (discriminant === "HumanResources") {
    } else if (discriminant === "Logistics") {
    } else if (discriminant === "Marketing") {
    } else if (discriminant === "Website") {
    }
    return Applications.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type JobTitle =
  | /** @default */ "Technician"
  | "SalesRepresentative"
  | "HumanResources"
  | "InformationTechnology";

export namespace JobTitle {
  export function defaultValue(): JobTitle {
    return "Technician";
  }
}

export namespace JobTitle {
  export function toStringifiedJSON(value: JobTitle): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: JobTitle): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: JobTitle, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace JobTitle {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<JobTitle, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<JobTitle, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<JobTitle>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): JobTitle {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as JobTitle;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "JobTitle.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as JobTitle;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof JobTitle>(
    field: K,
    value: JobTitle[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<JobTitle>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace JobTitle {
  /** Per-variant error types */ export type TechnicianErrors = {
    _errors: Option<Array<string>>;
  };
  export type SalesRepresentativeErrors = { _errors: Option<Array<string>> };
  export type HumanResourcesErrors = { _errors: Option<Array<string>> };
  export type InformationTechnologyErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type TechnicianTainted = {};
  export type SalesRepresentativeTainted = {};
  export type HumanResourcesTainted = {};
  export type InformationTechnologyTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Technician" } & TechnicianErrors)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeErrors)
    | ({ _value: "HumanResources" } & HumanResourcesErrors)
    | ({ _value: "InformationTechnology" } & InformationTechnologyErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Technician" } & TechnicianTainted)
    | ({ _value: "SalesRepresentative" } & SalesRepresentativeTainted)
    | ({ _value: "HumanResources" } & HumanResourcesTainted)
    | ({ _value: "InformationTechnology" } & InformationTechnologyTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface TechnicianFieldControllers {}
  export interface SalesRepresentativeFieldControllers {}
  export interface HumanResourcesFieldControllers {}
  export interface InformationTechnologyFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology";
    readonly data: JobTitle;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Technician"
        | "SalesRepresentative"
        | "HumanResources"
        | "InformationTechnology",
    ): void;
    validate(): Result<JobTitle, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<JobTitle>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Technician: { readonly fields: TechnicianFieldControllers };
    readonly SalesRepresentative: {
      readonly fields: SalesRepresentativeFieldControllers;
    };
    readonly HumanResources: {
      readonly fields: HumanResourcesFieldControllers;
    };
    readonly InformationTechnology: {
      readonly fields: InformationTechnologyFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): JobTitle {
    switch (variant) {
      case "Technician":
        return "Technician" as JobTitle;
      case "SalesRepresentative":
        return "SalesRepresentative" as JobTitle;
      case "HumanResources":
        return "HumanResources" as JobTitle;
      case "InformationTechnology":
        return "InformationTechnology" as JobTitle;
      default:
        return "Technician" as JobTitle;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: JobTitle,
  ): Gigaform {
    const initialVariant:
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology" =
      (initial as
        | "Technician"
        | "SalesRepresentative"
        | "HumanResources"
        | "InformationTechnology") ?? "Technician";
    let currentVariant = $state<
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology"
    >(initialVariant);
    let data = $state<JobTitle>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Technician: {
        fields: {} as TechnicianFieldControllers,
      },
      SalesRepresentative: {
        fields: {} as SalesRepresentativeFieldControllers,
      },
      HumanResources: {
        fields: {} as HumanResourcesFieldControllers,
      },
      InformationTechnology: {
        fields: {} as InformationTechnologyFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Technician"
        | "SalesRepresentative"
        | "HumanResources"
        | "InformationTechnology",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      JobTitle,
      Array<{ field: string; message: string }>
    > {
      return JobTitle.fromObject(data);
    }
    function reset(overrides?: Partial<JobTitle>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<JobTitle, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Technician"
      | "SalesRepresentative"
      | "HumanResources"
      | "InformationTechnology"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Technician") {
    } else if (discriminant === "SalesRepresentative") {
    } else if (discriminant === "HumanResources") {
    } else if (discriminant === "InformationTechnology") {
    }
    return JobTitle.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type ColorsConfig =
  | Cardinal
  | Ordinal
  | Custom
  | /** @default */ Gradient;

export namespace ColorsConfig {
  export function defaultValue(): ColorsConfig {
    return Gradient.defaultValue();
  }
}

export namespace ColorsConfig {
  export function toStringifiedJSON(value: ColorsConfig): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: ColorsConfig): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: ColorsConfig,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace ColorsConfig {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<ColorsConfig, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<ColorsConfig, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<ColorsConfig>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): ColorsConfig {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as ColorsConfig;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "ColorsConfig.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as ColorsConfig;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof ColorsConfig>(
    field: K,
    value: ColorsConfig[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<ColorsConfig>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace ColorsConfig {
  /** Per-variant error types */ export type CardinalErrors = {
    _errors: Option<Array<string>>;
  };
  export type OrdinalErrors = { _errors: Option<Array<string>> };
  export type CustomErrors = { _errors: Option<Array<string>> };
  export type GradientErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CardinalTainted = {};
  export type OrdinalTainted = {};
  export type CustomTainted = {};
  export type GradientTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "Cardinal" } & CardinalErrors)
    | ({ _type: "Ordinal" } & OrdinalErrors)
    | ({ _type: "Custom" } & CustomErrors)
    | ({ _type: "Gradient" } & GradientErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "Cardinal" } & CardinalTainted)
    | ({ _type: "Ordinal" } & OrdinalTainted)
    | ({ _type: "Custom" } & CustomTainted)
    | ({ _type: "Gradient" } & GradientTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface CardinalFieldControllers {}
  export interface OrdinalFieldControllers {}
  export interface CustomFieldControllers {}
  export interface GradientFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient";
    readonly data: ColorsConfig;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient",
    ): void;
    validate(): Result<ColorsConfig, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<ColorsConfig>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Cardinal: { readonly fields: CardinalFieldControllers };
    readonly Ordinal: { readonly fields: OrdinalFieldControllers };
    readonly Custom: { readonly fields: CustomFieldControllers };
    readonly Gradient: { readonly fields: GradientFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): ColorsConfig {
    switch (variant) {
      case "Cardinal":
        return Cardinal.defaultValue() as ColorsConfig;
      case "Ordinal":
        return Ordinal.defaultValue() as ColorsConfig;
      case "Custom":
        return Custom.defaultValue() as ColorsConfig;
      case "Gradient":
        return Gradient.defaultValue() as ColorsConfig;
      default:
        return Cardinal.defaultValue() as ColorsConfig;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: ColorsConfig,
  ): Gigaform {
    const initialVariant: "Cardinal" | "Ordinal" | "Custom" | "Gradient" =
      "Cardinal";
    let currentVariant = $state<"Cardinal" | "Ordinal" | "Custom" | "Gradient">(
      initialVariant,
    );
    let data = $state<ColorsConfig>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Cardinal: {
        fields: {} as CardinalFieldControllers,
      },
      Ordinal: {
        fields: {} as OrdinalFieldControllers,
      },
      Custom: {
        fields: {} as CustomFieldControllers,
      },
      Gradient: {
        fields: {} as GradientFieldControllers,
      },
    };
    function switchVariant(
      variant: "Cardinal" | "Ordinal" | "Custom" | "Gradient",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      ColorsConfig,
      Array<{ field: string; message: string }>
    > {
      return ColorsConfig.fromObject(data);
    }
    function reset(overrides?: Partial<ColorsConfig>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<ColorsConfig, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "Cardinal"
      | "Ordinal"
      | "Custom"
      | "Gradient"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "Cardinal") {
    } else if (discriminant === "Ordinal") {
    } else if (discriminant === "Custom") {
    } else if (discriminant === "Gradient") {
    }
    return ColorsConfig.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type WeekOfMonth = /** @default */
  | "First"
  | "Second"
  | "Third"
  | "Fourth"
  | "Last";

export namespace WeekOfMonth {
  export function defaultValue(): WeekOfMonth {
    return "First";
  }
}

export namespace WeekOfMonth {
  export function toStringifiedJSON(value: WeekOfMonth): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: WeekOfMonth): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: WeekOfMonth,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace WeekOfMonth {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<WeekOfMonth, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<WeekOfMonth, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<WeekOfMonth>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): WeekOfMonth {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as WeekOfMonth;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "WeekOfMonth.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as WeekOfMonth;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof WeekOfMonth>(
    field: K,
    value: WeekOfMonth[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<WeekOfMonth>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace WeekOfMonth {
  /** Per-variant error types */ export type FirstErrors = {
    _errors: Option<Array<string>>;
  };
  export type SecondErrors = { _errors: Option<Array<string>> };
  export type ThirdErrors = { _errors: Option<Array<string>> };
  export type FourthErrors = { _errors: Option<Array<string>> };
  export type LastErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type FirstTainted = {};
  export type SecondTainted = {};
  export type ThirdTainted = {};
  export type FourthTainted = {};
  export type LastTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "First" } & FirstErrors)
    | ({ _value: "Second" } & SecondErrors)
    | ({ _value: "Third" } & ThirdErrors)
    | ({ _value: "Fourth" } & FourthErrors)
    | ({ _value: "Last" } & LastErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "First" } & FirstTainted)
    | ({ _value: "Second" } & SecondTainted)
    | ({ _value: "Third" } & ThirdTainted)
    | ({ _value: "Fourth" } & FourthTainted)
    | ({ _value: "Last" } & LastTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface FirstFieldControllers {}
  export interface SecondFieldControllers {}
  export interface ThirdFieldControllers {}
  export interface FourthFieldControllers {}
  export interface LastFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "First" | "Second" | "Third" | "Fourth" | "Last";
    readonly data: WeekOfMonth;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "First" | "Second" | "Third" | "Fourth" | "Last",
    ): void;
    validate(): Result<WeekOfMonth, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<WeekOfMonth>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly First: { readonly fields: FirstFieldControllers };
    readonly Second: { readonly fields: SecondFieldControllers };
    readonly Third: { readonly fields: ThirdFieldControllers };
    readonly Fourth: { readonly fields: FourthFieldControllers };
    readonly Last: { readonly fields: LastFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): WeekOfMonth {
    switch (variant) {
      case "First":
        return "First" as WeekOfMonth;
      case "Second":
        return "Second" as WeekOfMonth;
      case "Third":
        return "Third" as WeekOfMonth;
      case "Fourth":
        return "Fourth" as WeekOfMonth;
      case "Last":
        return "Last" as WeekOfMonth;
      default:
        return "First" as WeekOfMonth;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: WeekOfMonth,
  ): Gigaform {
    const initialVariant: "First" | "Second" | "Third" | "Fourth" | "Last" =
      (initial as "First" | "Second" | "Third" | "Fourth" | "Last") ?? "First";
    let currentVariant = $state<
      "First" | "Second" | "Third" | "Fourth" | "Last"
    >(initialVariant);
    let data = $state<WeekOfMonth>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      First: {
        fields: {} as FirstFieldControllers,
      },
      Second: {
        fields: {} as SecondFieldControllers,
      },
      Third: {
        fields: {} as ThirdFieldControllers,
      },
      Fourth: {
        fields: {} as FourthFieldControllers,
      },
      Last: {
        fields: {} as LastFieldControllers,
      },
    };
    function switchVariant(
      variant: "First" | "Second" | "Third" | "Fourth" | "Last",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      WeekOfMonth,
      Array<{ field: string; message: string }>
    > {
      return WeekOfMonth.fromObject(data);
    }
    function reset(overrides?: Partial<WeekOfMonth>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<WeekOfMonth, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "First"
      | "Second"
      | "Third"
      | "Fourth"
      | "Last"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "First") {
    } else if (discriminant === "Second") {
    } else if (discriminant === "Third") {
    } else if (discriminant === "Fourth") {
    } else if (discriminant === "Last") {
    }
    return WeekOfMonth.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type ActivityType = /** @default */
  | Created
  | Edited
  | Sent
  | Viewed
  | Commented
  | Paid;

export namespace ActivityType {
  export function defaultValue(): ActivityType {
    return Created.defaultValue();
  }
}

export namespace ActivityType {
  export function toStringifiedJSON(value: ActivityType): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: ActivityType): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: ActivityType,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace ActivityType {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<ActivityType, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<ActivityType, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<ActivityType>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): ActivityType {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as ActivityType;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "ActivityType.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as ActivityType;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof ActivityType>(
    field: K,
    value: ActivityType[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<ActivityType>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace ActivityType {
  /** Per-variant error types */ export type CreatedErrors = {
    _errors: Option<Array<string>>;
  };
  export type EditedErrors = { _errors: Option<Array<string>> };
  export type SentErrors = { _errors: Option<Array<string>> };
  export type ViewedErrors = { _errors: Option<Array<string>> };
  export type CommentedErrors = { _errors: Option<Array<string>> };
  export type PaidErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type CreatedTainted = {};
  export type EditedTainted = {};
  export type SentTainted = {};
  export type ViewedTainted = {};
  export type CommentedTainted = {};
  export type PaidTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "Created" } & CreatedErrors)
    | ({ _type: "Edited" } & EditedErrors)
    | ({ _type: "Sent" } & SentErrors)
    | ({ _type: "Viewed" } & ViewedErrors)
    | ({ _type: "Commented" } & CommentedErrors)
    | ({ _type: "Paid" } & PaidErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "Created" } & CreatedTainted)
    | ({ _type: "Edited" } & EditedTainted)
    | ({ _type: "Sent" } & SentTainted)
    | ({ _type: "Viewed" } & ViewedTainted)
    | ({ _type: "Commented" } & CommentedTainted)
    | ({ _type: "Paid" } & PaidTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface CreatedFieldControllers {}
  export interface EditedFieldControllers {}
  export interface SentFieldControllers {}
  export interface ViewedFieldControllers {}
  export interface CommentedFieldControllers {}
  export interface PaidFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Created"
      | "Edited"
      | "Sent"
      | "Viewed"
      | "Commented"
      | "Paid";
    readonly data: ActivityType;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid",
    ): void;
    validate(): Result<ActivityType, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<ActivityType>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Created: { readonly fields: CreatedFieldControllers };
    readonly Edited: { readonly fields: EditedFieldControllers };
    readonly Sent: { readonly fields: SentFieldControllers };
    readonly Viewed: { readonly fields: ViewedFieldControllers };
    readonly Commented: { readonly fields: CommentedFieldControllers };
    readonly Paid: { readonly fields: PaidFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): ActivityType {
    switch (variant) {
      case "Created":
        return Created.defaultValue() as ActivityType;
      case "Edited":
        return Edited.defaultValue() as ActivityType;
      case "Sent":
        return Sent.defaultValue() as ActivityType;
      case "Viewed":
        return Viewed.defaultValue() as ActivityType;
      case "Commented":
        return Commented.defaultValue() as ActivityType;
      case "Paid":
        return Paid.defaultValue() as ActivityType;
      default:
        return Created.defaultValue() as ActivityType;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: ActivityType,
  ): Gigaform {
    const initialVariant:
      | "Created"
      | "Edited"
      | "Sent"
      | "Viewed"
      | "Commented"
      | "Paid" = "Created";
    let currentVariant = $state<
      "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid"
    >(initialVariant);
    let data = $state<ActivityType>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Created: {
        fields: {} as CreatedFieldControllers,
      },
      Edited: {
        fields: {} as EditedFieldControllers,
      },
      Sent: {
        fields: {} as SentFieldControllers,
      },
      Viewed: {
        fields: {} as ViewedFieldControllers,
      },
      Commented: {
        fields: {} as CommentedFieldControllers,
      },
      Paid: {
        fields: {} as PaidFieldControllers,
      },
    };
    function switchVariant(
      variant: "Created" | "Edited" | "Sent" | "Viewed" | "Commented" | "Paid",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      ActivityType,
      Array<{ field: string; message: string }>
    > {
      return ActivityType.fromObject(data);
    }
    function reset(overrides?: Partial<ActivityType>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<ActivityType, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "Created"
      | "Edited"
      | "Sent"
      | "Viewed"
      | "Commented"
      | "Paid"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "Created") {
    } else if (discriminant === "Edited") {
    } else if (discriminant === "Sent") {
    } else if (discriminant === "Viewed") {
    } else if (discriminant === "Commented") {
    } else if (discriminant === "Paid") {
    }
    return ActivityType.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type RowHeight =
  | "ExtraSmall"
  | "Small"
  | /** @default */ "Medium"
  | "Large";

export namespace RowHeight {
  export function defaultValue(): RowHeight {
    return "Medium";
  }
}

export namespace RowHeight {
  export function toStringifiedJSON(value: RowHeight): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: RowHeight): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: RowHeight,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace RowHeight {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<RowHeight, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<RowHeight, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<RowHeight>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): RowHeight {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as RowHeight;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "RowHeight.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as RowHeight;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof RowHeight>(
    field: K,
    value: RowHeight[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<RowHeight>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace RowHeight {
  /** Per-variant error types */ export type ExtraSmallErrors = {
    _errors: Option<Array<string>>;
  };
  export type SmallErrors = { _errors: Option<Array<string>> };
  export type MediumErrors = { _errors: Option<Array<string>> };
  export type LargeErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type ExtraSmallTainted = {};
  export type SmallTainted = {};
  export type MediumTainted = {};
  export type LargeTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "ExtraSmall" } & ExtraSmallErrors)
    | ({ _value: "Small" } & SmallErrors)
    | ({ _value: "Medium" } & MediumErrors)
    | ({ _value: "Large" } & LargeErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "ExtraSmall" } & ExtraSmallTainted)
    | ({ _value: "Small" } & SmallTainted)
    | ({ _value: "Medium" } & MediumTainted)
    | ({ _value: "Large" } & LargeTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface ExtraSmallFieldControllers {}
  export interface SmallFieldControllers {}
  export interface MediumFieldControllers {}
  export interface LargeFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "ExtraSmall" | "Small" | "Medium" | "Large";
    readonly data: RowHeight;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "ExtraSmall" | "Small" | "Medium" | "Large"): void;
    validate(): Result<RowHeight, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<RowHeight>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly ExtraSmall: { readonly fields: ExtraSmallFieldControllers };
    readonly Small: { readonly fields: SmallFieldControllers };
    readonly Medium: { readonly fields: MediumFieldControllers };
    readonly Large: { readonly fields: LargeFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): RowHeight {
    switch (variant) {
      case "ExtraSmall":
        return "ExtraSmall" as RowHeight;
      case "Small":
        return "Small" as RowHeight;
      case "Medium":
        return "Medium" as RowHeight;
      case "Large":
        return "Large" as RowHeight;
      default:
        return "ExtraSmall" as RowHeight;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: RowHeight,
  ): Gigaform {
    const initialVariant: "ExtraSmall" | "Small" | "Medium" | "Large" =
      (initial as "ExtraSmall" | "Small" | "Medium" | "Large") ?? "ExtraSmall";
    let currentVariant = $state<"ExtraSmall" | "Small" | "Medium" | "Large">(
      initialVariant,
    );
    let data = $state<RowHeight>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      ExtraSmall: {
        fields: {} as ExtraSmallFieldControllers,
      },
      Small: {
        fields: {} as SmallFieldControllers,
      },
      Medium: {
        fields: {} as MediumFieldControllers,
      },
      Large: {
        fields: {} as LargeFieldControllers,
      },
    };
    function switchVariant(
      variant: "ExtraSmall" | "Small" | "Medium" | "Large",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      RowHeight,
      Array<{ field: string; message: string }>
    > {
      return RowHeight.fromObject(data);
    }
    function reset(overrides?: Partial<RowHeight>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<RowHeight, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "ExtraSmall"
      | "Small"
      | "Medium"
      | "Large"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "ExtraSmall") {
    } else if (discriminant === "Small") {
    } else if (discriminant === "Medium") {
    } else if (discriminant === "Large") {
    }
    return RowHeight.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type OrderStage = /** @default */ "Estimate" | "Active" | "Invoice";

export namespace OrderStage {
  export function defaultValue(): OrderStage {
    return "Estimate";
  }
}

export namespace OrderStage {
  export function toStringifiedJSON(value: OrderStage): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: OrderStage): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(
    value: OrderStage,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace OrderStage {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<OrderStage, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<OrderStage, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<OrderStage>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(
    value: any,
    ctx: DeserializeContext,
  ): OrderStage {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as OrderStage;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "OrderStage.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as OrderStage;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof OrderStage>(
    field: K,
    value: OrderStage[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<OrderStage>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace OrderStage {
  /** Per-variant error types */ export type EstimateErrors = {
    _errors: Option<Array<string>>;
  };
  export type ActiveErrors = { _errors: Option<Array<string>> };
  export type InvoiceErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type EstimateTainted = {};
  export type ActiveTainted = {};
  export type InvoiceTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Estimate" } & EstimateErrors)
    | ({ _value: "Active" } & ActiveErrors)
    | ({ _value: "Invoice" } & InvoiceErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Estimate" } & EstimateTainted)
    | ({ _value: "Active" } & ActiveTainted)
    | ({ _value: "Invoice" } & InvoiceTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface EstimateFieldControllers {}
  export interface ActiveFieldControllers {}
  export interface InvoiceFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "Estimate" | "Active" | "Invoice";
    readonly data: OrderStage;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "Estimate" | "Active" | "Invoice"): void;
    validate(): Result<OrderStage, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<OrderStage>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Estimate: { readonly fields: EstimateFieldControllers };
    readonly Active: { readonly fields: ActiveFieldControllers };
    readonly Invoice: { readonly fields: InvoiceFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): OrderStage {
    switch (variant) {
      case "Estimate":
        return "Estimate" as OrderStage;
      case "Active":
        return "Active" as OrderStage;
      case "Invoice":
        return "Invoice" as OrderStage;
      default:
        return "Estimate" as OrderStage;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: OrderStage,
  ): Gigaform {
    const initialVariant: "Estimate" | "Active" | "Invoice" =
      (initial as "Estimate" | "Active" | "Invoice") ?? "Estimate";
    let currentVariant = $state<"Estimate" | "Active" | "Invoice">(
      initialVariant,
    );
    let data = $state<OrderStage>(
      initial ?? getDefaultForVariant(initialVariant),
    );
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Estimate: {
        fields: {} as EstimateFieldControllers,
      },
      Active: {
        fields: {} as ActiveFieldControllers,
      },
      Invoice: {
        fields: {} as InvoiceFieldControllers,
      },
    };
    function switchVariant(variant: "Estimate" | "Active" | "Invoice"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      OrderStage,
      Array<{ field: string; message: string }>
    > {
      return OrderStage.fromObject(data);
    }
    function reset(overrides?: Partial<OrderStage>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<OrderStage, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Estimate"
      | "Active"
      | "Invoice"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Estimate") {
    } else if (discriminant === "Active") {
    } else if (discriminant === "Invoice") {
    }
    return OrderStage.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Table =
  | /** @default */ "Account"
  | "Did"
  | "Appointment"
  | "Lead"
  | "TaxRate"
  | "Site"
  | "Employee"
  | "Route"
  | "Company"
  | "Product"
  | "Service"
  | "User"
  | "Order"
  | "Payment"
  | "Package"
  | "Promotion"
  | "Represents"
  | "Ordered";

export namespace Table {
  export function defaultValue(): Table {
    return "Account";
  }
}

export namespace Table {
  export function toStringifiedJSON(value: Table): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Table): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Table, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Table {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Table, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Table, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Table>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Table {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Table;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Table.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Table;
  }
<<<<<<< Updated upstream
}

export namespace Table {
  /** Per-variant error types */ export type AccountErrors = {
    _errors: Option<Array<string>>;
  };
  export type DidErrors = { _errors: Option<Array<string>> };
  export type AppointmentErrors = { _errors: Option<Array<string>> };
  export type LeadErrors = { _errors: Option<Array<string>> };
  export type TaxRateErrors = { _errors: Option<Array<string>> };
  export type SiteErrors = { _errors: Option<Array<string>> };
  export type EmployeeErrors = { _errors: Option<Array<string>> };
  export type RouteErrors = { _errors: Option<Array<string>> };
  export type CompanyErrors = { _errors: Option<Array<string>> };
  export type ProductErrors = { _errors: Option<Array<string>> };
  export type ServiceErrors = { _errors: Option<Array<string>> };
  export type UserErrors = { _errors: Option<Array<string>> };
  export type OrderErrors = { _errors: Option<Array<string>> };
  export type PaymentErrors = { _errors: Option<Array<string>> };
  export type PackageErrors = { _errors: Option<Array<string>> };
  export type PromotionErrors = { _errors: Option<Array<string>> };
  export type RepresentsErrors = { _errors: Option<Array<string>> };
  export type OrderedErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type AccountTainted = {};
  export type DidTainted = {};
  export type AppointmentTainted = {};
  export type LeadTainted = {};
  export type TaxRateTainted = {};
  export type SiteTainted = {};
  export type EmployeeTainted = {};
  export type RouteTainted = {};
  export type CompanyTainted = {};
  export type ProductTainted = {};
  export type ServiceTainted = {};
  export type UserTainted = {};
  export type OrderTainted = {};
  export type PaymentTainted = {};
  export type PackageTainted = {};
  export type PromotionTainted = {};
  export type RepresentsTainted = {};
  export type OrderedTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Account" } & AccountErrors)
    | ({ _value: "Did" } & DidErrors)
    | ({ _value: "Appointment" } & AppointmentErrors)
    | ({ _value: "Lead" } & LeadErrors)
    | ({ _value: "TaxRate" } & TaxRateErrors)
    | ({ _value: "Site" } & SiteErrors)
    | ({ _value: "Employee" } & EmployeeErrors)
    | ({ _value: "Route" } & RouteErrors)
    | ({ _value: "Company" } & CompanyErrors)
    | ({ _value: "Product" } & ProductErrors)
    | ({ _value: "Service" } & ServiceErrors)
    | ({ _value: "User" } & UserErrors)
    | ({ _value: "Order" } & OrderErrors)
    | ({ _value: "Payment" } & PaymentErrors)
    | ({ _value: "Package" } & PackageErrors)
    | ({ _value: "Promotion" } & PromotionErrors)
    | ({ _value: "Represents" } & RepresentsErrors)
    | ({ _value: "Ordered" } & OrderedErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Account" } & AccountTainted)
    | ({ _value: "Did" } & DidTainted)
    | ({ _value: "Appointment" } & AppointmentTainted)
    | ({ _value: "Lead" } & LeadTainted)
    | ({ _value: "TaxRate" } & TaxRateTainted)
    | ({ _value: "Site" } & SiteTainted)
    | ({ _value: "Employee" } & EmployeeTainted)
    | ({ _value: "Route" } & RouteTainted)
    | ({ _value: "Company" } & CompanyTainted)
    | ({ _value: "Product" } & ProductTainted)
    | ({ _value: "Service" } & ServiceTainted)
    | ({ _value: "User" } & UserTainted)
    | ({ _value: "Order" } & OrderTainted)
    | ({ _value: "Payment" } & PaymentTainted)
    | ({ _value: "Package" } & PackageTainted)
    | ({ _value: "Promotion" } & PromotionTainted)
    | ({ _value: "Represents" } & RepresentsTainted)
    | ({ _value: "Ordered" } & OrderedTainted);
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
  /** Per-variant field controller types */ export interface AccountFieldControllers {}
  export interface DidFieldControllers {}
  export interface AppointmentFieldControllers {}
  export interface LeadFieldControllers {}
  export interface TaxRateFieldControllers {}
  export interface SiteFieldControllers {}
  export interface EmployeeFieldControllers {}
  export interface RouteFieldControllers {}
  export interface CompanyFieldControllers {}
  export interface ProductFieldControllers {}
  export interface ServiceFieldControllers {}
  export interface UserFieldControllers {}
  export interface OrderFieldControllers {}
  export interface PaymentFieldControllers {}
  export interface PackageFieldControllers {}
  export interface PromotionFieldControllers {}
  export interface RepresentsFieldControllers {}
  export interface OrderedFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered";
    readonly data: Table;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void;
    validate(): Result<Table, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Table>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Account: { readonly fields: AccountFieldControllers };
    readonly Did: { readonly fields: DidFieldControllers };
    readonly Appointment: { readonly fields: AppointmentFieldControllers };
    readonly Lead: { readonly fields: LeadFieldControllers };
    readonly TaxRate: { readonly fields: TaxRateFieldControllers };
    readonly Site: { readonly fields: SiteFieldControllers };
    readonly Employee: { readonly fields: EmployeeFieldControllers };
    readonly Route: { readonly fields: RouteFieldControllers };
    readonly Company: { readonly fields: CompanyFieldControllers };
    readonly Product: { readonly fields: ProductFieldControllers };
    readonly Service: { readonly fields: ServiceFieldControllers };
    readonly User: { readonly fields: UserFieldControllers };
    readonly Order: { readonly fields: OrderFieldControllers };
    readonly Payment: { readonly fields: PaymentFieldControllers };
    readonly Package: { readonly fields: PackageFieldControllers };
    readonly Promotion: { readonly fields: PromotionFieldControllers };
    readonly Represents: { readonly fields: RepresentsFieldControllers };
    readonly Ordered: { readonly fields: OrderedFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Table {
    switch (variant) {
      case "Account":
        return "Account" as Table;
      case "Did":
        return "Did" as Table;
      case "Appointment":
        return "Appointment" as Table;
      case "Lead":
        return "Lead" as Table;
      case "TaxRate":
        return "TaxRate" as Table;
      case "Site":
        return "Site" as Table;
      case "Employee":
        return "Employee" as Table;
      case "Route":
        return "Route" as Table;
      case "Company":
        return "Company" as Table;
      case "Product":
        return "Product" as Table;
      case "Service":
        return "Service" as Table;
      case "User":
        return "User" as Table;
      case "Order":
        return "Order" as Table;
      case "Payment":
        return "Payment" as Table;
      case "Package":
        return "Package" as Table;
      case "Promotion":
        return "Promotion" as Table;
      case "Represents":
        return "Represents" as Table;
      case "Ordered":
        return "Ordered" as Table;
      default:
        return "Account" as Table;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Table,
  ): Gigaform {
    const initialVariant:
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered" =
      (initial as
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered") ?? "Account";
    let currentVariant = $state<
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
    >(initialVariant);
    let data = $state<Table>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Account: {
        fields: {} as AccountFieldControllers,
      },
      Did: {
        fields: {} as DidFieldControllers,
      },
      Appointment: {
        fields: {} as AppointmentFieldControllers,
      },
      Lead: {
        fields: {} as LeadFieldControllers,
      },
      TaxRate: {
        fields: {} as TaxRateFieldControllers,
      },
      Site: {
        fields: {} as SiteFieldControllers,
      },
      Employee: {
        fields: {} as EmployeeFieldControllers,
      },
      Route: {
        fields: {} as RouteFieldControllers,
      },
      Company: {
        fields: {} as CompanyFieldControllers,
      },
      Product: {
        fields: {} as ProductFieldControllers,
      },
      Service: {
        fields: {} as ServiceFieldControllers,
      },
      User: {
        fields: {} as UserFieldControllers,
      },
      Order: {
        fields: {} as OrderFieldControllers,
      },
      Payment: {
        fields: {} as PaymentFieldControllers,
      },
      Package: {
        fields: {} as PackageFieldControllers,
      },
      Promotion: {
        fields: {} as PromotionFieldControllers,
      },
      Represents: {
        fields: {} as RepresentsFieldControllers,
      },
      Ordered: {
        fields: {} as OrderedFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Table,
      Array<{ field: string; message: string }>
    > {
      return Table.fromObject(data);
    }
    function reset(overrides?: Partial<Table>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Table, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Account") {
    } else if (discriminant === "Did") {
    } else if (discriminant === "Appointment") {
    } else if (discriminant === "Lead") {
    } else if (discriminant === "TaxRate") {
    } else if (discriminant === "Site") {
    } else if (discriminant === "Employee") {
    } else if (discriminant === "Route") {
    } else if (discriminant === "Company") {
    } else if (discriminant === "Product") {
    } else if (discriminant === "Service") {
    } else if (discriminant === "User") {
    } else if (discriminant === "Order") {
    } else if (discriminant === "Payment") {
    } else if (discriminant === "Package") {
    } else if (discriminant === "Promotion") {
    } else if (discriminant === "Represents") {
    } else if (discriminant === "Ordered") {
    }
    return Table.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type Item = (string | Product) | (string | Service);
=======
  export function validateField<K extends keyof Table>(
    field: K,
    value: Table[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Table>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace Table {
  /** Per-variant error types */ export type AccountErrors = {
    _errors: Option<Array<string>>;
  };
  export type DidErrors = { _errors: Option<Array<string>> };
  export type AppointmentErrors = { _errors: Option<Array<string>> };
  export type LeadErrors = { _errors: Option<Array<string>> };
  export type TaxRateErrors = { _errors: Option<Array<string>> };
  export type SiteErrors = { _errors: Option<Array<string>> };
  export type EmployeeErrors = { _errors: Option<Array<string>> };
  export type RouteErrors = { _errors: Option<Array<string>> };
  export type CompanyErrors = { _errors: Option<Array<string>> };
  export type ProductErrors = { _errors: Option<Array<string>> };
  export type ServiceErrors = { _errors: Option<Array<string>> };
  export type UserErrors = { _errors: Option<Array<string>> };
  export type OrderErrors = { _errors: Option<Array<string>> };
  export type PaymentErrors = { _errors: Option<Array<string>> };
  export type PackageErrors = { _errors: Option<Array<string>> };
  export type PromotionErrors = { _errors: Option<Array<string>> };
  export type RepresentsErrors = { _errors: Option<Array<string>> };
  export type OrderedErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type AccountTainted = {};
  export type DidTainted = {};
  export type AppointmentTainted = {};
  export type LeadTainted = {};
  export type TaxRateTainted = {};
  export type SiteTainted = {};
  export type EmployeeTainted = {};
  export type RouteTainted = {};
  export type CompanyTainted = {};
  export type ProductTainted = {};
  export type ServiceTainted = {};
  export type UserTainted = {};
  export type OrderTainted = {};
  export type PaymentTainted = {};
  export type PackageTainted = {};
  export type PromotionTainted = {};
  export type RepresentsTainted = {};
  export type OrderedTainted = {};
  /** Union error type */ export type Errors =
    | ({ _value: "Account" } & AccountErrors)
    | ({ _value: "Did" } & DidErrors)
    | ({ _value: "Appointment" } & AppointmentErrors)
    | ({ _value: "Lead" } & LeadErrors)
    | ({ _value: "TaxRate" } & TaxRateErrors)
    | ({ _value: "Site" } & SiteErrors)
    | ({ _value: "Employee" } & EmployeeErrors)
    | ({ _value: "Route" } & RouteErrors)
    | ({ _value: "Company" } & CompanyErrors)
    | ({ _value: "Product" } & ProductErrors)
    | ({ _value: "Service" } & ServiceErrors)
    | ({ _value: "User" } & UserErrors)
    | ({ _value: "Order" } & OrderErrors)
    | ({ _value: "Payment" } & PaymentErrors)
    | ({ _value: "Package" } & PackageErrors)
    | ({ _value: "Promotion" } & PromotionErrors)
    | ({ _value: "Represents" } & RepresentsErrors)
    | ({ _value: "Ordered" } & OrderedErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _value: "Account" } & AccountTainted)
    | ({ _value: "Did" } & DidTainted)
    | ({ _value: "Appointment" } & AppointmentTainted)
    | ({ _value: "Lead" } & LeadTainted)
    | ({ _value: "TaxRate" } & TaxRateTainted)
    | ({ _value: "Site" } & SiteTainted)
    | ({ _value: "Employee" } & EmployeeTainted)
    | ({ _value: "Route" } & RouteTainted)
    | ({ _value: "Company" } & CompanyTainted)
    | ({ _value: "Product" } & ProductTainted)
    | ({ _value: "Service" } & ServiceTainted)
    | ({ _value: "User" } & UserTainted)
    | ({ _value: "Order" } & OrderTainted)
    | ({ _value: "Payment" } & PaymentTainted)
    | ({ _value: "Package" } & PackageTainted)
    | ({ _value: "Promotion" } & PromotionTainted)
    | ({ _value: "Represents" } & RepresentsTainted)
    | ({ _value: "Ordered" } & OrderedTainted);
  /** Per-variant field controller types */ export interface AccountFieldControllers {}
  export interface DidFieldControllers {}
  export interface AppointmentFieldControllers {}
  export interface LeadFieldControllers {}
  export interface TaxRateFieldControllers {}
  export interface SiteFieldControllers {}
  export interface EmployeeFieldControllers {}
  export interface RouteFieldControllers {}
  export interface CompanyFieldControllers {}
  export interface ProductFieldControllers {}
  export interface ServiceFieldControllers {}
  export interface UserFieldControllers {}
  export interface OrderFieldControllers {}
  export interface PaymentFieldControllers {}
  export interface PackageFieldControllers {}
  export interface PromotionFieldControllers {}
  export interface RepresentsFieldControllers {}
  export interface OrderedFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant:
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered";
    readonly data: Table;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(
      variant:
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void;
    validate(): Result<Table, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Table>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly Account: { readonly fields: AccountFieldControllers };
    readonly Did: { readonly fields: DidFieldControllers };
    readonly Appointment: { readonly fields: AppointmentFieldControllers };
    readonly Lead: { readonly fields: LeadFieldControllers };
    readonly TaxRate: { readonly fields: TaxRateFieldControllers };
    readonly Site: { readonly fields: SiteFieldControllers };
    readonly Employee: { readonly fields: EmployeeFieldControllers };
    readonly Route: { readonly fields: RouteFieldControllers };
    readonly Company: { readonly fields: CompanyFieldControllers };
    readonly Product: { readonly fields: ProductFieldControllers };
    readonly Service: { readonly fields: ServiceFieldControllers };
    readonly User: { readonly fields: UserFieldControllers };
    readonly Order: { readonly fields: OrderFieldControllers };
    readonly Payment: { readonly fields: PaymentFieldControllers };
    readonly Package: { readonly fields: PackageFieldControllers };
    readonly Promotion: { readonly fields: PromotionFieldControllers };
    readonly Represents: { readonly fields: RepresentsFieldControllers };
    readonly Ordered: { readonly fields: OrderedFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Table {
    switch (variant) {
      case "Account":
        return "Account" as Table;
      case "Did":
        return "Did" as Table;
      case "Appointment":
        return "Appointment" as Table;
      case "Lead":
        return "Lead" as Table;
      case "TaxRate":
        return "TaxRate" as Table;
      case "Site":
        return "Site" as Table;
      case "Employee":
        return "Employee" as Table;
      case "Route":
        return "Route" as Table;
      case "Company":
        return "Company" as Table;
      case "Product":
        return "Product" as Table;
      case "Service":
        return "Service" as Table;
      case "User":
        return "User" as Table;
      case "Order":
        return "Order" as Table;
      case "Payment":
        return "Payment" as Table;
      case "Package":
        return "Package" as Table;
      case "Promotion":
        return "Promotion" as Table;
      case "Represents":
        return "Represents" as Table;
      case "Ordered":
        return "Ordered" as Table;
      default:
        return "Account" as Table;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Table,
  ): Gigaform {
    const initialVariant:
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered" =
      (initial as
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered") ?? "Account";
    let currentVariant = $state<
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
    >(initialVariant);
    let data = $state<Table>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      Account: {
        fields: {} as AccountFieldControllers,
      },
      Did: {
        fields: {} as DidFieldControllers,
      },
      Appointment: {
        fields: {} as AppointmentFieldControllers,
      },
      Lead: {
        fields: {} as LeadFieldControllers,
      },
      TaxRate: {
        fields: {} as TaxRateFieldControllers,
      },
      Site: {
        fields: {} as SiteFieldControllers,
      },
      Employee: {
        fields: {} as EmployeeFieldControllers,
      },
      Route: {
        fields: {} as RouteFieldControllers,
      },
      Company: {
        fields: {} as CompanyFieldControllers,
      },
      Product: {
        fields: {} as ProductFieldControllers,
      },
      Service: {
        fields: {} as ServiceFieldControllers,
      },
      User: {
        fields: {} as UserFieldControllers,
      },
      Order: {
        fields: {} as OrderFieldControllers,
      },
      Payment: {
        fields: {} as PaymentFieldControllers,
      },
      Package: {
        fields: {} as PackageFieldControllers,
      },
      Promotion: {
        fields: {} as PromotionFieldControllers,
      },
      Represents: {
        fields: {} as RepresentsFieldControllers,
      },
      Ordered: {
        fields: {} as OrderedFieldControllers,
      },
    };
    function switchVariant(
      variant:
        | "Account"
        | "Did"
        | "Appointment"
        | "Lead"
        | "TaxRate"
        | "Site"
        | "Employee"
        | "Route"
        | "Company"
        | "Product"
        | "Service"
        | "User"
        | "Order"
        | "Payment"
        | "Package"
        | "Promotion"
        | "Represents"
        | "Ordered",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Table,
      Array<{ field: string; message: string }>
    > {
      return Table.fromObject(data);
    }
    function reset(overrides?: Partial<Table>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Table, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_value") as
      | "Account"
      | "Did"
      | "Appointment"
      | "Lead"
      | "TaxRate"
      | "Site"
      | "Employee"
      | "Route"
      | "Company"
      | "Product"
      | "Service"
      | "User"
      | "Order"
      | "Payment"
      | "Package"
      | "Promotion"
      | "Represents"
      | "Ordered"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_value", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._value = discriminant;
    if (discriminant === "Account") {
    } else if (discriminant === "Did") {
    } else if (discriminant === "Appointment") {
    } else if (discriminant === "Lead") {
    } else if (discriminant === "TaxRate") {
    } else if (discriminant === "Site") {
    } else if (discriminant === "Employee") {
    } else if (discriminant === "Route") {
    } else if (discriminant === "Company") {
    } else if (discriminant === "Product") {
    } else if (discriminant === "Service") {
    } else if (discriminant === "User") {
    } else if (discriminant === "Order") {
    } else if (discriminant === "Payment") {
    } else if (discriminant === "Package") {
    } else if (discriminant === "Promotion") {
    } else if (discriminant === "Represents") {
    } else if (discriminant === "Ordered") {
    }
    return Table.fromStringifiedJSON(JSON.stringify(obj));
  }
}
>>>>>>> Stashed changes

export namespace Item {
  export function defaultValue(): Item {
    return "";
  }
}

export namespace Item {
<<<<<<< Updated upstream
=======
  export function defaultValue(): Item {
    return RecordLink.defaultValue<Service>();
  }
}

export namespace Item {
>>>>>>> Stashed changes
  export function toStringifiedJSON(value: Item): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Item): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Item, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}
<<<<<<< Updated upstream

export namespace Item {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Item, Array<{ field: string; message: string }>> {
=======

export namespace Item {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Item, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Item, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
      return Result.ok<Item>(result);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Item {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Item;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Item.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Item;
  }
  export function validateField<K extends keyof Item>(
    field: K,
    value: Item[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Item>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
}

export namespace Item {
  /** Per-variant error types */ export type RecordLinkProductErrors = {
    _errors: Option<Array<string>>;
  };
  export type RecordLinkServiceErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type RecordLinkProductTainted = {};
  export type RecordLinkServiceTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "RecordLink<Product>" } & RecordLinkProductErrors)
    | ({ _type: "RecordLink<Service>" } & RecordLinkServiceErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "RecordLink<Product>" } & RecordLinkProductTainted)
    | ({ _type: "RecordLink<Service>" } & RecordLinkServiceTainted);
  /** Per-variant field controller types */ export interface RecordLinkProductFieldControllers {}
  export interface RecordLinkServiceFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "RecordLink<Product>" | "RecordLink<Service>";
    readonly data: Item;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "RecordLink<Product>" | "RecordLink<Service>"): void;
    validate(): Result<Item, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Item>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly "RecordLink<Product>": {
      readonly fields: RecordLinkProductFieldControllers;
    };
    readonly "RecordLink<Service>": {
      readonly fields: RecordLinkServiceFieldControllers;
    };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Item {
    switch (variant) {
      case "RecordLink<Product>":
        return RecordLink.defaultValue<Product>() as Item;
      case "RecordLink<Service>":
        return RecordLink.defaultValue<Service>() as Item;
      default:
        return RecordLink.defaultValue<Product>() as Item;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Item,
  ): Gigaform {
    const initialVariant: "RecordLink<Product>" | "RecordLink<Service>" =
      "RecordLink<Product>";
    let currentVariant = $state<"RecordLink<Product>" | "RecordLink<Service>">(
      initialVariant,
    );
    let data = $state<Item>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      "RecordLink<Product>": {
        fields: {} as RecordLinkProductFieldControllers,
      },
      "RecordLink<Service>": {
        fields: {} as RecordLinkServiceFieldControllers,
      },
    };
    function switchVariant(
      variant: "RecordLink<Product>" | "RecordLink<Service>",
    ): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Item,
      Array<{ field: string; message: string }>
    > {
      return Item.fromObject(data);
    }
    function reset(overrides?: Partial<Item>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Item, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "RecordLink<Product>"
      | "RecordLink<Service>"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "RecordLink<Product>") {
    } else if (discriminant === "RecordLink<Service>") {
    }
    return Item.fromStringifiedJSON(JSON.stringify(obj));
  }
}

export type RecordLink<T> = /** @default */ string | T;

export namespace RecordLink {
  export function defaultValue<T>(): RecordLink<T> {
    return "";
  }
}

export namespace RecordLink {
  export function toStringifiedJSON<T>(value: RecordLink<T>): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject<T>(value: RecordLink<T>): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize<T>(
    value: RecordLink<T>,
    ctx: SerializeContext,
  ): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace RecordLink {
  export function fromStringifiedJSON<T>(
    json: string,
    opts?: DeserializeOptions,
  ): Result<RecordLink<T>, Array<{ field: string; message: string }>> {
>>>>>>> Stashed changes
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
<<<<<<< Updated upstream
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Item, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
=======
  export function fromObject<T>(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<RecordLink<T>, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize<T>(obj, ctx);
>>>>>>> Stashed changes
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<RecordLink<T>>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
<<<<<<< Updated upstream
  export function __deserialize(value: any, ctx: DeserializeContext): Item {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Item;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Item.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Item;
=======
  export function __deserialize<T>(
    value: any,
    ctx: DeserializeContext,
  ): RecordLink<T> {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as RecordLink<T>;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "RecordLink.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as RecordLink<T>;
  }
  export function validateField<T, K extends keyof RecordLink<T>>(
    field: K,
    value: RecordLink<T>[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields<T>(
    partial: Partial<RecordLink<T>>,
  ): Array<{ field: string; message: string }> {
    return [];
>>>>>>> Stashed changes
  }
}

export type Actor = /** @default */ User | Employee | Account;

export namespace Actor {
  export function defaultValue(): Actor {
    return User.defaultValue();
  }
}

export namespace Actor {
  export function toStringifiedJSON(value: Actor): string {
    const ctx = SerializeContext.create();
    return JSON.stringify(__serialize(value, ctx));
  }
  export function toObject(value: Actor): unknown {
    const ctx = SerializeContext.create();
    return __serialize(value, ctx);
  }
  export function __serialize(value: Actor, ctx: SerializeContext): unknown {
    if (typeof (value as any)?.__serialize === "function") {
      return (value as any).__serialize(ctx);
    }
    return value;
  }
}

export namespace Actor {
  export function fromStringifiedJSON(
    json: string,
    opts?: DeserializeOptions,
  ): Result<Actor, Array<{ field: string; message: string }>> {
    try {
      const raw = JSON.parse(json);
      return fromObject(raw, opts);
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function fromObject(
    obj: unknown,
    opts?: DeserializeOptions,
  ): Result<Actor, Array<{ field: string; message: string }>> {
    try {
      const ctx = DeserializeContext.create();
      const result = __deserialize(obj, ctx);
      ctx.applyPatches();
      if (opts?.freeze) {
        ctx.freezeAll();
      }
<<<<<<< Updated upstream
      return Result.ok(result);
=======
      return Result.ok<Actor>(result);
>>>>>>> Stashed changes
    } catch (e) {
      if (e instanceof DeserializeError) {
        return Result.err(e.errors);
      }
      const message = e instanceof Error ? e.message : String(e);
      return Result.err([{ field: "_root", message }]);
    }
  }
  export function __deserialize(value: any, ctx: DeserializeContext): Actor {
    if (value?.__ref !== undefined) {
      return ctx.getOrDefer(value.__ref) as Actor;
    }
    if (typeof (value as any)?.__type === "string") {
      throw new Error(
        "Actor.__deserialize: polymorphic deserialization requires type registry (TODO)",
      );
    }
    return value as Actor;
  }
<<<<<<< Updated upstream
=======
  export function validateField<K extends keyof Actor>(
    field: K,
    value: Actor[K],
  ): Array<{ field: string; message: string }> {
    return [];
  }
  export function validateFields(
    partial: Partial<Actor>,
  ): Array<{ field: string; message: string }> {
    return [];
  }
>>>>>>> Stashed changes
}

export namespace Actor {
  /** Per-variant error types */ export type UserErrors = {
    _errors: Option<Array<string>>;
  };
  export type EmployeeErrors = { _errors: Option<Array<string>> };
  export type AccountErrors = { _errors: Option<Array<string>> };
  /** Per-variant tainted types */ export type UserTainted = {};
  export type EmployeeTainted = {};
  export type AccountTainted = {};
  /** Union error type */ export type Errors =
    | ({ _type: "User" } & UserErrors)
    | ({ _type: "Employee" } & EmployeeErrors)
    | ({ _type: "Account" } & AccountErrors);
  /** Union tainted type */ export type Tainted =
    | ({ _type: "User" } & UserTainted)
    | ({ _type: "Employee" } & EmployeeTainted)
    | ({ _type: "Account" } & AccountTainted);
<<<<<<< Updated upstream
  /** Field controller interface */ export interface FieldController<T> {
    readonly path: ReadonlyArray<string | number>;
    readonly name: string;
    readonly constraints: Record<string, unknown>;
    readonly label?: string;
    readonly description?: string;
    readonly placeholder?: string;
    readonly disabled?: boolean;
    readonly readonly?: boolean;
    get(): T;
    set(value: T): void;
    getError(): Option<Array<string>>;
    setError(value: Option<Array<string>>): void;
    getTainted(): Option<boolean>;
    setTainted(value: Option<boolean>): void;
    validate(): Array<string>;
  }
=======
>>>>>>> Stashed changes
  /** Per-variant field controller types */ export interface UserFieldControllers {}
  export interface EmployeeFieldControllers {}
  export interface AccountFieldControllers {}
  /** Union Gigaform interface with variant switching */ export interface Gigaform {
    readonly currentVariant: "User" | "Employee" | "Account";
    readonly data: Actor;
    readonly errors: Errors;
    readonly tainted: Tainted;
    readonly variants: VariantFields;
    switchVariant(variant: "User" | "Employee" | "Account"): void;
    validate(): Result<Actor, Array<{ field: string; message: string }>>;
    reset(overrides?: Partial<Actor>): void;
  }
  /** Variant fields container */ export interface VariantFields {
    readonly User: { readonly fields: UserFieldControllers };
    readonly Employee: { readonly fields: EmployeeFieldControllers };
    readonly Account: { readonly fields: AccountFieldControllers };
  }
  /** Gets default value for a specific variant */ function getDefaultForVariant(
    variant: string,
  ): Actor {
    switch (variant) {
      case "User":
        return User.defaultValue() as Actor;
      case "Employee":
        return Employee.defaultValue() as Actor;
      case "Account":
        return Account.defaultValue() as Actor;
      default:
        return User.defaultValue() as Actor;
    }
  }
  /** Creates a new discriminated union Gigaform with variant switching */ export function createForm(
    initial?: Actor,
  ): Gigaform {
    const initialVariant: "User" | "Employee" | "Account" = "User";
    let currentVariant = $state<"User" | "Employee" | "Account">(
      initialVariant,
    );
    let data = $state<Actor>(initial ?? getDefaultForVariant(initialVariant));
    let errors = $state<Errors>({} as Errors);
    let tainted = $state<Tainted>({} as Tainted);
    const variants: VariantFields = {
      User: {
        fields: {} as UserFieldControllers,
      },
      Employee: {
        fields: {} as EmployeeFieldControllers,
      },
      Account: {
        fields: {} as AccountFieldControllers,
      },
    };
    function switchVariant(variant: "User" | "Employee" | "Account"): void {
      currentVariant = variant;
      data = getDefaultForVariant(variant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    function validate(): Result<
      Actor,
      Array<{ field: string; message: string }>
    > {
      return Actor.fromObject(data);
    }
    function reset(overrides?: Partial<Actor>): void {
      data = overrides
        ? (overrides as typeof data)
        : getDefaultForVariant(currentVariant);
      errors = {} as Errors;
      tainted = {} as Tainted;
    }
    return {
      get currentVariant() {
        return currentVariant;
      },
      get data() {
        return data;
      },
      set data(v) {
        data = v;
      },
      get errors() {
        return errors;
      },
      set errors(v) {
        errors = v;
      },
      get tainted() {
        return tainted;
      },
      set tainted(v) {
        tainted = v;
      },
      variants,
      switchVariant,
      validate,
      reset,
    };
  }
  /** Parses FormData for union type, determining variant from discriminant field */ export function fromFormData(
    formData: FormData,
  ): Result<Actor, Array<{ field: string; message: string }>> {
    const discriminant = formData.get("_type") as
      | "User"
      | "Employee"
      | "Account"
      | null;
    if (!discriminant) {
      return Result.err([
        { field: "_type", message: "Missing discriminant field" },
      ]);
    }
    const obj: Record<string, unknown> = {};
    obj._type = discriminant;
    if (discriminant === "User") {
    } else if (discriminant === "Employee") {
    } else if (discriminant === "Account") {
    }
    return Actor.fromStringifiedJSON(JSON.stringify(obj));
  }
}
