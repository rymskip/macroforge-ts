/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class NativeMapper {
  constructor(mapping: SourceMappingResult)
  isEmpty(): boolean
  originalToExpanded(pos: number): number
  expandedToOriginal(pos: number): number | null
  generatedBy(pos: number): string | null
  mapSpanToOriginal(start: number, length: number): SpanResult | null
  mapSpanToExpanded(start: number, length: number): SpanResult
  isInGenerated(pos: number): boolean
}

export declare class NativePlugin {
  constructor()
  log(message: string): void
  setLogFile(path: string): void
  processFile(filepath: string, code: string, options?: ProcessFileOptions | undefined | null): ExpandResult
  getMapper(filepath: string): NativeMapper | null
  mapDiagnostics(filepath: string, diags: Array<JsDiagnostic>): Array<JsDiagnostic>
}

export declare class PositionMapper {
  constructor(mapping: SourceMappingResult)
  isEmpty(): boolean
  originalToExpanded(pos: number): number
  expandedToOriginal(pos: number): number | null
  generatedBy(pos: number): string | null
  mapSpanToOriginal(start: number, length: number): SpanResult | null
  mapSpanToExpanded(start: number, length: number): SpanResult
  isInGenerated(pos: number): boolean
}
export type NativePositionMapper = PositionMapper

export declare function __macroforgeDebugDescriptors(): Array<string>

export declare function __macroforgeDebugGetModules(): Array<string>

export declare function __macroforgeDebugLookup(module: string, name: string): string

export declare function __macroforgeGetMacroNames(): Array<string>

export declare function __macroforgeGetManifest(): MacroManifest

export declare function __macroforgeIsMacroPackage(): boolean

/**
 * r" Run this macro with the given context
 * r" Called by the TS plugin to execute macro expansion
 */
export declare function __macroforgeRunClone(contextJson: string): string

/**
 * r" Run this macro with the given context
 * r" Called by the TS plugin to execute macro expansion
 */
export declare function __macroforgeRunDebug(contextJson: string): string

/**
 * r" Run this macro with the given context
 * r" Called by the TS plugin to execute macro expansion
 */
export declare function __macroforgeRunDeserialize(contextJson: string): string

/**
 * r" Run this macro with the given context
 * r" Called by the TS plugin to execute macro expansion
 */
export declare function __macroforgeRunEq(contextJson: string): string

/**
 * r" Run this macro with the given context
 * r" Called by the TS plugin to execute macro expansion
 */
export declare function __macroforgeRunSerialize(contextJson: string): string

export declare function checkSyntax(code: string, filepath: string): SyntaxCheckResult

export declare function Clone(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): ClassDecorator

/** Generates a toString() method for debugging */
export declare function debug(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): PropertyDecorator

export declare function Debug(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): ClassDecorator

export interface DecoratorManifestEntry {
  module: string
  export: string
  kind: string
  docs: string
}

export declare function Derive(...features: any[]): ClassDecorator

export declare function Deserialize(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): ClassDecorator

export declare function Eq(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): ClassDecorator

export interface ExpandOptions {
  keepDecorators?: boolean
}

export interface ExpandResult {
  code: string
  types?: string
  metadata?: string
  diagnostics: Array<MacroDiagnostic>
  sourceMapping?: SourceMappingResult
}

/** Expand macros in TypeScript code and return the transformed TS (types) and diagnostics */
export declare function expandSync(code: string, filepath: string, options?: ExpandOptions | undefined | null): ExpandResult

export interface GeneratedRegionResult {
  start: number
  end: number
  sourceMacro: string
}

export interface ImportSourceResult {
  /** Local identifier name in the import statement */
  local: string
  /** Module specifier this identifier was imported from */
  module: string
}

export interface JsDiagnostic {
  start?: number
  length?: number
  message?: string
  code?: number
  category?: string
}

export interface MacroDiagnostic {
  level: string
  message: string
  start?: number
  end?: number
}

export interface MacroManifest {
  version: number
  macros: Array<MacroManifestEntry>
  decorators: Array<DecoratorManifestEntry>
}

export interface MacroManifestEntry {
  name: string
  kind: string
  description: string
  package: string
}

export interface MappingSegmentResult {
  originalStart: number
  originalEnd: number
  expandedStart: number
  expandedEnd: number
}

export declare function parseImportSources(code: string, filepath: string): Array<ImportSourceResult>

export interface ProcessFileOptions {
  keepDecorators?: boolean
  version?: string
}

/** Generates a static fromJSON() method for JSON deserialization with runtime validation */
export declare function serde(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): PropertyDecorator

/** Generates a toJSON() method for JSON serialization */
export declare function serde(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): PropertyDecorator

export declare function Serialize(...features: Array<string | ClassDecorator | PropertyDecorator | ((...args:
any[]) => unknown) | Record<string, unknown>>): ClassDecorator

export interface SourceMappingResult {
  segments: Array<MappingSegmentResult>
  generatedRegions: Array<GeneratedRegionResult>
}

export interface SpanResult {
  start: number
  length: number
}

export interface SyntaxCheckResult {
  ok: boolean
  error?: string
}

export interface TransformResult {
  code: string
  map?: string
  types?: string
  metadata?: string
}

export declare function transformSync(code: string, filepath: string): TransformResult
