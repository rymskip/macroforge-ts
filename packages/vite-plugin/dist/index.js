import { createRequire } from 'module';
import * as fs from 'fs';
import * as path from 'path';
function napiMacrosPlugin(options = {}) {
    let rustTransformer;
    let projectRoot;
    const generateTypes = options.generateTypes !== false; // Default to true
    const typesOutputDir = options.typesOutputDir || 'src/macros/generated';
    const typeGenStrategy = options.typeGenStrategy || 'module-augmentation';
    // Helper function to convert PascalCase to kebab-case
    function toKebabCase(str) {
        return str
            .replace(/([a-z])([A-Z])/g, '$1-$2')
            .replace(/([A-Z])([A-Z][a-z])/g, '$1-$2')
            .toLowerCase();
    }
    // Extract classes with @Derive decorator
    function extractDecoratedClasses(code) {
        const classes = [];
        // Regex to match @Derive decorator and the class it decorates
        const deriveRegex = /@Derive\s*\(([^)]+)\)\s*(?:export\s+)?class\s+(\w+)/gm;
        let match;
        while ((match = deriveRegex.exec(code)) !== null) {
            const featuresStr = match[1];
            const className = match[2];
            // Extract features from the decorator arguments
            const features = featuresStr
                .split(',')
                .map(f => f.trim().replace(/['"]/g, ''))
                .filter(f => f);
            classes.push({ className, features });
        }
        return classes;
    }
    // Generate type definition content
    function generateTypeDef(className, features) {
        const interfaces = [];
        if (features.includes('Debug')) {
            interfaces.push('toString(): string');
        }
        if (features.includes('JSON')) {
            interfaces.push('toJSON(): object');
        }
        // Use a different approach - create an ambient module declaration
        return `// Generated by @ts-macros/vite-plugin
// This file is auto-generated when @Derive decorator is used

// Augment the class with additional methods
declare global {
  interface ${className} {
    ${interfaces.join('\n    ')}
  }
}

// Also declare as a namespace merge for better compatibility
declare namespace ${className} {
  interface prototype {
    ${interfaces.join('\n    ')}
  }
}

export {}
`;
    }
    // Ensure directory exists
    function ensureDir(dir) {
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
    }
    return {
        name: 'vite-plugin-napi-macros',
        enforce: 'pre',
        configResolved(config) {
            projectRoot = config.root;
            // Load the Rust binary
            try {
                const require = createRequire(import.meta.url);
                // This will load the compiled .node binary
                rustTransformer = require('@ts-macros/swc-napi');
            }
            catch (error) {
                console.warn('[vite-plugin-napi-macros] Rust binary not found. Please run `npm run build:rust` first.');
                console.warn(error);
            }
        },
        transform(code, id) {
            // Only transform TypeScript files
            if (!id.endsWith('.ts') && !id.endsWith('.tsx')) {
                return null;
            }
            // Skip node_modules by default
            if (id.includes('node_modules')) {
                return null;
            }
            // Generate type definitions if enabled and we find @Derive decorators
            if (generateTypes && code.includes('@Derive')) {
                const decoratedClasses = extractDecoratedClasses(code);
                if (decoratedClasses.length > 0) {
                    const outputDir = path.join(projectRoot, typesOutputDir);
                    ensureDir(outputDir);
                    // Generate a type definition file for each decorated class
                    decoratedClasses.forEach(({ className, features }) => {
                        const fileName = `${toKebabCase(className)}.d.ts`;
                        const filePath = path.join(outputDir, fileName);
                        const content = generateTypeDef(className, features);
                        // Only write if content changed or file doesn't exist
                        try {
                            const existingContent = fs.existsSync(filePath)
                                ? fs.readFileSync(filePath, 'utf-8')
                                : null;
                            if (existingContent !== content) {
                                fs.writeFileSync(filePath, content);
                                console.log(`[vite-plugin-napi-macros] Generated types for ${className} at ${path.relative(projectRoot, filePath)}`);
                            }
                        }
                        catch (error) {
                            console.error(`[vite-plugin-napi-macros] Failed to write type definition for ${className}:`, error);
                        }
                    });
                }
            }
            // Check if Rust transformer is available
            if (!rustTransformer || !rustTransformer.transformSync) {
                // Return unchanged if transformer not available
                return null;
            }
            try {
                // Call the Rust transformer
                const result = rustTransformer.transformSync(code, id);
                if (result && result.code) {
                    return {
                        code: result.code,
                        map: result.map || null
                    };
                }
            }
            catch (error) {
                console.error(`[vite-plugin-napi-macros] Transform error in ${id}:`, error);
                // Return unchanged on error
                return null;
            }
            return null;
        }
    };
}
export default napiMacrosPlugin;
