import {
  CompletionItem,
  CompletionItemKind,
  InitializeParams,
  InitializeResult,
  ProposedFeatures,
  TextDocumentPositionParams,
  TextDocumentSyncKind,
  createConnection,
  TextDocuments,
} from "vscode-languageserver/node";
import { TextDocument } from "vscode-languageserver-textdocument";
import { fileURLToPath } from "node:url";
import path from "node:path";
import {
  DocumentAnalysis,
  analyzeDocument,
  resolveClassForIdentifier,
} from "./analyzer";

const connection = createConnection(ProposedFeatures.all);
const documents = new TextDocuments(TextDocument);

const analysisCache = new Map<string, DocumentAnalysis>();

connection.onInitialize((_params: InitializeParams): InitializeResult => {
  return {
    capabilities: {
      textDocumentSync: TextDocumentSyncKind.Incremental,
      completionProvider: {
        triggerCharacters: ["."],
        resolveProvider: false,
      },
    },
  };
});

documents.onDidOpen((event) => refreshAnalysis(event.document));
documents.onDidChangeContent((event) => refreshAnalysis(event.document));
documents.onDidClose((event) => analysisCache.delete(event.document.uri));

connection.onCompletion((params: TextDocumentPositionParams) => {
  const document = documents.get(params.textDocument.uri);
  if (!document) {
    return [];
  }

  const analysis = analysisCache.get(document.uri) ?? refreshAnalysis(document);
  if (!analysis) {
    return [];
  }

  const offset = document.offsetAt(params.position);
  const targetIdentifier = extractCompletionIdentifier(
    document.getText(),
    offset,
  );

  if (!targetIdentifier) {
    return [];
  }

  const resolved = resolveClassForIdentifier(
    targetIdentifier,
    offset,
    analysis,
  );

  if (!resolved) {
    return [];
  }

  return buildCompletionItems(resolved.features);
});

documents.listen(connection);
connection.listen();

function refreshAnalysis(document: TextDocument) {
  try {
    const fileName = uriToPath(document.uri);
    const analysis = analyzeDocument(document.getText(), fileName);
    analysisCache.set(document.uri, analysis);
    return analysis;
  } catch (error) {
    connection.console.error(
      `ts-macros-lsp failed to analyze ${document.uri}: ${String(error)}`,
    );
    return undefined;
  }
}

function uriToPath(uri: string) {
  if (uri.startsWith("file://")) {
    return fileURLToPath(uri);
  }

  return path.resolve(uri);
}

function extractCompletionIdentifier(text: string, offset: number) {
  let index = offset - 1;

  while (index >= 0 && isWhitespace(text.charCodeAt(index))) {
    index -= 1;
  }

  let sawDot = false;
  if (index >= 0 && text[index] === ".") {
    sawDot = true;
    index -= 1;
  } else if (index >= 1 && text[index] === "?" && text[index - 1] === ".") {
    sawDot = true;
    index -= 2;
  }

  if (!sawDot) {
    return undefined;
  }

  while (index >= 0 && isWhitespace(text.charCodeAt(index))) {
    index -= 1;
  }

  let end = index;
  while (index >= 0 && isIdentifierPart(text.charCodeAt(index))) {
    index -= 1;
  }

  const start = index + 1;
  if (start > end) {
    return undefined;
  }

  const identifier = text.slice(start, end + 1);
  return isIdentifierStart(identifier.charCodeAt(0)) ? identifier : undefined;
}

function buildCompletionItems(features: string[]): CompletionItem[] {
  const recognized = features.length ? features : ["Debug", "JSON"];
  const items: CompletionItem[] = [];

  if (recognized.includes("Debug")) {
    items.push({
      label: "toString",
      kind: CompletionItemKind.Method,
      detail: "(method) toString(): string",
      documentation: "Generated by @Derive(\"Debug\")",
    });
  }

  if (recognized.includes("JSON")) {
    items.push({
      label: "toJSON",
      kind: CompletionItemKind.Method,
      detail: "(method) toJSON(): Record<string, unknown>",
      documentation: "Generated by @Derive(\"JSON\")",
    });
  }

  return items;
}

function isWhitespace(charCode: number) {
  return charCode === 32 || charCode === 9 || charCode === 10 || charCode === 13;
}

function isIdentifierStart(charCode: number) {
  return (
    (charCode >= 65 && charCode <= 90) ||
    (charCode >= 97 && charCode <= 122) ||
    charCode === 36 ||
    charCode === 95
  );
}

function isIdentifierPart(charCode: number) {
  return (
    isIdentifierStart(charCode) ||
    (charCode >= 48 && charCode <= 57)
  );
}
