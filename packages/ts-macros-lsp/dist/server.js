"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("vscode-languageserver/node");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const node_url_1 = require("node:url");
const node_path_1 = __importDefault(require("node:path"));
const analyzer_1 = require("./analyzer");
const connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all);
const documents = new node_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
const analysisCache = new Map();
connection.onInitialize((_params) => {
    return {
        capabilities: {
            textDocumentSync: node_1.TextDocumentSyncKind.Incremental,
            completionProvider: {
                triggerCharacters: ["."],
                resolveProvider: false,
            },
        },
    };
});
documents.onDidOpen((event) => refreshAnalysis(event.document));
documents.onDidChangeContent((event) => refreshAnalysis(event.document));
documents.onDidClose((event) => analysisCache.delete(event.document.uri));
connection.onCompletion((params) => {
    const document = documents.get(params.textDocument.uri);
    if (!document) {
        return [];
    }
    const analysis = analysisCache.get(document.uri) ?? refreshAnalysis(document);
    if (!analysis) {
        return [];
    }
    const offset = document.offsetAt(params.position);
    const targetIdentifier = extractCompletionIdentifier(document.getText(), offset);
    if (!targetIdentifier) {
        return [];
    }
    const resolved = (0, analyzer_1.resolveClassForIdentifier)(targetIdentifier, offset, analysis);
    if (!resolved) {
        return [];
    }
    return buildCompletionItems(resolved.features);
});
documents.listen(connection);
connection.listen();
function refreshAnalysis(document) {
    try {
        const fileName = uriToPath(document.uri);
        const analysis = (0, analyzer_1.analyzeDocument)(document.getText(), fileName);
        analysisCache.set(document.uri, analysis);
        return analysis;
    }
    catch (error) {
        connection.console.error(`ts-macros-lsp failed to analyze ${document.uri}: ${String(error)}`);
        return undefined;
    }
}
function uriToPath(uri) {
    if (uri.startsWith("file://")) {
        return (0, node_url_1.fileURLToPath)(uri);
    }
    return node_path_1.default.resolve(uri);
}
function extractCompletionIdentifier(text, offset) {
    let index = offset - 1;
    while (index >= 0 && isWhitespace(text.charCodeAt(index))) {
        index -= 1;
    }
    let sawDot = false;
    if (index >= 0 && text[index] === ".") {
        sawDot = true;
        index -= 1;
    }
    else if (index >= 1 && text[index] === "?" && text[index - 1] === ".") {
        sawDot = true;
        index -= 2;
    }
    if (!sawDot) {
        return undefined;
    }
    while (index >= 0 && isWhitespace(text.charCodeAt(index))) {
        index -= 1;
    }
    let end = index;
    while (index >= 0 && isIdentifierPart(text.charCodeAt(index))) {
        index -= 1;
    }
    const start = index + 1;
    if (start > end) {
        return undefined;
    }
    const identifier = text.slice(start, end + 1);
    return isIdentifierStart(identifier.charCodeAt(0)) ? identifier : undefined;
}
function buildCompletionItems(features) {
    const recognized = features.length ? features : ["Debug", "JSON"];
    const items = [];
    if (recognized.includes("Debug")) {
        items.push({
            label: "toString",
            kind: node_1.CompletionItemKind.Method,
            detail: "(method) toString(): string",
            documentation: "Generated by @Derive(\"Debug\")",
        });
    }
    if (recognized.includes("JSON")) {
        items.push({
            label: "toJSON",
            kind: node_1.CompletionItemKind.Method,
            detail: "(method) toJSON(): Record<string, unknown>",
            documentation: "Generated by @Derive(\"JSON\")",
        });
    }
    return items;
}
function isWhitespace(charCode) {
    return charCode === 32 || charCode === 9 || charCode === 10 || charCode === 13;
}
function isIdentifierStart(charCode) {
    return ((charCode >= 65 && charCode <= 90) ||
        (charCode >= 97 && charCode <= 122) ||
        charCode === 36 ||
        charCode === 95);
}
function isIdentifierPart(charCode) {
    return (isIdentifierStart(charCode) ||
        (charCode >= 48 && charCode <= 57));
}
//# sourceMappingURL=server.js.map